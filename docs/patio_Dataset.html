<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>patio</title>
    <link rel="stylesheet" href="./assets/css/bootstrap.css">
    <link rel="stylesheet" href="./assets/css/bootstrap-responsive.css">
    <link rel="stylesheet" href="./assets/js/google-code-prettify/prettify.css">
    <style type="text/css">
        

.subnav-inner {
    width: 100%;
    height: 36px;
    background-color: #EEE;
    background-repeat: repeat-x;
    background-image: -moz-linear-gradient(top, whiteSmoke 0%, #EEE 100%);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, whiteSmoke), color-stop(100%, #EEE));
    background-image: -webkit-linear-gradient(top, whiteSmoke 0%, #EEE 100%);
    background-image: -ms-linear-gradient(top, whiteSmoke 0%, #EEE 100%);
    background-image: -o-linear-gradient(top, whiteSmoke 0%, #EEE 100%);
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr = '#f5f5f5', endColorstr = '#eeeeee', GradientType = 0);
    background-image: linear-gradient(top, whiteSmoke 0%, #EEE 100%);
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
}

.subnav .nav > li > a:hover {
    color: black !important;
}

.subnav .nav li.dropdown .dropdown-toggle .caret,
.subnav .nav li.dropdown.open .caret {
    border-top-color: #999 !important;
    border-bottom-color: #999 !important;
}

.subnav-fixed {
    position: fixed;
    width : 90%;
    margin-right: auto;
    margin-left: auto;
    top: 40px;
    left: 0;
    right: 0;
    z-index: 1020;
    border-color: #D5D5D5;
    border-width: 0 0 1px;
    -webkit-border-radius: 0;
    -moz-border-radius: 0;
    border-radius: 0;
    -webkit-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);
    -moz-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);
    box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);
    filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);
}

.navbar .nav  .dropdown-menu {
    max-height: 500px;
    overflow: auto;
}â€‹

    </style>
    <style type="text/css">
        body {
            padding-top: 60px;
            padding-bottom: 40px;
        }
    </style>
    <script type="text/javascript">
        var init = (function () {
            "use strict";

            var processScroll = (function () {
                var curr = null, prev = null;
                return function (nav) {
                    var $win = $(window);
                    $('.subnav').each(function () {
                        var nav = $(this);
                        var navTop = nav.offset().top - 40;
                        var scrollTop = $win.scrollTop();
                        if (scrollTop >= navTop && curr != nav) {
                            if(curr){
                                curr.removeClass('subnav-fixed')
                                prev = curr;
                            }
                            curr = nav;
                            curr.addClass('subnav-fixed')
                        } else if (curr == nav && scrollTop <= navTop) {
                            curr.removeClass('subnav-fixed');
                            prev.addClass('subnav-fixed');
                            curr = prev;
                        }else{
                            nav.removeClass('subnav-fixed');
                        }
                    });
                };
            })();

            return function () {
                window.prettyPrint && prettyPrint();
                $(".collapse").collapse();
                // fix sub nav on scroll
                processScroll();
                $(window).on('scroll', processScroll)
            }
        })();
    </script>
</head>
<body onload="init()">
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
      
          <a href="./index.html" class="brand">patio</a>
      
      
           <div class="nav-collapse">
      <ul class="nav nav-pills">
      
                 <li><a href="./connecting.html">Connecting</a></li>
                 
                 <li><a href="./models.html">Models</a></li>
                 
                 <li><a href="./associations.html">Associations</a></li>
                 
                 <li><a href="./model-inheritance.html">Model Inheritance</a></li>
                 
                 <li><a href="./querying.html">Querying</a></li>
                 
                 <li><a href="./DDL.html">DDL</a></li>
                 
                 <li><a href="./migrations.html">Migrations</a></li>
                 
                 <li><a href="./logging.html">Logging</a></li>
                 
            

      
        <li class="dropdown">
           <a href="#" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
           <ul class="dropdown-menu">
             
                         <li><a href="./patio.html#.associations">patio.associations</a></li>
               
                         <li><a href="./patio.html#.plugins">patio.plugins</a></li>
               
                         <li><a href="./patio.html#.sql">patio.sql</a></li>
               
                         <li><a href="./patio_sql_Constants.html">patio.sql.Constants</a></li>
               
           </ul>
           </li>
        
        
           <li class="dropdown">
           <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
           <ul class="dropdown-menu">
             
                         <li><a href="./patio.html">patio</a></li>
               
                         <li><a href="./patio_AlterTableGenerator.html">patio.AlterTableGenerator</a></li>
               
                         <li><a href="./patio_AssociationError.html">patio.AssociationError</a></li>
               
                         <li><a href="./patio_ConnectionPool.html">patio.ConnectionPool</a></li>
               
                         <li><a href="./patio_Database.html">patio.Database</a></li>
               
                         <li><a href="./patio_DatabaseError.html">patio.DatabaseError</a></li>
               
                         <li><a href="./patio_Dataset.html">patio.Dataset</a></li>
               
                         <li><a href="./patio_DatasetError.html">patio.DatasetError</a></li>
               
                         <li><a href="./patio_ExpressionError.html">patio.ExpressionError</a></li>
               
                         <li><a href="./patio_MigrationError.html">patio.MigrationError</a></li>
               
                         <li><a href="./patio_Model.html">patio.Model</a></li>
               
                         <li><a href="./patio_ModelError.html">patio.ModelError</a></li>
               
                         <li><a href="./patio_NotImplemented.html">patio.NotImplemented</a></li>
               
                         <li><a href="./patio_PatioError.html">patio.PatioError</a></li>
               
                         <li><a href="./patio_QueryError.html">patio.QueryError</a></li>
               
                         <li><a href="./patio_SchemaGenerator.html">patio.SchemaGenerator</a></li>
               
                         <li><a href="./patio_Time.html">patio.Time</a></li>
               
                         <li><a href="./patio_associations_Association.html">patio.associations.Association</a></li>
               
                         <li><a href="./patio_associations_ManyToMany.html">patio.associations.ManyToMany</a></li>
               
                         <li><a href="./patio_associations_ManyToOne.html">patio.associations.ManyToOne</a></li>
               
                         <li><a href="./patio_associations_ManyToOne.html">patio.associations.ManyToOne</a></li>
               
                         <li><a href="./patio_associations_OneToMany.html">patio.associations.OneToMany</a></li>
               
                         <li><a href="./patio_dataset.html#._Query">patio.dataset._Query</a></li>
               
                         <li><a href="./patio_migrations_IntegerMigrator.html">patio.migrations.IntegerMigrator</a></li>
               
                         <li><a href="./patio_migrations_Migrator.html">patio.migrations.Migrator</a></li>
               
                         <li><a href="./patio_migrations_TimestampMigrator.html">patio.migrations.TimestampMigrator</a></li>
               
                         <li><a href="./patio_plugins_CachePlugin.html">patio.plugins.CachePlugin</a></li>
               
                         <li><a href="./patio_plugins_ClassTableInheritancePlugin.html">patio.plugins.ClassTableInheritancePlugin</a></li>
               
                         <li><a href="./patio_plugins_TimeStampPlugin.html">patio.plugins.TimeStampPlugin</a></li>
               
                         <li><a href="./patio_sql_AliasMethods.html">patio.sql.AliasMethods</a></li>
               
                         <li><a href="./patio_sql_AliasedExpression.html">patio.sql.AliasedExpression</a></li>
               
                         <li><a href="./patio_sql_BitWiseMethods.html">patio.sql.BitWiseMethods</a></li>
               
                         <li><a href="./patio_sql_BooleanConstant.html">patio.sql.BooleanConstant</a></li>
               
                         <li><a href="./patio_sql_BooleanExpression.html">patio.sql.BooleanExpression</a></li>
               
                         <li><a href="./patio_sql_BooleanMethods.html">patio.sql.BooleanMethods</a></li>
               
                         <li><a href="./patio_sql_CaseExpression.html">patio.sql.CaseExpression</a></li>
               
                         <li><a href="./patio_sql_Cast.html#.constructor">patio.sql.Cast.constructor</a></li>
               
                         <li><a href="./patio_sql_CastMethods.html">patio.sql.CastMethods</a></li>
               
                         <li><a href="./patio_sql_ColumnAll.html">patio.sql.ColumnAll</a></li>
               
                         <li><a href="./patio_sql_ComplexExpression.html">patio.sql.ComplexExpression</a></li>
               
                         <li><a href="./patio_sql_ComplexExpressionMethods.html">patio.sql.ComplexExpressionMethods</a></li>
               
                         <li><a href="./patio_sql_Constant.html">patio.sql.Constant</a></li>
               
                         <li><a href="./patio_sql_DateTime.html">patio.sql.DateTime</a></li>
               
                         <li><a href="./patio_sql_Decimal.html">patio.sql.Decimal</a></li>
               
                         <li><a href="./patio_sql_Expression.html">patio.sql.Expression</a></li>
               
                         <li><a href="./patio_sql_Float.html">patio.sql.Float</a></li>
               
                         <li><a href="./patio_sql_GenericExpression.html">patio.sql.GenericExpression</a></li>
               
                         <li><a href="./patio_sql_Identifier.html">patio.sql.Identifier</a></li>
               
                         <li><a href="./patio_sql_InequalityMethods.html">patio.sql.InequalityMethods</a></li>
               
                         <li><a href="./patio_sql_JoinClause.html">patio.sql.JoinClause</a></li>
               
                         <li><a href="./patio_sql_JoinOnClause.html">patio.sql.JoinOnClause</a></li>
               
                         <li><a href="./patio_sql_JoinUsingClause.html">patio.sql.JoinUsingClause</a></li>
               
                         <li><a href="./patio_sql_LiteralString.html#.constructor">patio.sql.LiteralString.constructor</a></li>
               
                         <li><a href="./patio_sql_NoBooleanInputMethods.html">patio.sql.NoBooleanInputMethods</a></li>
               
                         <li><a href="./patio_sql_NumericMethods.html">patio.sql.NumericMethods</a></li>
               
                         <li><a href="./patio_sql_OrderedExpression.html">patio.sql.OrderedExpression</a></li>
               
                         <li><a href="./patio_sql_OrderedMethods.html">patio.sql.OrderedMethods</a></li>
               
                         <li><a href="./patio_sql_PlaceHolderLiteralString.html">patio.sql.PlaceHolderLiteralString</a></li>
               
                         <li><a href="./patio_sql_QualifiedIdentifier.html">patio.sql.QualifiedIdentifier</a></li>
               
                         <li><a href="./patio_sql_QualifyingMethods.html">patio.sql.QualifyingMethods</a></li>
               
                         <li><a href="./patio_sql_SQLFunction.html">patio.sql.SQLFunction</a></li>
               
                         <li><a href="./patio_sql_SQLFunction.html">patio.sql.SQLFunction</a></li>
               
                         <li><a href="./patio_sql_StringConcatenationMethods.html">patio.sql.StringConcatenationMethods</a></li>
               
                         <li><a href="./patio_sql_StringExpression.html">patio.sql.StringExpression</a></li>
               
                         <li><a href="./patio_sql_StringMethods.html">patio.sql.StringMethods</a></li>
               
                         <li><a href="./patio_sql_SubScript.html">patio.sql.SubScript</a></li>
               
                         <li><a href="./patio_sql_SubscriptMethods.html">patio.sql.SubscriptMethods</a></li>
               
                         <li><a href="./patio_sql_Time.html">patio.sql.Time</a></li>
               
                         <li><a href="./patio_sql_TimeStamp.html">patio.sql.TimeStamp</a></li>
               
                         <li><a href="./patio_sql_Year.html">patio.sql.Year</a></li>
               
           </ul>
        </li>
       
      </ul>
      
      <ul class="nav pull-right">
                  <li><a href="https://github.com/Pollenware/patio" target="#github" class="pull-right">github</a></li>
        </ul>
        
      </div>
    </div>
  </div>
</div>


<div class="container-fluid">
    <a name="top"></a>
    <div class="container">



    <a name=""></a>
    <div class="navbar subnav">
    <div class="navbar-inner  subnav-inner">
          <div class="container">
            <a href="#" class="brand">
            patio.Dataset
            
                    
             <span class="label label-success">Public</span>
                    
            
            </a>
           <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                      <span class="icon-bar"></span>
                      <span class="icon-bar"></span>
                      <span class="icon-bar"></span>
                    </a>
                    <div class="nav-collapse">

            <ul class="nav pull-right">
             <li><a href="#constructor">Constructor</a></li>
                        
                        <li><a href="#instanceProperties">Instance Properties</a></li>
                        
                        
                        <li><a href="#staticProperties">Static Properties</a></li>
                        
                        
                        
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Instance Methods<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                
                                <li><a href="./patio_Dataset.html#__aggregateDataset">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __aggregateDataset

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__argumentList">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __argumentList

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__arrayToConditionSpecifier">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __arrayToConditionSpecifier

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__asSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __asSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__columnList">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __columnList

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__createBetweenExpression">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __createBetweenExpression

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__createBoolExpression">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __createBoolExpression

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__defaultServerOpts">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __defaultServerOpts

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__expressionList">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __expressionList

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__hashIdentifierToName">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __hashIdentifierToName

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#__tableRef">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                __tableRef

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_compoundFromSelf">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _compoundFromSelf

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_datasetAlias">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _datasetAlias

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_deleteFromSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _deleteFromSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_deleteOrderSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _deleteOrderSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_deleteWhereSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _deleteWhereSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_filter">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _filter

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_filterExpr">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _filterExpr

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_invertOrder">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _invertOrder

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_joinTypeSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _joinTypeSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalArray">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalArray

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalBoolean">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalBoolean

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalBuffer">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalBuffer

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalDataset">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalDataset

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalDate">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalDate

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalExpression">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalExpression

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalHash">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalHash

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalNull">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalNull

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalNumber">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalNumber

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalObject">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalObject

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalOther">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalOther

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalString">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalString

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalTime">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalTime

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalTimestamp">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalTimestamp

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_literalYear">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _literalYear

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_optionsOverlap">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _optionsOverlap

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_qualifiedExpression">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _qualifiedExpression

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectColumnsSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectColumnsSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectCompoundsSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectCompoundsSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectDistinctSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectDistinctSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectFromSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectFromSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectGroupSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectGroupSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectHavingSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectHavingSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectJoinSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectJoinSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectLimitSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectLimitSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectLockSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectLockSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectOrderSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectOrderSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectWhereSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectWhereSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectWithSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectWithSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_selectWithSqlBase">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _selectWithSqlBase

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_sourceList">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _sourceList

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_splitAlias">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _splitAlias

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_splitString">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _splitString

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_staticSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _staticSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_subselectSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _subselectSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_toTableName">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _toTableName

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_unaliasedIdentifier">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _unaliasedIdentifier

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_updateOrderSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _updateOrderSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_updateSetSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _updateSetSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_updateTableSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _updateTableSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#_updateWhereSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                _updateWhereSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#addGraphAliases">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                addGraphAliases

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#aliasedExpressionSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                aliasedExpressionSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#all">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                all

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#and">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                and

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#avg">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                avg

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#between">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                between

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#booleanConstantSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                booleanConstantSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#caseExpressionSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                caseExpressionSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#castSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                castSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#columnAllSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                columnAllSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#complexExpressionSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                complexExpressionSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#compoundClone">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                compoundClone

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#constantSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                constantSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#count">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                count

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#distinct">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                distinct

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#eq">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                eq

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#except">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                except

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#exclude">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                exclude

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#execute">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                execute

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#executeDdl">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                executeDdl

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#executeDui">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                executeDui

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#executeInsert">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                executeInsert

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#fetchRows">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                fetchRows

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#filter">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                filter

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#find">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                find

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#first">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                first

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#forEach">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                forEach

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#forUpdate">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                forUpdate

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#from">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                from

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#fromSelf">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                fromSelf

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#functionSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                functionSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#get">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                get

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#graph">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                graph

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#graphEach">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                graphEach

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#grep">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                grep

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#group">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                group

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#groupAndCount">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                groupAndCount

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#groupBy">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                groupBy

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#gt">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                gt

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#gte">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                gte

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#having">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                having

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#import">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                import

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#inputIdentifier">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                inputIdentifier

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#insert">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                insert

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#insertMultiple">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                insertMultiple

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#insertSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                insertSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#intersect">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                intersect

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#interval">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                interval

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#invert">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                invert

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#is">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                is

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isEmpty">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isEmpty

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isFalse">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isFalse

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isNot">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isNot

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isNotFalse">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isNotFalse

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isNotNull">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isNotNull

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isNotTrue">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isNotTrue

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isNull">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isNull

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#isTrue">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                isTrue

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#join">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                join

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#joinClauseSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                joinClauseSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#joinOnClauseSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                joinOnClauseSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#joinTable">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                joinTable

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#joinUsingClauseSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                joinUsingClauseSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#last">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                last

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#like">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                like

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#limit">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                limit

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#literal">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                literal

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#lockStyle">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                lockStyle

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#lt">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                lt

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#lte">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                lte

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#map">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                map

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#max">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                max

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#mergeOptions">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                mergeOptions

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#min">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                min

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#multiInsert">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                multiInsert

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#multiInsertSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                multiInsertSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#naked">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                naked

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#negativeBooleanConstantSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                negativeBooleanConstantSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#neq">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                neq

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#notBetween">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                notBetween

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#one">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                one

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#or">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                or

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#order">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                order

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#orderAppend">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                orderAppend

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#orderBy">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                orderBy

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#orderMore">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                orderMore

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#orderPrepend">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                orderPrepend

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#orderedExpressionSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                orderedExpressionSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#outputIdentifier">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                outputIdentifier

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#placeholderLiteralStringSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                placeholderLiteralStringSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#postLoad">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                postLoad

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#qualifiedColumnName">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                qualifiedColumnName

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#qualifiedIdentifierSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                qualifiedIdentifierSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#qualify">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                qualify

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#qualifyTo">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                qualifyTo

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#qualifyToFirstSource">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                qualifyToFirstSource

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#quoteIdentifier">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                quoteIdentifier

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#quoteSchemaTable">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                quoteSchemaTable

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#range">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                range

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#remove">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                remove

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#returning">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                returning

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#reverse">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                reverse

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#reverseOrder">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                reverseOrder

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#save">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                save

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#saveMultiple">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                saveMultiple

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#schemaAndTable">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                schemaAndTable

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#select">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                select

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#selectAll">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                selectAll

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#selectAppend">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                selectAppend

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#selectHash">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                selectHash

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#selectMap">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                selectMap

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#selectMore">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                selectMore

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#selectOrderMap">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                selectOrderMap

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#set">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                set

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#setDefaults">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                setDefaults

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#setGraphAliases">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                setGraphAliases

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#setOverrides">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                setOverrides

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#singleRecord">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                singleRecord

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#singleValue">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                singleValue

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#stringToIdentifier">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                stringToIdentifier

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#subscriptSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                <span class="label label-important">P</span>
                                
                                subscriptSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#sum">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                sum

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#toCsv">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                toCsv

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#toHash">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                toHash

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#truncate">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                truncate

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#unfiltered">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                unfiltered

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#ungraphed">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                ungraphed

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#ungrouped">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                ungrouped

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#union">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                union

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#unlimited">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                unlimited

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#unordered">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                unordered

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#unusedTableAlias">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                unusedTableAlias

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#update">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                update

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#updateSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                updateSql

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#where">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                where

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#with">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                with

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#withRecursive">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                withRecursive

                                </a></li>
                                
                                <li><a href="./patio_Dataset.html#withSql">
                                
                                
                                <span class="label label-label">F</span>
                                
                                
                                        
                                 <span class="label label-success">P</span>
                                        
                                
                                withSql

                                </a></li>
                                
                            </ul>
                        </li>
                        
            </ul>
            </div>
            </div>
     </div>
</div>



    <p>
Class that is used for querying/retirving datasets from a database.

<p> Dynamically genertated methods include
<ul>
    <li>Join methods from <a href='./patio_Dataset.html#'> patio.Dataset.CONDITIONED_JOIN_TYPES</a> and
        <a href='./patio_Dataset.html#'>  patio.Dataset.UNCONDITIONED_JOIN_TYPES</a>, these methods handle the type call
        to <a href='./patio_dataset_Query.html#joinTable'> patio.dataset.Query#joinTable</a>, so to invoke include all arguments that
        <a href='./patio_dataset_Query.html#joinTable'> patio.dataset.Query#joinTable</a> requires except the type parameter. The default list includes.
        <ul>
            <li>Conditioned join types that accept conditions.
                 <ul>
                     <li>inner - INNER JOIN</li>
                     <li>fullOuter - FULL OUTER</li>
                     <li>rightOuter - RIGHT OUTER JOIN</li>
                     <li>leftOuter - LEFT OUTER JOIN</li>
                     <li>full - FULL JOIN</li>
                     <li>right - RIGHT JOIN</li>
                     <li>left - LEFT JOIN</li>
                 </ul>
            </li>
            <li>Unconditioned join types that do not accept join conditions
                 <ul>
                     <li>natural - NATURAL JOIN</li>
                     <li>naturalLeft - NATURAL LEFT JOIN</li>
                     <li>naturalRight - NATURAL RIGHT JOIN</li>
                     <li>naturalFull - NATURA FULLL JOIN</li>
                     <li>cross - CROSS JOIN</li>
                 </ul>
            </li>
        </ul>
     </li>
 </li>
</ul>

<p>
    <h4>Features:</h4>
    <p>
          Features that a particular <a href='./patio_Dataset.html#'> patio.Dataset</a> supports are shown in the example below.
          If you wish to implement an adapter please override these values depending on the database that
          you are developing the adapter for.
     </p>
     <pre class="code">
         var ds = DB.from("test");

         //The default values returned

         //Whether this dataset quotes identifiers.
         //Whether this dataset quotes identifiers.
         ds.quoteIdentifiers //=>true

         //Whether this dataset will provide accurate number of rows matched for
         //delete and update statements.  Accurate in this case is the number of
         //rows matched by the dataset's filter.
         ds.providesAccurateRowsMatched; //=>true

         //Times Whether the dataset requires SQL standard datetimes (false by default,
         // as most allow strings with ISO 8601 format).
         ds.requiresSqlStandardDate; //=>false

         //Whether the dataset supports common table expressions (the WITH clause).
         ds.supportsCte; //=>true

         //Whether the dataset supports the DISTINCT ON clause, false by default.
         ds.supportsDistinctOn; //=>false

         //Whether the dataset supports the INTERSECT and EXCEPT compound operations, true by default.
         ds.supportsIntersectExcept; //=>true

         //Whether the dataset supports the INTERSECT ALL and EXCEPT ALL compound operations, true by default
         ds.supportsIntersectExceptAll; //=>true

         //Whether the dataset supports the IS TRUE syntax.
         ds.supportsIsTrue; //=>true

         //Whether the dataset supports the JOIN table USING (column1, ...) syntax.
         ds.supportsJoinUsing; //=>true

         //Whether modifying joined datasets is supported.
         ds.supportsModifyingJoin; //=>false

         //Whether the IN/NOT IN operators support multiple columns when an
         ds.supportsMultipleColumnIn; //=>true

         //Whether the dataset supports timezones in literal timestamps
         ds.supportsTimestampTimezone; //=>false

         //Whether the dataset supports fractional seconds in literal timestamps
         ds.supportsTimestampUsecs; //=>true

         //Whether the dataset supports window functions.
         ds.supportsWindowFunctions; //=>false
      </pre>
<p>
<p>
    <h4>Actions</h4>
    <p>
        Each dataset does not actually send any query to the database until an action method has
        been called upon it(with the exception of <a href='./patio_Dataset.html#graph'> patio.Dataset#graph</a> because columns
        from the other table might need retrived in order to set up the graph). Each action
        returns a <i>comb.Promise</i> that will be resolved with the result or errback, it is important
        that you account for errors otherwise it can be difficult to track down issues.
        The list of action methods is:
        <ul>
            <li><a href='./patio_Dataset.html#all'> patio.Dataset#all</a></li>
            <li><a href='./patio_Dataset.html#one'> patio.Dataset#one</a></li>
            <li><a href='./patio_Dataset.html#avg'> patio.Dataset#avg</a></li>
            <li><a href='./patio_Dataset.html#count'> patio.Dataset#count</a></li>
            <li><a href='./patio_Dataset.html#columns'> patio.Dataset#columns</a></li>
            <li><a href='./patio_Dataset.html#remove'> patio.Dataset#remove</a></li>
            <li><a href='./patio_Dataset.html#forEach'> patio.Dataset#forEach</a></li>
            <li><a href='./patio_Dataset.html#empty'> patio.Dataset#empty</a></li>
            <li><a href='./patio_Dataset.html#first'> patio.Dataset#first</a></li>
            <li><a href='./patio_Dataset.html#get'> patio.Dataset#get</a></li>
            <li><a href='./patio_Dataset.html#import'> patio.Dataset#import</a></li>
            <li><a href='./patio_Dataset.html#insert'> patio.Dataset#insert</a></li>
            <li><a href='./patio_Dataset.html#save'> patio.Dataset#save</a></li>
            <li><a href='./patio_Dataset.html#insertMultiple'> patio.Dataset#insertMultiple</a></li>
            <li><a href='./patio_Dataset.html#saveMultiple'> patio.Dataset#saveMultiple</a></li>
            <li><a href='./patio_Dataset.html#interval'> patio.Dataset#interval</a></li>
            <li><a href='./patio_Dataset.html#last'> patio.Dataset#last</a></li>
            <li><a href='./patio_Dataset.html#map'> patio.Dataset#map</a></li>
            <li><a href='./patio_Dataset.html#max'> patio.Dataset#max</a></li>
            <li><a href='./patio_Dataset.html#min'> patio.Dataset#min</a></li>
            <li><a href='./patio_Dataset.html#multiInsert'> patio.Dataset#multiInsert</a></li>
            <li><a href='./patio_Dataset.html#range'> patio.Dataset#range</a></li>
            <li><a href='./patio_Dataset.html#selectHash'> patio.Dataset#selectHash</a></li>
            <li><a href='./patio_Dataset.html#selectMap'> patio.Dataset#selectMap</a></li>
            <li><a href='./patio_Dataset.html#selectOrderMap'> patio.Dataset#selectOrderMap</a></li>
            <li><a href='./patio_Dataset.html#set'> patio.Dataset#set</a></li>
            <li><a href='./patio_Dataset.html#singleRecord'> patio.Dataset#singleRecord</a></li>
            <li><a href='./patio_Dataset.html#singleValue'> patio.Dataset#singleValue</a></li>
            <li><a href='./patio_Dataset.html#sum'> patio.Dataset#sum</a></li>
            <li><a href='./patio_Dataset.html#toCsv'> patio.Dataset#toCsv</a></li>
            <li><a href='./patio_Dataset.html#toHash'> patio.Dataset#toHash</a></li>
            <li><a href='./patio_Dataset.html#truncate'> patio.Dataset#truncate</a></li>
            <li><a href='./patio_Dataset.html#update'> patio.Dataset#update</a></li>
        </ul>

    </p>
</p>

</p>
    

    

    
        <a name="staticProperties"></a>
        <em>Static Properties</em>
        <table class='table table-bordered table-striped'><tr><td>Property</td><td>Type</td><td>Default Value</td><td>Description</td></tr><tr><td><em>ACTION_METHODS</em></td><td>String[]</td><td><code>
['all', 'one', 'avg', 'count', 'columns', 'remove', 'forEach', 'isEmpty', 'first',
         'get', 'import', 'insert', 'save', 'insertMultiple', 'saveMultiple', 'interval', 'last',
         'map', 'max', 'min', 'multiInsert', 'range', 'selectHash', 'selectMap', 'selectOrderMap', 'set',
         'singleRecord', 'singleValue', 'sum', 'toCsv', 'toHash', 'truncate', 'update']
         </code></td><td>
List of action methods avaiable on the dataset.

</td><tr><tr><td><em>AND_SEPARATOR</em></td><td>property</td><td><code>" AND "</code></td><td>
Default SQL AND separator.
         </td><tr><tr><td><em>BOOL_FALSE</em></td><td>property</td><td><code>"'f'"</code></td><td>
Default SQL boolean false operator.
         </td><tr><tr><td><em>BOOL_TRUE</em></td><td>property</td><td><code>"'t'"</code></td><td>
Default SQL boolean true operator.
         </td><tr><tr><td><em>COLUMN_CHANGE_OPTS</em></td><td>property</td><td><code>["select", "sql", "from", "join"]</code></td><td>
 The dataset options that require the removal of cached columns
 if changed.
         </td><tr><tr><td><em>COMMA_SEPARATOR</em></td><td>property</td><td><code>'</code></td><td>
Default SQL comma sperator.
         </td><tr><tr><td><em>CONDITIONED_JOIN_TYPES</em></td><td>property</td><td><code>["inner", "fullOuter", "rightOuter", "leftOuter", "full", "right", "left"]</code></td><td>
These strings have {name}Join methods created (e.g. <a href='./patio_Dataset.html#innerJoin'> patio.Dataset#innerJoin</a>) that
call <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a> with the string, passing along the arguments and
block from the method call.
</td><tr><tr><td><em>COUNT_FROM_SELF_OPTS</em></td><td>String[]</td><td><code>
["distinct", "group", "sql", "limit", "compounds"]
         </code></td><td>
List of options that can interfere with the aggregation of a <a href='./patio_Dataset.html#'> patio.Dataset</a>
</td><tr><tr><td><em>COUNT_OF_ALL_AS_COUNT</em></td><td>property</td><td><code>sql.count(sql.literal('*')).as("count")</code></td><td>
Default COUNT expression.
         </td><tr><tr><td><em>DATASET_ALIAS_BASE_NAME</em></td><td>property</td><td><code>'t'</code></td><td>
Default alias for datasets.
         </td><tr><tr><td><em>DELETE_CLAUSE_METHODS</em></td><td>property</td><td><code>clauseMethods("delete"</code></td><td>
Default SQL DELETE clause methods. This may be overrode by adapters.
         </td><tr><tr><td><em>FEATURES</em></td><td>property</td><td><code>
["quoteIdentifiers","providesAccurateRowsMatched","requiresSqlStandardDateTimes","supportsCte",
"supportsDistinctOn","supportsIntersectExcept","supportsIntersectExceptAll","supportsIsTrue","supportsJoinUsing",
"supportsModifyingJoins","supportsMultipleColumnIn","supportsTimestampTimezones","supportsTimestampUsecs",
"supportsWindowFunctions"]
Array of features.
         </code></td><td>
</td><tr><tr><td><em>FOR_UPDATE</em></td><td>property</td><td><code>' FOR UPDATE'</code></td><td>
Default FOR UPDATE SQL fragment.
         </td><tr><tr><td><em>FROM</em></td><td>property</td><td><code>"FROM"</code></td><td>
Default FROM clause
         </td><tr><tr><td><em>INSERT_CLAUSE_METHODS</em></td><td>property</td><td><code>clauseMethods("insert"</code></td><td>
Default SQL INSERT clause. This may be overrode by adapters.
         </td><tr><tr><td><em>IS_LITERALS</em></td><td>property</td><td><code>{NULL:'NULL', true:'TRUE', false:'FALSE'}</code></td><td>
Hash of IS literals
         </td><tr><tr><td><em>IS_OPERATORS</em></td><td>property</td><td><code>ComplexExpression.IS_OPERATORS</code></td><td>
Defaults IS OPERATORS. See <a href='./patio_sql_ComplexExpression.html#'> patio.sql.ComplexExpression.IS_OPERATORS</a>.
         </td><tr><tr><td><em>JOIN_METHODS</em></td><td>property</td><td><code>["join", "joinTable"]</code></td><td>
 All methods that return modified datasets with a joined table added.
         </td><tr><tr><td><em>NON_SQL_OPTIONS</em></td><td>property</td><td><code>["server", "defaults", "overrides", "graph", "eagerGraph", "graphAliases"]</code></td><td>
Which options don't affect the SQL generation.  Used by <a href='./patio_Dataset.html#simpleSelectAll'> patio.Dataset#simpleSelectAll</a>
to determine if this is a simple SELECT * FROM table.
         </td><tr><tr><td><em>NULL</em></td><td>property</td><td><code>"NULL"</code></td><td>
Defaults SQL NULL.
         </td><tr><tr><td><em>N_ARITY_OPERATORS</em></td><td>property</td><td><code>ComplexExpression.N_ARITY_OPERATORS</code></td><td>
Defaults N(Multi arity) OPERATORS. See <a href='./patio_sql_ComplexExpression.html#'> patio.sql.ComplexExpression.N_ARITY_OPERATORS</a>.
         </td><tr><tr><td><em>QUALIFY_KEYS</em></td><td>property</td><td><code>["select", "where", "having", "order", "group"]</code></td><td>
Default SQL clauses that need qualifying. This may be overrode by adapters.
         </td><tr><tr><td><em>QUERY_METHODS</em></td><td>property</td><td><code>['addGraphAliases', "and", "distinct", "except", "exclude", "filter", "find", "is", "isNot",
            "eq", "neq", "lt", "lte", "gt", "gte", "forUpdate", "from", "fromSelf", "graph", "grep", "group",
            "groupAndCount", "groupBy", "having", "intersect", "invert", "limit", "lockStyle", "naked", "or", "order",
            "orderAppend", "orderBy", "orderMore", "orderPrepend", "qualify", "reverse",
            "reverseOrder", "select", "selectAll", "selectAppend", "selectMore", "setDefaults",
            "setGraphAliases", "setOverrides", "unfiltered", "ungraphed", "ungrouped", "union", "unlimited",
            "unordered", "where", "with", "withRecursive", "withSql"]</code></td><td>
Methods that return modified datasets
         </td><tr><tr><td><em>QUESTION_MARK</em></td><td>property</td><td><code>/\?/g</code></td><td>
Regexp used to replace '?' in <a href='./patio_sql_PlaceHolderLiteralString.html#'> patio.sql.PlaceHolderLiteralString</a>
         </td><tr><tr><td><em>RETURNING</em></td><td>property</td><td><code>" RETURNING "</code></td><td>
Default SQL 'RETURNING' literal string
         </td><tr><tr><td><em>SELECT_CLAUSE_METHODS</em></td><td>property</td><td><code>clauseMethods("select"</code></td><td>
Default SQL SELECT clause. This may be overrode by adapters.
         </td><tr><tr><td><em>SPACE</em></td><td>property</td><td><code>" "</code></td><td>
Default space to use when building SQL queries
         </td><tr><tr><td><em>SQL_WITH</em></td><td>property</td><td><code>"WITH"</code></td><td>
Default SQL WITH base. This may be overrode by adapters.
         </td><tr><tr><td><em>TWO_ARITY_OPERATORS</em></td><td>property</td><td><code>ComplexExpression.TWO_ARITY_OPERATORS</code></td><td>
Defaults TWO OPERATORS. See <a href='./patio_sql_ComplexExpression.html#'> patio.sql.ComplexExpression.TWO_ARITY_OPERATORS</a>.
         </td><tr><tr><td><em>UNCONDITIONED_JOIN_TYPES</em></td><td>property</td><td><code>["natural", "naturalLeft", "naturalRight", "naturalFull", "cross"]</code></td><td>

These strings have {name}Join methods created (e.g. naturalJoin) that
call <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a>.  They only accept a single table
argument which is passed to <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a>, and they throw an error
if called with a block.
</td><tr><tr><td><em>UPDATE_CLAUSE_METHODS</em></td><td>property</td><td><code>clauseMethods("update"</code></td><td>
Default SQL UPDATE clause. This may be overrode by adapters.
         </td><tr><tr><td><em>WILDCARD</em></td><td>property</td><td><code>new LiteralString('*')</code></td><td>
Default SQL '*' literal string.
         </td><tr></table>
    
    
        <a name="instanceProperties"></a>
        <em>Instance Properties</em>
        <table class='table table-bordered table-striped'><tr><td>Property</td><td>Type</td><td>Default Value</td><td>Description</td></tr><tr><td>columns</td><td>{comb.Promise}

 Returns a promise that is resolved with the columns in the result set in order as an array of strings.
If the columns are currently cached, then the promise is immediately resolved with the cached value. Otherwise,
a SELECT query is performed to retrieve a single row in order to get the columns.

If you are looking for all columns for a single table and maybe some information about
each column (e.g. database type), see {@link patio.Database#schema}.

<pre class="code">
 DB.from("table").columns.then(function(columns){
       // => ["id", "name"]
  });
</pre></td><td><code>function (){
   var ret = new Promise();
   if (this.__columns) {
       ret.callback(this.__columns);
   } else {
       var ds = this.unfiltered().unordered().mergeOptions({distinct:null, limit:1});
       ds.forEach().then(hitch(this, function () {
           this.__columns = ds.__columns || [];
           ret.callback(this.__columns);
       }), hitch(ret, "errback"));
   }
   return ret;
               
}</code></td><td>
</td><tr><tr><td>firstSourceAlias</td><td>String</td><td></td><td>The first source (primary table) for this dataset. If the table is aliased, returns the aliased name.                                     throws a {patio.DatasetError} tf the dataset doesn't have a table. <pre class="code">   DB.from("table").firstSourceAlias;   //=> "table"    DB.from("table___t").firstSourceAlias;   //=> "t" </pre></td><tr><tr><td>firstSourceTable</td><td>String</td><td></td><td>The first source (primary table) for this dataset.  If the dataset doesn't                                      have a table, raises a <a href='./patio_erros_DatasetError.html#'> patio.erros.DatasetError</a>. <pre class="code">   DB.from("table").firstSourceTable;         //=> "table"   DB.from("table___t").firstSourceTable;         //=> "t" </pre></td><tr><tr><td>identifierInputMethod</td><td>String</td><td></td><td>this is the method that will be called on each identifier returned from the database.                                          This value will be defaulted to whatever the identifierInputMethod                                          is on the database used in initialization.</td><tr><tr><td>identifierOutputMethod</td><td>String</td><td></td><td>this is the method that will be called on each identifier sent to the database.                                          This value will be defaulted to whatever the identifierOutputMethod                                          is on the database used in initialization.</td><tr><tr><td>isSimpleSelectAll</td><td>Boolean</td><td></td><td>Returns true if this dataset is a simple SELECT * FROM {table}, otherwise false. <pre class="code">     DB.from("items").isSimpleSelectAll; //=> true     DB.from("items").filter({a : 1}).isSimpleSelectAll; //=> false </pre></td><tr><tr><td>providesAccurateRowsMatched</td><td>boolean</td><td><code>true</code></td><td>Whether this dataset will provide accurate number of rows matched for
  delete and update statements.  Accurate in this case is the number of
  rows matched by the dataset's filter.</td><tr><tr><td>quoteIdentifiers</td><td>boolean</td><td><code>true</code></td><td>Whether this dataset quotes identifiers.</td><tr><tr><td>requiresSqlStandardDate</td><td>boolean</td><td><code>false</code></td><td>Whether the dataset requires SQL standard datetimes (false by default,
                                                    as most allow strings with ISO 8601 format).</td><tr><tr><td>rowCb</td><td>Function</td><td></td><td>callback to be invoked for each row returned from the database.                      the return value will be used as the result of query. The rowCb can also return a promise,                      The resolved value of the promise will be used as result.</td><tr><tr><td>supportsCte</td><td>boolean</td><td><code>true</code></td><td>Whether the dataset supports common table expressions (the WITH clause).</td><tr><tr><td>supportsDistinctOn</td><td>boolean</td><td><code>false</code></td><td>Whether the dataset supports the DISTINCT ON clause, false by default.</td><tr><tr><td>supportsIntersectExcept</td><td>boolean</td><td><code>true</code></td><td>Whether the dataset supports the INTERSECT and EXCEPT compound operations, true by default.</td><tr><tr><td>supportsIntersectExceptAll</td><td>boolean</td><td><code>true</code></td><td>Whether the dataset supports the INTERSECT ALL and EXCEPT ALL compound operations, true by default.</td><tr><tr><td>supportsIsTrue</td><td>boolean</td><td><code>true</code></td><td>Whether the dataset supports the IS TRUE syntax.</td><tr><tr><td>supportsJoinUsing</td><td>boolean</td><td><code>true</code></td><td>Whether the dataset supports the JOIN table USING (column1, ...) syntax.</td><tr><tr><td>supportsModifyingJoin</td><td>boolean</td><td><code>false</code></td><td>Whether modifying joined datasets is supported.</td><tr><tr><td>supportsMultipleColumnIn</td><td>boolean</td><td><code>true</code></td><td>Whether the IN/NOT IN operators support multiple columns when an</td><tr><tr><td>supportsTimestampTimezone</td><td>boolean</td><td><code>false</code></td><td>Whether the dataset supports timezones in literal timestamps</td><tr><tr><td>supportsTimestampUsecs</td><td>boolean</td><td><code>true</code></td><td>Whether the dataset supports fractional seconds in literal timestamps</td><tr><tr><td>supportsWindowFunctions</td><td>boolean</td><td><code>false</code></td><td>Whether the dataset supports window functions.</td><tr></table>
    

    <a name="constructor"></a>
    <h3>Constructor</h3>

    <em>Defined dataset/index.js</em>
    
    
    
        
            <em>Source</em>
            <pre class="prettyprint linenums lang-js">
function (db,opts){
   this._super(arguments);
   this.db = db;
   this.__opts = {};
   this.__rowCb = null;
   if (db) {
       this.__quoteIdentifiers = db.quoteIdentifiers;
       this.__identifierInputMethod = db.identifierInputMethod;
       this.__identifierOutputMethod = db.identifierOutputMethod;
   }
           
}
            </pre>
      
    

  
  
    <a name="__aggregateDataset"></a>
    <h3>
        __aggregateDataset
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._optionsOverlap(this._static.COUNT_FROM_SELF_OPTS) ? this.fromSelf() : this.unordered();
           
}
    </pre>
    


  
    <a name="__argumentList"></a>
    <h3>
        __argumentList
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Do a simple join of the arguments (which should be strings) separated by commas
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args){
   return args.join(this._static.COMMA_SEPARATOR)
           
}
    </pre>
    


  
    <a name="__arrayToConditionSpecifier"></a>
    <h3>
        __arrayToConditionSpecifier
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : array of elements to make a condition specifier out of</li>
    
        <li> <em>defaultOp</em>  : the value to assign a value if one is not provided.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>[[]]</code> an array of two element arrays.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr,defaultOp){
   var ret = [];
   arr.forEach(function (a) {
       if (comb.isString(a)) {
           a = this.stringToIdentifier(a);
       }
       if (comb.isInstanceOf(a, Identifier)) {
           ret.push([a, defaultOp]);
       } else if (comb.isHash(a)) {
           ret = ret.concat(array.toArray(a));
       } else {
           throw new QueryError(&quot;Invalid condition specifier &quot; + a);
       }
   }, this);
   return ret;
           
}
    </pre>
    


  
    <a name="__asSql"></a>
    <h3>
        __asSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
SQL fragment for specifying an alias.  expression should already be literalized.
         </p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>expression</em>  : </li>
    
        <li> <em>alias</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (expression,alias){
   return string.format(&quot;%s AS %s&quot;, expression, this.quoteIdentifier(alias));
           
}
    </pre>
    


  
    <a name="__columnList"></a>
    <h3>
        __columnList
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Converts an array of column names into a comma seperated string of
column names. If the array is empty, a wildcard (*) is returned.
         </p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>columns</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (columns){
   return (!columns || columns.length == 0) ? this._static.WILDCARD : this.__expressionList(columns);
           
}
    </pre>
    


  
    <a name="__createBetweenExpression"></a>
    <h3>
        __createBetweenExpression
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
ds.__createBetweenExpression({x : [1,2]}) =&gt; //=&gt; WHERE ((x &gt;= 1) AND (x &lt;= 10))
ds.__createBetweenExpression({x : [1,2]}, true) =&gt; //=&gt; WHERE ((x &lt; 1) OR (x &gt; 10))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object where the keys are columns and the values are two element arrays.</li>
    
        <li> <em>invert?</em>  : if set to true it inverts the between to make it not between the two values</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.sql.BooleanExpression</code> a boolean expression containing the between expression.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj,invert){
   var pairs = [];
   for (var i in obj) {
       var v = obj[i];
       if (comb.isArray(v) &amp;&amp; v.length) {
           var ident = this.stringToIdentifier(i);
           pairs.push(new BooleanExpression(&quot;AND&quot;, new BooleanExpression(&quot;gte&quot;, ident, v[0]), new BooleanExpression(&quot;lte&quot;, ident, v[1])));
       } else {
           throw new QueryError(&quot;Between requires an array for the value&quot;);
       }
   }
   var ret = pairs.length == 1 ? pairs[0] : BooleanExpression.fromArgs([&quot;AND&quot;].concat(pairs))
   return invert ? BooleanExpression.invert(ret) : ret;
           
}
    </pre>
    


  
    <a name="__createBoolExpression"></a>
    <h3>
        __createBoolExpression
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Creates a boolean expression that each key is compared to its value using the provided operator.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
ds.__createBoolExpression(&quot;gt&quot;, {x : 1, y:2, z : 5}) //=&gt; WHERE ((x &gt; 1) AND (y &gt; 2) AND (z &gt; 5))
ds.__createBoolExpression(&quot;gt&quot;, [[x, 1], [y,2], [z, 5]) //=&gt; WHERE ((x &gt; 1) AND (y &gt; 2) AND (z &gt; 5))
ds.__createBoolExpression(&quot;lt&quot;, {x : 1, y:2, z : 5}) //=&gt; WHERE ((x &lt; 1) AND (y &lt; 2) AND (z &lt; 5))
ds.__createBoolExpression(&quot;lt&quot;, [[x, 1], [y,2], [z, 5]) //=&gt; WHERE ((x &lt; 1) AND (y &lt; 2) AND (z &lt; 5))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>op</em>  : valid boolean expression operator to capare each K,V pair with</li>
    
        <li> <em>obj</em>  : object or two dimensional array containing key value pairs</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.sql.BooleanExpression</code> boolean expression joined by a AND of each key value pair compared by the op</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (op,obj){
   var pairs = [];
   if (Expression.isConditionSpecifier(obj)) {
       if (comb.isHash(obj)) {
           obj = comb.array.toArray(obj);
       }
       obj.forEach(function (pair) {
           pairs.push(new BooleanExpression(op, new Identifier(pair[0]), pair[1]));
       });
   }
   return pairs.length == 1 ? pairs[0] : BooleanExpression.fromArgs([&quot;AND&quot;].concat(pairs));
           
}
    </pre>
    


  
    <a name="__defaultServerOpts"></a>
    <h3>
        __defaultServerOpts
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>opts</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (opts){
   return comb.merge({server:this.__opts.server || &quot;default&quot;}, opts);
           
}
    </pre>
    


  
    <a name="__expressionList"></a>
    <h3>
        __expressionList
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Converts an array of expressions into a comma separated string of
expressions.
         </p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>columns</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (columns){
   return columns.map(this.literal, this).join(this._static.COMMA_SEPARATOR);
           
}
    </pre>
    


  
    <a name="__hashIdentifierToName"></a>
    <h3>
        __hashIdentifierToName
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>identifier</em>  : identifier to resolve to a string.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String</code> the string version of the identifier.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (identifier){
   return comb.isString(identifier) ? this.__hashIdentifierToName(this.stringToIdentifier(identifier)) :
       comb.isInstanceOf(identifier, Identifier) ? identifier.value :
           comb.isInstanceOf(identifier, QualifiedIdentifier) ? identifier.column :
               comb.isInstanceOf(identifier, AliasedExpression) ? identifier.alias : identifier;
           
}
    </pre>
    


  
    <a name="__tableRef"></a>
    <h3>
        __tableRef
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>t</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment specifying a table name.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (t){
   return comb.isString(t) ? this._quotedIdentifier(t) : this.literal(t);
           
}
    </pre>
    


  
    <a name="_compoundFromSelf"></a>
    <h3>
        _compoundFromSelf
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Return a [@link patio.sql._Query#fromSelf} dataset if an order or limit is specified, so it works as expected
with UNION, EXCEPT, and INTERSECT clauses.
         </p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var opts = this.__opts;
   return (opts[&quot;limit&quot;] || opts[&quot;order&quot;]) ? this.fromSelf() : this;
           
}
    </pre>
    


  
    <a name="_datasetAlias"></a>
    <h3>
        _datasetAlias
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
The alias to use for datasets, takes a number to make sure the name is unique.
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>number</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (number){
   return this._static.DATASET_ALIAS_BASE_NAME + number;
           
}
    </pre>
    


  
    <a name="_deleteFromSql"></a>
    <h3>
        _deleteFromSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._selectFromSql();
           
}
    </pre>
    


  
    <a name="_deleteOrderSql"></a>
    <h3>
        _deleteOrderSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._selectOrderSql();
           
}
    </pre>
    


  
    <a name="_deleteWhereSql"></a>
    <h3>
        _deleteWhereSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._selectWhereSql();
           
}
    </pre>
    


  
    <a name="_filter"></a>
    <h3>
        _filter
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>clause</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (clause){
   var cond = comb.argsToArray(arguments).slice(1), cb;
   if (cond.length &amp;&amp; comb.isFunction(cond[cond.length - 1])) {
       cb = cond.pop();
   }
   cond = cond.length == 1 ? cond[0] : cond
   if ((cond == null || cond == undefined || cond === &quot;&quot;) || (comb.isArray(cond) &amp;&amp; cond.length == 0 &amp;&amp; !cb) || (comb.isObject(cond) &amp;&amp; comb.isEmpty(cond) &amp;&amp; !cb)) {
       return this.mergeOptions();
   } else {
       cond = this._filterExpr(cond, cb);
       var cl = this.__opts[clause];
       cl &amp;&amp; (cond = new BooleanExpression(&quot;AND&quot;, cl, cond));
       var opts = {};
       opts[clause] = cond;
       return this.mergeOptions(opts);
   }
           
}
    </pre>
    


  
    <a name="_filterExpr"></a>
    <h3>
        _filterExpr
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>expr</em>  : </li>
    
        <li> <em>cb</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (expr,cb){
   expr = (comb.isUndefined(expr) || comb.isNull(expr) || (comb.isArray(expr) &amp;&amp; !expr.length)) ? null : expr;
   if (expr &amp;&amp; cb) {
       return new BooleanExpression(&quot;AND&quot;, this._filterExpr(expr), this._filterExpr(cb))
   } else if (cb) {
       expr = cb
   }
   if (comb.isInstanceOf(expr, Expression)) {
       if (comb.isInstanceOf(expr, NumericExpression, StringExpression)) {
           throw new QueryError(&quot;Invalid SQL Expression type : &quot; + expr);
       }
       return expr;
   } else if (comb.isArray(expr)) {
       if (expr.length) {
           var first = expr[0];
           if (comb.isString(first)) {
               return new PlaceHolderLiteralString(first, expr.slice(1), true);
           } else if (Expression.isConditionSpecifier(expr)) {
               return BooleanExpression.fromValuePairs(expr)
           } else {
               return BooleanExpression.fromArgs([&quot;AND&quot;].concat(expr.map(function (e) {
                   return this._filterExpr(e);
               }, this)));
           }
       }
   } else if (comb.isFunction(expr)) {
       return this._filterExpr(expr.call(sql, sql));
   } else if (comb.isBoolean(expr)) {
       return new BooleanExpression(&quot;NOOP&quot;, expr);
   } else if (comb.isString(expr)) {
       return this.stringToIdentifier(expr);
   } else if (comb.isInstanceOf(expr, LiteralString)) {
       return new LiteralString(&quot;(&quot; + expr + &quot;)&quot;);
   } else if (comb.isHash(expr)) {
       return BooleanExpression.fromValuePairs(expr);
   } else {
       throw new QueryError(&quot;Invalid filter argument&quot;);
   }
           
}
    </pre>
    


  
    <a name="_invertOrder"></a>
    <h3>
        _invertOrder
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>order</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (order){
   var ret = order;
   if (order) {
       ret = order.map(function (o) {
           if (comb.isInstanceOf(o, OrderedExpression)) {
               return o.invert();
           } else {
               return new OrderedExpression(comb.isString(o) ? new Identifier(o) : o);
           }
       }, this);
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_joinTypeSql"></a>
    <h3>
        _joinTypeSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
SQL fragment specifying a JOIN type, splits a camelCased join type
and converts to uppercase/
         </p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>joinType</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (joinType){
   return (joinType || &quot;&quot;).replace(/([a-z]+)|([A-Z][a-z]+)/g,
       function (m) {
           return m.toUpperCase() + &quot; &quot;;
       }
   ).trimRight() + &quot; JOIN&quot;;
           
}
    </pre>
    


  
    <a name="_literalArray"></a>
    <h3>
        _literalArray
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for Array.  Treats as an expression if an array of all two pairs, or as a SQL array otherwise.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   return Expression.isConditionSpecifier(v) ? this._literalExpression(BooleanExpression.fromValuePairs(v)) : this._arraySql(v);
           
}
    </pre>
    


  
    <a name="_literalBoolean"></a>
    <h3>
        _literalBoolean
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>b</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for a boolean.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (b){
   return b ? this._static.BOOL_TRUE : this._static.BOOL_FALSE;
           
}
    </pre>
    


  
    <a name="_literalBuffer"></a>
    <h3>
        _literalBuffer
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>b</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for Buffer, treated as an expression</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (b){
   return &quot;X&#x27;&quot; + b.toString(&quot;hex&quot;) + &quot;&#x27;&quot;;
           
}
    </pre>
    


  
    <a name="_literalDataset"></a>
    <h3>
        _literalDataset
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>dataset</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for Dataset.  Does a subselect inside parantheses.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (dataset){
   return string.format(&quot;(%s)&quot;, this._subselectSql(dataset));
           
}
    </pre>
    


  
    <a name="_literalDate"></a>
    <h3>
        _literalDate
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>date</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for Date, using the ISO8601 format.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (date){
   return (this.requiresSqlStandardDateTimes ? &quot;DATE &#x27;&quot; : &quot;&#x27;&quot;) + patio.dateToString(date) + &quot;&#x27;&quot;;
           
}
    </pre>
    


  
    <a name="_literalExpression"></a>
    <h3>
        _literalExpression
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for SQL::Expression, result depends on the specific type of expression.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   return v.toString(this);
           
}
    </pre>
    


  
    <a name="_literalHash"></a>
    <h3>
        _literalHash
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for Hash, treated as an expression</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   return this._literalExpression(BooleanExpression.fromValuePairs(v));
           
}
    </pre>
    


  
    <a name="_literalNull"></a>
    <h3>
        _literalNull
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p></p>



    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for null</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._static.NULL;
           
}
    </pre>
    


  
    <a name="_literalNumber"></a>
    <h3>
        _literalNumber
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>num</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for a number.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (num){
   var ret = &quot;&quot; + num;
   if (isNaN(num) || num == Infinity) {
       ret = string.format(&quot;&#x27;%s&#x27;&quot;, ret);
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_literalObject"></a>
    <h3>
        _literalObject
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for Hash, treated as an expression</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   return this._literalExpression(BooleanExpression.fromValuePairs(v));
           
}
    </pre>
    


  
    <a name="_literalOther"></a>
    <h3>
        _literalOther
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for a type of object not handled by <a href='./patio_dataset.html#literal'> patio.dataset._Sql#literal</a>.
If object has a method sqlLiteral then it is called with this dataset as the first argument,
otherwise raises an error. Classes implementing sqlLiteral should call a class-specific method
on the dataset provided and should add that method to <a href='./patio_dataset_Dataset.html#'> patio.dataset.Dataset</a>, allowing for adapters
to provide customized literalizations.
If a database specific type is allowed, this should be overriden in a subclass.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   if (comb.isFunction(v.sqlLiteral)) {
       return v.sqlLiteral(this);
   } else {
       throw string.format(&quot;can&#x27;t express %j as a SQL literal&quot;, [v]);
   }
           
}
    </pre>
    


  
    <a name="_literalString"></a>
    <h3>
        _literalString
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for String.  Doubles \ and ' by default.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   var parts = this._splitString(v);
   var table = parts[0], column = parts[1], alias = parts[2];
   if (!alias) {
       return column &amp;&amp; table ? this._literalExpression(QualifiedIdentifier.fromArgs([table, column])) : &quot;&#x27;&quot;
           + v.replace(/\\/g, &quot;\\\\&quot;).replace(/&#x27;/g, &quot;&#x27;&#x27;&quot;) + &quot;&#x27;&quot;
   } else {
       return this.literal(new AliasedExpression(column
           &amp;&amp; table ? QualifiedIdentifier.fromArgs([table, column]) : new Identifier(column), alias));
   }
           
}
    </pre>
    


  
    <a name="_literalTime"></a>
    <h3>
        _literalTime
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for a timestamp, using the ISO8601 format.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   return this.formatTimestamp(v, this._static.TIME_FORMAT);
           
}
    </pre>
    


  
    <a name="_literalTimestamp"></a>
    <h3>
        _literalTimestamp
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for a timestamp, using the ISO8601 format.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   return this.formatTimestamp(v, this._static.TIMESTAMP_FORMAT)
           
}
    </pre>
    


  
    <a name="_literalYear"></a>
    <h3>
        _literalYear
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>o</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for a year.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (o){
   return patio.dateToString(o, this._static.YEAR_FORMAT);
           
}
    </pre>
    


  
    <a name="_optionsOverlap"></a>
    <h3>
        _optionsOverlap
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Return true if the dataset has a non-null value for any key in opts.
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>opts</em>  : the options to compate this datasets options to</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>Boolean</code> true if the dataset has a non-null value for any key in opts.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (opts){
   var o = [];
   for (var i in this.__opts) {
       if (!comb.isUndefinedOrNull(this.__opts[i])) {
           o.push(i);
       }
   }
   return !(comb.array.intersect(comb.array.compact(o), opts).length == 0);
           
}
    </pre>
    


  
    <a name="_qualifiedExpression"></a>
    <h3>
        _qualifiedExpression
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>

Qualify the given expression to the given table.
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>e</em>  : </li>
    
        <li> <em>table</em>  : the table to qualify the expression to</li>
    
        <li> <em>column</em> <code>patio.sql.Expression</code> : the expression to qualify</li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (e,table){
   var h, i, args;
   if (comb.isString(e)) {
       //this should not be hit but here just for completeness
       return this.stringToIdentifier(e);
   } else if (comb.isArray(e)) {
       return e.map(function (exp) {
           return this._qualifiedExpression(exp, table);
       }, this);
   } else if (comb.isInstanceOf(e, Identifier)) {
       return new QualifiedIdentifier(table, e);
   } else if (comb.isInstanceOf(e, OrderedExpression)) {
       return new OrderedExpression(this._qualifiedExpression(e.expression, table), e.descending,
           {nulls:e.nulls});
   } else if (comb.isInstanceOf(e, AliasedExpression)) {
       return new AliasedExpression(this._qualifiedExpression(e.expression, table), e.alias);
   } else if (comb.isInstanceOf(e, CaseExpression)) {
       args = [this._qualifiedExpression(e.conditions, table), this._qualifiedExpression(e.def, table)];
       if (e.hasExpression) {
           args.push(this._qualifiedExpression(e.expression, table));
       }
       return CaseExpression.fromArgs(args);
   } else if (comb.isInstanceOf(e, Cast)) {
       return new Cast(this._qualifiedExpression(e.expr, table), e.type);
   } else if (comb.isInstanceOf(e, SQLFunction)) {
       return SQLFunction.fromArgs([e.f].concat(this._qualifiedExpression(e.args, table)));
   } else if (comb.isInstanceOf(e, ComplexExpression)) {
       return ComplexExpression.fromArgs([e.op].concat(this._qualifiedExpression(e.args, table)));
   } else if (comb.isInstanceOf(e, SubScript)) {
       return new SubScript(this._qualifiedExpression(e.f, table), this._qualifiedExpression(e.sub, table));
   } else if (comb.isInstanceOf(e, PlaceHolderLiteralString)) {
       args = [];
       var eArgs = e.args;
       if (comb.isHash(eArgs)) {
           h = {};
           for (i in eArgs) {
               h[i] = this._qualifiedExpression(eArgs[i], table);
           }
           args = h;
       } else {
           args = this._qualifiedExpression(eArgs, table);
       }
       return new PlaceHolderLiteralString(e.str, args, e.parens);
   } else if (comb.isHash(e)) {
       h = {};
       for (i in e) {
           h[this._qualifiedExpression(i, table) + &quot;&quot;] = this._qualifiedExpression(e[i], table);
       }
       return h;
   } else {
       return e;
   }
           
}
    </pre>
    


  
    <a name="_selectColumnsSql"></a>
    <h3>
        _selectColumnsSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the columns selected</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return &quot; &quot; + this.__columnList(this.__opts.select);
           
}
    </pre>
    


  
    <a name="_selectCompoundsSql"></a>
    <h3>
        _selectCompoundsSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the EXCEPT, INTERSECT, or UNION clause.
This uses a subselect for the compound datasets used, because using parantheses doesn't
work on all databases.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var opts = this.__opts, compounds = opts.compounds, ret = &quot;&quot;;
   if (compounds) {
       compounds.forEach(function (c) {
           var type = c[0], dataset = c[1], all = c[2];
           ret += string.format(&quot; %s%s %s&quot;, type.toUpperCase(), all ? &quot; ALL&quot; : &quot;&quot;,
               this._subselectSql(dataset));
       }, this);
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_selectDistinctSql"></a>
    <h3>
        _selectDistinctSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p></p>



    <em>Returns</em>
    <ul>
    
        <li>  the DISTINCT clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var distinct = this.__opts.distinct, ret = &quot;&quot;;
   if (distinct) {
       ret = &quot; DISTINCT&quot;;
       if (distinct.length) {
           ret += string.format(&quot; ON (%s)&quot;, this.__expressionList(distinct));
       }
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_selectFromSql"></a>
    <h3>
        _selectFromSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the sql to add the list of tables to select FROM</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var from = this.__opts.from;
   return from ? string.format(&quot; %s%s&quot;, this._static.FROM, this._sourceList(from)) : &quot;&quot;;
           
}
    </pre>
    


  
    <a name="_selectGroupSql"></a>
    <h3>
        _selectGroupSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the GROUP BY clause</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var group = this.__opts.group;
   return group ? string.format(&quot; GROUP BY %s&quot;, this.__expressionList(group)) : &quot;&quot;;
           
}
    </pre>
    


  
    <a name="_selectHavingSql"></a>
    <h3>
        _selectHavingSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the sql to add the filter criteria in the HAVING clause</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var having = this.__opts.having;
   return having ? string.format(&quot; HAVING %s&quot;, this.literal(having)) : &quot;&quot;;
           
}
    </pre>
    


  
    <a name="_selectJoinSql"></a>
    <h3>
        _selectJoinSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the JOIN clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var join = this.__opts.join, ret = &quot;&quot;;
   if (join) {
       join.forEach(function (j) {
           ret += this.literal(j)
       }, this);
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_selectLimitSql"></a>
    <h3>
        _selectLimitSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the LIMIT and OFFSET clauses.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var ret = &quot;&quot;, limit = this.__opts.limit, offset = this.__opts.offset;
   !comb.isUndefined(limit) &amp;&amp; !comb.isNull(limit) &amp;&amp; (ret += string.format(&quot; LIMIT %s&quot;, this.literal(limit)));
   !comb.isUndefined(offset) &amp;&amp; !comb.isNull(offset) &amp;&amp; (ret +=
       string.format(&quot; OFFSET %s&quot;, this.literal(offset)));
   return ret;
           
}
    </pre>
    


  
    <a name="_selectLockSql"></a>
    <h3>
        _selectLockSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  SQL for different locking modes.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var lock = this.__opts.lock, ret = &quot;&quot;;
   if (lock) {
       if (lock == &quot;update&quot;) {
           ret += this._static.FOR_UPDATE;
       } else {
           ret += &quot; &quot; + lock;
       }
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_selectOrderSql"></a>
    <h3>
        _selectOrderSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the SQL ORDER BY clause fragment.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var order = this.__opts.order;
   return order ? string.format(&quot; ORDER BY %s&quot;, this.__expressionList(order)) : &quot;&quot;;
           
}
    </pre>
    


  
    <a name="_selectWhereSql"></a>
    <h3>
        _selectWhereSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  the SQL WHERE clause fragment.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var where = this.__opts.where;
   return where ? string.format(&quot; WHERE %s&quot;, this.literal(where)) : &quot;&quot;;
           
}
    </pre>
    


  
    <a name="_selectWithSql"></a>
    <h3>
        _selectWithSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL WITH clause fragment.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql){
   var wit = this.__opts[&quot;with&quot;], ret = &quot;&quot;;
   if (wit &amp;&amp; wit.length) {
       ret = string.format(&quot;%s %s %s&quot;, this._selectWithSqlBase(), wit.map(
           function (w) {
               var r = &quot;&quot;;
               r += this.quoteIdentifier(w.name);
               w.args &amp;&amp; (r += string.format(&quot;(%s)&quot;, this.__argumentList(w.args)));
               r += &quot; AS &quot; + this._literalDataset(w.dataset);
               return r;
           }, this).join(this._static.COMMA_SEPARATOR), sql);
   } else {
       ret = sql;
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_selectWithSqlBase"></a>
    <h3>
        _selectWithSqlBase
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  The base keyword to use for the SQL WITH clause</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._static.SQL_WITH;
           
}
    </pre>
    


  
    <a name="_sourceList"></a>
    <h3>
        _sourceList
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Converts an array of source names into into a comma separated list.
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>source</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (source){
   if (!Array.isArray(source)) {
       source = [source];
   }
   if (!source || !source.length) {
       throw new QueryError(&quot;No source specified for the query&quot;);
   }
   return &quot; &quot; + source.map(
       function (s) {
           return this.__tableRef(s);
       }, this).join(this._static.COMMA_SEPARATOR);
           
}
    </pre>
    


  
    <a name="_splitAlias"></a>
    <h3>
        _splitAlias
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Splits a possible implicit alias, handling both <a href='./patio_sql_AliasedExpression.html#'> patio.sql.AliasedExpression</a>s
and strings.  Returns an array of two elements, with the first being the
main expression, and the second being the alias. Alias may be null if it is a
string that does not contain an alias {table}___{alias}.
         </p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>c</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (c){
   var ret;
   if (comb.isInstanceOf(c, AliasedExpression)) {
       ret = [c.expression, c.alias];
   } else if (comb.isString(c)) {
       var parts = this._splitString(c), cTable = parts[0], column = parts[1], alias = parts[2];
       if (alias) {
           ret = [cTable ? new QualifiedIdentifier(cTable, column) : column, alias];
       } else {
           ret = [c, null];
       }
   } else {
       ret = [c, null];
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_splitString"></a>
    <h3>
        _splitString
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/index.js</em>

<p>
Can either be a string or null.


</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
//columns
 table__column___alias //=&gt; table.column as alias
 table__column //=&gt; table.column
 //tables
 schema__table___alias //=&gt; schema.table as alias
 schema__table //=&gt; schema.table

//name and alias
columnOrTable___alias //=&gt; columnOrTable as alias
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>s</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String[]</code> an array with the elements being:
<ul>
     <li>For columns :[table, column, alias].</li>
     <li>For tables : [schema, table, alias].</li>
</ul></li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (s){
   var ret, m;
   if ((m = s.match(this._static.COLUMN_REF_RE1)) != null) {
       ret = m.slice(1);
   }
   else if ((m = s.match(this._static.COLUMN_REF_RE2)) != null) {
       ret = [null, m[1], m[2]];
   }
   else if ((m = s.match(this._static.COLUMN_REF_RE3)) != null) {
       ret = [m[1], m[2], null];
   }
   else {
       ret = [null, s, null];
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_staticSql"></a>
    <h3>
        _staticSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL to use if this dataset uses static SQL.  Since static SQL
can be a PlaceholderLiteralString in addition to a String,
we literalize nonstrings.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql){
   return comb.isString(sql) ? sql : this.literal(sql);
           
}
    </pre>
    


  
    <a name="_subselectSql"></a>
    <h3>
        _subselectSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>ds</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment for a subselect using the given database's SQL.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (ds){
   return ds.sql;
           
}
    </pre>
    


  
    <a name="_toTableName"></a>
    <h3>
        _toTableName
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Returns a string that is the name of the table.

</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>name</em>  : the object to get the table name from.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String</code> the name of the table.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> If the name is not a String <a href='./patio_sql_Identifier.html#'> patio.sql.Identifier</a>,
<a href='./patio_sql_QualifiedIdentifier.html#'> patio.sql.QualifiedIdentifier</a> or <a href='./patio_sql_AliasedExpression.html#'> patio.sql.AliasedExpression</a>.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (name){
   var ret;
   if (comb.isString(name)) {
       var parts = this._splitString(name);
       var schema = parts[0], table = parts[1], alias = parts[2];
       ret = (schema || alias) ? alias || table : table;
   } else if (comb.isInstanceOf(name, Identifier)) {
       ret = name.value;
   } else if (comb.isInstanceOf(name, QualifiedIdentifier)) {
       ret = this._toTableName(name.column);
   } else if (comb.isInstanceOf(name, AliasedExpression)) {
       ret = this.__toAliasedTableName(name.alias);
   } else {
       throw new QueryError(&quot;Invalid object to retrieve the table name from&quot;);
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_unaliasedIdentifier"></a>
    <h3>
        _unaliasedIdentifier
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Return the unaliased part of the identifier.  Handles both
implicit aliases in strings, as well as <a href='./patio_sql_AliasedExpression.html#'> patio.sql.AliasedExpression</a>s.
Other objects are returned as is.

</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>c</em>  : </li>
    
        <li> <em>tableAlias</em> <code>String|patio.sql.AliasedExpression|*</code> : the object to un alias</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.sql.QualifiedIdentifier|String|*</code> the unaliased portion of the identifier</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (c){
   if (comb.isString(c)) {
       var parts = this._splitString(c);
       var table = parts[0], column = parts[1];
       if (table) {
           return new QualifiedIdentifier(table, column);
       }
       return column;
   } else if (comb.isInstanceOf(c, AliasedExpression)) {
       return c.expression;
   } else {
       return c;
   }
           
}
    </pre>
    


  
    <a name="_updateOrderSql"></a>
    <h3>
        _updateOrderSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._selectOrderSql();
           
}
    </pre>
    


  
    <a name="_updateSetSql"></a>
    <h3>
        _updateSetSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>



    <em>Returns</em>
    <ul>
    
        <li>  The SQL fragment specifying the columns and values to SET.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var values = this.__opts.values, defs = this.__opts.defaults, overrides = this.__opts.overrides;
   var st = &quot;&quot;;
   if (comb.isArray(values)) {
       var v = [], mergedDefsAndOverrides = false, length = values.length;
       for (var i = 0; i &lt; length; i++) {
           var val = values[i];
           if (comb.isHash(val)) {
               mergedDefsAndOverrides = true;
               val = comb.merge({}, defs || {}, val);
               val = comb.merge({}, val, overrides || {});
               for (var j in val) {
                   var ident = this.stringToIdentifier(j);
                   v.push(this.quoteIdentifier(ident) + &quot; = &quot; + this.literal(val[j]));
               }
           } else if (comb.isInstanceOf(val, Expression)) {
               v.push(this._literalExpression(val).replace(/^\(|\)$/g, &quot;&quot;));
           } else {
               v.push(val);
           }
       }
       if (!mergedDefsAndOverrides) {
           var val = comb.merge({}, defs || {});
           val = comb.merge({}, val, overrides || {});
           for (var i in val) {
               var ident = this.stringToIdentifier(i);
               v.push(this.quoteIdentifier(ident) + &quot; = &quot; + this.literal(val[i]));
           }
       }
       st += v.join(this._static.COMMA_SEPARATOR);
   } else {
       st = values;
   }
   return &quot; SET &quot; + st;
           
}
    </pre>
    


  
    <a name="_updateTableSql"></a>
    <h3>
        _updateTableSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  SQL fragment specifying the tables to delete from.
Includes join table if modifying joins is allowed.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql){
   var ret = this._sourceList(this.__opts.from);
   if (this.supportsModifyingJoins) {
       ret += this._selectJoinSql();
   }
   return ret;
           
}
    </pre>
    


  
    <a name="_updateWhereSql"></a>
    <h3>
        _updateWhereSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._selectWhereSql();
           
}
    </pre>
    


  
    <a name="addGraphAliases"></a>
    <h3>
        addGraphAliases
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/graph.js</em>

<p>
Adds the given graph aliases to the list of graph aliases to use,
unlike <a href='./patio_Dataset.html#setGraphAliases'> patio.Dataset#setGraphAliases</a>, which replaces the list (the equivalent
of <a href='./patio_Dataset.html#selectMore'> patio.Dataset#selectMore</a> when graphing).  See <a href='./patio_Dataset.html#setGraphAliases'> patio.Dataset#setGraphAliases</a>.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
var DB = patio.defaultDatabase;
 // SELECT ..., table.column AS someAlias
  DB.from(&quot;table&quot;).addGraphAliases({someAlias : [&quot;table&quot;, &quot;column&quot;]);
  //returns from graphing
  // =&gt; {table : {column : someAlias_value, ...}, ...}
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>graphAliases</em>  : the graph aliases to use.          Where key is the alias name and the value is an array where arr[0] = 'tableName' arr[1] = "colName'.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> deep copy of the original dataset with the added graphAliases.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (graphAliases){
   var ds = this.selectMore.apply(this, this.__graphAliasColumns(graphAliases));
   ds.__opts.graphAliases = comb.merge((ds.__opts.graphAliases || (ds.__opts.graph ? ds.__opts.graph.columnAliases : {}) || {}), graphAliases);
   return ds;
       
}
    </pre>
    


  
    <a name="aliasedExpressionSql"></a>
    <h3>
        aliasedExpressionSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>ae</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (ae){
   return this.__asSql(this.literal(ae.expression), ae.alias);
           
}
    </pre>
    


  
    <a name="all"></a>
    <h3>
        all
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a Promise that is resolved with an array with all records in the dataset.
If a block is given, the array is iterated over after all items have been loaded.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT * FROM table
DB.from(&quot;table&quot;).all().then(function(res){
     //res === [{id : 1, ...}, {id : 2, ...}, ...];
});
// Iterate over all rows in the table
var myArr = [];
var rowPromise = DB.from(&quot;table&quot;).all(function(row){ myArr.push(row);});
rowPromise.then(function(rows){
   //=&gt; rows == myArr;
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>block</em>  : a block to be called with each item. The return value of the block is ignored.</li>
    
        <li> <em>cb?</em>  : a block to invoke when the action is done</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved with an array of rows.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (block,cb){
   var a = [];
   var ret = new Promise();
   this.forEach(hitch(this, function (r) {
       a.push(r);
   })).then(hitch(this, function () {
       this.postLoad(a);
       if (block) {
           a.forEach(block, this);
       }
       ret.callback(a);
   }), hitch(ret, &quot;errback&quot;));
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="and"></a>
    <h3>
        and
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Adds a futher filter to an existing filter using AND. This method is identical to <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>
except it expects an existing filter.

<p>
    <b>For parameter types see <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>.</b>
</p>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;table&quot;).filter(&quot;a&quot;).and(&quot;b&quot;).sql;
     //=&gt;SELECT * FROM table WHERE a AND b
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the condtion added to the WHERE/HAVING clause added.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> If no WHERE?HAVING clause exists.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var tOpts = this.__opts, clauseObj = tOpts[tOpts.having ? &quot;having&quot; : &quot;where&quot;];
   if (clauseObj) {
       return this.filter.apply(this, arguments);
   } else {
       throw new QueryError(&quot;No existing filter found&quot;);
   }
           
}
    </pre>
    


  
    <a name="avg"></a>
    <h3>
        avg
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise that is resolved with the average value for the given column.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT avg(number) FROM table LIMIT 1
DB.from(&quot;table&quot;).avg(&quot;number&quot;).then(function(avg){
     // avg === 3
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : the column to average</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved with the average value of the column.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   return this.__aggregateDataset().get(sql.avg(this.stringToIdentifier(column)), cb);
           
}
    </pre>
    


  
    <a name="between"></a>
    <h3>
        between
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a cloned dataset with a between clause added
to the where clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
ds.notBetween({x:[1, 2]}).sql;
         //=&gt; SELECT * FROM test WHERE ((x &gt;= 1) OR (x &lt;= 2))

 ds.find({x:{notBetween:[1, 2]}}).sql;
         //=&gt; SELECT * FROM test WHERE ((x &gt;= 1) OR (x &lt;= 2))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object where the key is the column and the value is an array where the first element                     is the item to be greater than or equal to than and the second item is less than or equal to than.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with a between clause added
to the where clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBetweenExpression(obj));
           
}
    </pre>
    


  
    <a name="booleanConstantSql"></a>
    <h3>
        booleanConstantSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>constant</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (constant){
   return this.literal(constant)
           
}
    </pre>
    


  
    <a name="caseExpressionSql"></a>
    <h3>
        caseExpressionSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>ce</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (ce){
   var sql = &#x27;(CASE &#x27;;
   if (ce.expression) {
       sql += this.literal(ce.expression) + &quot; &quot;;
   }
   var conds = ce.conditions;
   if (comb.isArray(conds)) {
       conds.forEach(function (cond) {
           sql += string.format(&quot;WHEN %s THEN %s&quot;, this.literal(cond[0]), this.literal(cond[1]));
       }, this);
   } else if (comb.isHash(conds)) {
       for (var i in conds) {
           sql += string.format(&quot;WHEN %s THEN %s&quot;, this.literal(i), this.literal(conds[i]));
       }
   }
   return string.format(&quot;%s ELSE %s END)&quot;, sql, this.literal(ce.def));
           
}
    </pre>
    


  
    <a name="castSql"></a>
    <h3>
        castSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>expr</em>  : </li>
    
        <li> <em>type</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (expr,type){
   return string.format(&quot;CAST(%s AS %s)&quot;, this.literal(expr), this.db.castTypeLiteral(type));
           
}
    </pre>
    


  
    <a name="columnAllSql"></a>
    <h3>
        columnAllSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>ca</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (ca){
   return  string.format(&quot;%s.*&quot;, this.quoteSchemaTable(ca.table));
           
}
    </pre>
    


  
    <a name="complexExpressionSql"></a>
    <h3>
        complexExpressionSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>op</em>  : </li>
    
        <li> <em>args</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (op,args){
   var newOp;
   var isOperators = this._static.IS_OPERATORS, isLiterals = this._static.IS_LITERALS;
   if ((newOp = isOperators[op]) != null) {
       var r = args[1], v = comb.isNull(r) ? isLiterals.NULL : isLiterals[r];
       if (r == null || this.supportsIsTrue) {
           if (comb.isUndefined(v)) {
               throw new QueryError(string.format(&quot;Invalid argument(&#x27;%s&#x27;) used for IS operator&quot;, r));
           }
           l = args[0];
           return string.format(&quot;(%s %s %s)&quot;, comb.isString(l) ? l : this.literal(l), newOp, v);
       } else if (op == &quot;IS&quot;) {
           return this.complexExpressionSql(&quot;EQ&quot;, args);
       } else {
           return this.complexExpressionSql(&quot;OR&quot;,
               [BooleanExpression.fromArgs([&quot;NEQ&quot;].concat(args)), new BooleanExpression(&quot;IS&quot;, args[0],
                   null)]);
       }
   } else if ([&quot;IN&quot;, &quot;NOTIN&quot;].indexOf(op) != -1) {
       var cols = args[0], vals = args[1], colArray = comb.isArray(cols), valArray = false, emptyValArray = false;
       if (comb.isArray(vals)) {
           valArray = true;
           emptyValArray = vals.length == 0;
       }
       if (colArray) {
           if (emptyValArray) {
               if (op == &quot;IN&quot;) {
                   return this.literal(BooleanExpression.fromValuePairs(cols.map(function (x) {
                       return  [x, x];
                   }), &quot;AND&quot;, true));
               } else {
                   return this.literal({1:1});
               }
           } else if (!this.supportsMultipleColumnIn) {
               if (valArray) {
                   var expr = BooleanExpression.fromArgs([&quot;OR&quot;].concat(vals.map(function (vs) {
                       return BooleanExpression.fromValuePairs(array.zip(cols, vs))
                   })));
                   return this.literal(op == &quot;IN&quot; ? expr : expr.invert())
               }
           } else {
               //If the columns and values are both arrays, use _arraySql instead of
               //literal so that if values is an array of two element arrays, it
               //will be treated as a value list instead of a condition specifier.
               return string.format(&quot;(%s %s %s)&quot;, comb.isString(cols) ? cols : this.literal(cols),
                   ComplexExpression.IN_OPERATORS[op],
                   valArray ? this._arraySql(vals) : this.literal(vals));
           }
       }
       else {
           if (emptyValArray) {
               if (op == &quot;IN&quot;) {
                   return this.literal(BooleanExpression.fromValuePairs([
                       [cols, cols]
                   ], &quot;AND&quot;, true));
               } else {
                   return this.literal({1:1});
               }
           } else {
               return string.format(&quot;(%s %s %s)&quot;, comb.isString(cols) ? cols : this.literal(cols),
                   ComplexExpression.IN_OPERATORS[op], this.literal(vals));
           }
       }
   } else if ((newOp = this._static.TWO_ARITY_OPERATORS[op]) != null) {
       var l = args[0];
       return string.format(&quot;(%s %s %s)&quot;, comb.isString(l) ? l : this.literal(l), newOp,
           this.literal(args[1]));
   } else if ((newOp = this._static.N_ARITY_OPERATORS[op]) != null) {
       return string.format(&quot;(%s)&quot;, args.map(this.literal, this).join(&quot; &quot; + newOp + &quot; &quot;));
   } else if (op == &quot;NOT&quot;) {
       return string.format(&quot;NOT %s&quot;, this.literal(args[0]));
   } else if (op == &quot;NOOP&quot;) {
       return this.literal(args[0]);
   } else {
       throw new QueryError(&quot;Invalid operator &quot; + op);
   }
           
}
    </pre>
    


  
    <a name="compoundClone"></a>
    <h3>
        compoundClone
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Add the dataset to the list of compounds

</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>type</em>  : the type of compound (i.e. "union", "intersect")</li>
    
        <li> <em>dataset</em>  : the dataset to add to</li>
    
        <li> <em>options</em>  : </li>
    
        <li> <em>Object?</em>  : [options={}] compound option to use (i.e {all : true})</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> ds with the dataset added to the compounds.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (type,dataset,options){
   var ds = this._compoundFromSelf().mergeOptions({compounds:(comb.array.toArray(this.__opts.compounds || [])).concat([
       [type, dataset._compoundFromSelf(), options.all]
   ])});
   return options.fromSelf === false ? ds : ds.fromSelf(options);
           
}
    </pre>
    


  
    <a name="constantSql"></a>
    <h3>
        constantSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>constant</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (constant){
   return &quot;&quot; + constant;
           
}
    </pre>
    


  
    <a name="count"></a>
    <h3>
        count
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise that is resolved with the number of records in the dataset.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT COUNT(*) AS count FROM table LIMIT 1
DB.from(&quot;table&quot;).count().then(function(count){
    //count === 3;
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved with the the number of records in the dataset.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cb){
   var ret = new Promise();
   this.__aggregateDataset().get(sql.COUNT(sql.literal(&quot;*&quot;)).as(&quot;count&quot;)).then(hitch(this, function (res) {
       ret.callback(parseInt(res, 10));
   }), hitch(ret, &quot;errback&quot;));
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="distinct"></a>
    <h3>
        distinct
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the SQL DISTINCT clause.
The DISTINCT clause is used to remove duplicate rows from the
output.  If arguments are provided, uses a DISTINCT ON clause,
in which case it will only be distinct on those columns, instead
of all returned columns.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).distinct().sqll
     //=&gt; SELECT DISTINCT * FROM items
DB.from(&quot;items&quot;).order(&quot;id&quot;).distinct(&quot;id&quot;).sql;
     //=&gt; SELECT DISTINCT ON (id) * FROM items ORDER BY id
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : variable number of arguments used to create                                                 the DISTINCT ON clause.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the DISTINCT/DISTINCT ON clause added.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> If arguments are given and DISTINCT ON is not supported.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args){
   args = comb.argsToArray(arguments);
   if (args.length &amp;&amp; !this.supportsDistinctOn) {
       throw new QueryError(&quot;DISTICT ON is not supported&quot;);
   }
   args = args.map(function (a) {
       return comb.isString(a) ? new Identifier(a) : a;
   });
   return this.mergeOptions({distinct:args});
           
}
    </pre>
    


  
    <a name="eq"></a>
    <h3>
        eq
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>

Returns a cloned dataset with an equal expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).eq({x : 1});
         //=&gt; SELECT * FROM test WHERE (x = 1)
 DB.from(&quot;test&quot;).eq({x : 1, y : 10});
         //=&gt; SELECT * FROM test WHERE ((x = 1) AND (y = 10))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object used to create the equal expression</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the equal expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBoolExpression(&quot;eq&quot;, obj));
           
}
    </pre>
    


  
    <a name="except"></a>
    <h3>
        except
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Adds an EXCEPT clause using a second dataset object.
An EXCEPT compound dataset returns all rows in the current dataset
that are not in the given dataset.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).except(DB.from(&quot;other_items&quot;)).sql;
     //=&gt; SELECT * FROM items EXCEPT SELECT * FROM other_items

DB.from(&quot;items&quot;).except(DB.from(&quot;other_items&quot;),
                       {all : true, fromSelf : false}).sql;
     //=&gt; SELECT * FROM items EXCEPT ALL SELECT * FROM other_items

DB.from(&quot;items&quot;).except(DB.from(&quot;other_items&quot;),
                       {alias : &quot;i&quot;}).sql;
     //=&gt;SELECT * FROM (SELECT * FROM items EXCEPT SELECT * FROM other_items) AS i
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>dataset</em>  : the dataset to use to create the EXCEPT clause.</li>
    
        <li> <em>opts?</em>  : options to use when creating the EXCEPT clause</li>
    
        <li> <em>opt.alias?</em> <code>String|patio.sql.Identifier</code> : Use the given value as the <a href='./patio_Dataset.html#fromSelf'> patio.Dataset#fromSelf</a> alias.</li>
    
        <li> <em>opts.all?</em> <code>Boolean</code> : Set to true to use EXCEPT ALL instead of EXCEPT, so duplicate rows can occur</li>
    
        <li> <em>opts.fromSelf?</em> <code>Boolean</code> : Set to false to not wrap the returned dataset in a <a href='./patio_Dataset.html#fromSelf'> patio.Dataset#fromSelf</a>, use with care.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the EXCEPT clause added.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> if the operation is not supported.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (dataset,opts){
   opts = comb.isUndefined(opts) ? {} : opts;
   if (!comb.isHash(opts)) {
       opts = {all:true};
   }
   if (!this.supportsIntersectExcept) {
       throw new QueryError(&quot;EXCEPT not supoorted&quot;);
   } else if (opts.hasOwnProperty(&quot;all&quot;) &amp;&amp; !this.supportsIntersectExceptAll) {
       throw new QueryError(&quot;EXCEPT ALL not supported&quot;);
   }
   return this.compoundClone(&quot;except&quot;, dataset, opts);
           
}
    </pre>
    


  
    <a name="exclude"></a>
    <h3>
        exclude
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Performs the inverse of <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>.  Note that if you have multiple filter
conditions, this is not the same as a negation of all conditions. For argument types see
<a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).exclude({category : &quot;software&quot;).sql;
     //=&gt; SELECT * FROM items WHERE (category != &#x27;software&#x27;)

DB.from(&quot;items&quot;).exclude({category : &#x27;software&#x27;, id : 3}).sql;
     //=&gt; SELECT * FROM items WHERE ((category != &#x27;software&#x27;) OR (id != 3))
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the excluded conditions applied to the HAVING/WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var cond = comb.argsToArray(arguments), tOpts = this.__opts;
   var clause = (tOpts[&quot;having&quot;] ? &quot;having&quot; : &quot;where&quot;), clauseObj = tOpts[clause];
   cond = cond.length &gt; 1 ? cond : cond[0];
   cond = this._filterExpr.call(this, cond);
   cond = BooleanExpression.invert(cond);
   if (clauseObj) {
       cond = new BooleanExpression(&quot;AND&quot;, clauseObj, cond)
   }
   var opts = {};
   opts[clause] = cond;
   return this.mergeOptions(opts);
           
}
    </pre>
    


  
    <a name="execute"></a>
    <h3>
        execute
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
        <li> <em>opts</em>  : </li>
    
        <li> <em>block</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql,opts,block){
   if (comb.isFunction(opts)) {
       block = opts;
       opts = {};
   } else {
       opts = opts || {};
   }
   return this.db.execute(sql, comb.merge({server:this.__opts.server || &quot;readOnly&quot;}, opts), block);
           
}
    </pre>
    


  
    <a name="executeDdl"></a>
    <h3>
        executeDdl
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
        <li> <em>opts</em>  : </li>
    
        <li> <em>block</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql,opts,block){
   opts = opts || {};
   return this.db.executeDdl(sql, this.__defaultServerOpts(opts), block);
           
}
    </pre>
    


  
    <a name="executeDui"></a>
    <h3>
        executeDui
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
        <li> <em>opts</em>  : </li>
    
        <li> <em>block</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql,opts,block){
   opts = opts || {};
   return this.db.executeDui(sql, this.__defaultServerOpts(opts), block);
           
}
    </pre>
    


  
    <a name="executeInsert"></a>
    <h3>
        executeInsert
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
        <li> <em>opts</em>  : </li>
    
        <li> <em>block</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql,opts,block){
   opts = opts || {};
   return this.db.executeInsert(sql, this.__defaultServerOpts(opts), block);
           
}
    </pre>
    


  
    <a name="fetchRows"></a>
    <h3>
        fetchRows
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : </li>
    
        <li> <em>cb</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql,cb){
   throw new NotImplemented(&quot;fetchRows must be implemented by the adapter&quot;);
           
}
    </pre>
    


  
    <a name="filter"></a>
    <h3>
        filter
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the given conditions applied to it.
If the query already has a HAVING clause, then the conditions are applied to the
HAVING clause otherwise they are applied to the WHERE clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).filter({id : 3}).sql;
     //=&gt; SELECT * FROM items WHERE (id = 3)

DB.from(&quot;items&quot;).filter(&#x27;price &lt; ?&#x27;, 100)
     //=&gt; SELECT * FROM items WHERE price &lt; 100

DB.from(&quot;items&quot;).filter({id, [1,2,3]}).filter({id : {between : [0, 10]}}).sql;
     //=&gt; SELECT
              *
          FROM
              items
          WHERE
              ((id IN (1, 2, 3)) AND ((id &gt;= 0) AND (id &lt;= 10)))

DB.from(&quot;items&quot;).filter(&#x27;price &lt; 100&#x27;);
     //=&gt; SELECT * FROM items WHERE price &lt; 100

DB.from(&quot;items&quot;).filter(&quot;active&quot;).sql;
     //=&gt; SELECT * FROM items WHERE active

DB.from(&quot;items&quot;).filter(function(){
     return this.price.lt(100);
});
     //=&gt; SELECT * FROM items WHERE (price &lt; 100)

//Multiple filter calls can be chained for scoping:
DB.from(&quot;items&quot;).filter(:category =&gt; &#x27;software&#x27;).filter{price &lt; 100}
     //=&gt; SELECT * FROM items WHERE ((category = &#x27;software&#x27;) AND (price &lt; 100))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : filters to apply to the  WHERE/HAVING clause. Description of each:  <ul>      <li>Hash - list of equality/inclusion expressions</li>      <li>Array - depends:          <ul>              <li>If first member is a string, assumes the rest of the arguments                  are parameters and interpolates them into the string.</li>              <li>If all members are arrays of length two, treats the same way                  as a hash, except it allows for duplicate keys to be                  specified.</li>              <li>Otherwise, treats each argument as a separate condition.</li>           </ul>       </li>      <li>String - taken literally</li>      <li><a href='./patio_sql_Identifier.html#'> patio.sql.Identifier</a> - taken as a boolean column argument (e.g. WHERE active)</li>      <li><a href='./patio_sql_BooleanExpression.html#'> patio.sql.BooleanExpression</a> - an existing condition expression,          probably created using the patio.sql methods.       </li></li>
    
        <li> <em>cb?</em>  : filter also takes a cb, which should return one of the above argument
types, and is treated the same way.  This block is called with an <a href='./patio.html#.sql'> patio.sql</a> object which can be used to dynaically create expression.  For more details
on the sql object see <a href='./patio.html#.sql'> patio.sql</a>

<p>
    <b>NOTE:</b>If both a cb and regular arguments are provided, they get ANDed together.
</p></li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the filter arumgents applied to the WHERE/HAVING clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args,cb){
   args = [this.__opts[&quot;having&quot;] ? &quot;having&quot; : &quot;where&quot;].concat(comb.argsToArray(arguments));
   return this._filter.apply(this, args);
           
}
    </pre>
    


  
    <a name="find"></a>
    <h3>
        find
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var args = [this.__opts[&quot;having&quot;] ? &quot;having&quot; : &quot;where&quot;].concat(comb.argsToArray(arguments));
   return this._filter.apply(this, args);
           
}
    </pre>
    


  
    <a name="first"></a>
    <h3>
        first
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
If a integer argument is given, it is interpreted as a limit, and then returns all
matching records up to that limit.

If no arguments are passed, it returns the first matching record.

If a function taking no arguments is passed in as the last parameter then it
is assumed to be a filter block. If the a funciton is passed in that takes arguments
then it is assumed to be a callback. You may also pass in both the second to last argument
being a filter function, and the last being a callback.

If any other type of argument(s) is passed, it is given to <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a> and the
first matching record is returned.  Examples:

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
comb.executeInOrder(DB.from(&quot;table&quot;), function(ds){
  // SELECT * FROM table LIMIT 1
  ds.first(); // =&gt; {id : 7}

  // SELECT * FROM table LIMIT 2
  ds.first(2); // =&gt; [{id : 6}, {id : 4}]

  // SELECT * FROM table WHERE (id = 2) LIMIT 1
  ds.first({id : 2}) // =&gt; {id : 2}


 // SELECT * FROM table WHERE (id = 3) LIMIT 1
  ds.first(&quot;id = 3&quot;); // =&gt; {id : 3}

  // SELECT * FROM table WHERE (id = 4) LIMIT 1
  ds.first(&quot;id = ?&quot;, 4); // =&gt; {id : 4}

  // SELECT * FROM table WHERE (id &gt; 2) LIMIT 1
  ds.first(function(){return this.id.gt(2);}); // =&gt; {id : 5}


  // SELECT * FROM table WHERE ((id &gt; 4) AND (id &lt; 6)) LIMIT 1
  ds.first(&quot;id &gt; ?&quot;, 4, function(){
         return this.id.lt(6);
  }); // =&gt; {id : 5}

   // SELECT * FROM table WHERE (id &lt; 2) LIMIT 2
  ds.first(2, function(){
         return this.id.lt(2)
  }); // =&gt; [{id:1}]
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : varargs to be used to limit/filter the result set.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved with the either the first matching record.
                       Or an array of items if a limit was provided as the first argument.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args){
   args = comb.argsToArray(arguments);
   var cb, block = comb.isFunction(args[args.length - 1]) ? args.pop() : null;
   if (block &amp;&amp; block.length &gt; 0) {
       cb = block;
       block = comb.isFunction(args[args.length - 1]) ? args.pop() : null;
   }
   var ds = block ? this.filter(block) : this;
   if (!args.length) {
       return ds.singleRecord(cb);
   } else {
       args = (args.length === 1) ? args.shift() : args;
       if (comb.isNumber(args)) {
           return ds.limit(args).all(null, cb);
       } else {
           return ds.filter(args).singleRecord(cb);
       }
   }
           
}
    </pre>
    


  
    <a name="forEach"></a>
    <h3>
        forEach
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Iterates over the records in the dataset as they are returned from the
database adapter.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT * FROM table
DB.from(&quot;table&quot;).forEach(function(row){
     //....do something
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>block?</em>  : the block to invoke for each row.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved when the action has completed.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (block,cb){
   var rowCb, ret;
   if (this.__opts.graph) {
       ret = this.graphEach(block);
   } else if ((rowCb = this.rowCb)) {
       ret = this.fetchRows(this.selectSql, function (r) {
           var ret = new comb.Promise();
           try {
               comb.when(rowCb(r), function (r) {
                   try {
                       comb.when(block(r), hitch(ret, &quot;callback&quot;, r), hitch(ret, &quot;errback&quot;));
                   } catch (e) {
                       ret.errback(e);
                   }
               }, hitch(ret, &quot;errback&quot;));
           } catch (e) {
               ret.errback(e);
           }
           return ret;
       });
   } else {
       ret = this.fetchRows(this.selectSql, block);
   }
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="forUpdate"></a>
    <h3>
        forUpdate
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;table&quot;).forUpdate()
         //=&gt; SELECT * FROM table FOR UPDATE
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with a "update" lock style.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.lockStyle(&quot;update&quot;);
           
}
    </pre>
    


  
    <a name="from"></a>
    <h3>
        from
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the source changed. If no
source is given, removes all tables.  If multiple sources
are given, it is the same as using a CROSS JOIN (cartesian product) between all tables.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
var dataset = DB.from(&quot;items&quot;);

dataset.from().sql;
     //=&gt; SELECT *

dataset.from(&quot;blah&quot;).sql
     //=&gt; SELECT * FROM blah

dataset.from(&quot;blah&quot;, &quot;foo&quot;)
     //=&gt; SELECT * FROM blah, foo

dataset.from({a:&quot;b&quot;}).sql;
     //=&gt; SELECT * FROM a AS b

dataset.from(dataset.from(&quot;a&quot;).group(&quot;b&quot;).as(&quot;c&quot;)).sql;
         //=&gt; &quot;SELECT * FROM (SELECT * FROM a GROUP BY b) AS c&quot;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>source?</em>  : tables to select from</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the FROM clause overridden.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (source){
   source = comb.argsToArray(arguments);
   var tableAliasNum = 0, sources = [];
   source.forEach(function (s) {
       if (comb.isInstanceOf(s, Dataset)) {
           sources.push(new AliasedExpression(s, this._datasetAlias(++tableAliasNum)));
       } else if (comb.isHash(s)) {
           for (var i in s) {
               sources.push(new AliasedExpression(new Identifier(i), s[i]));
           }
       } else if (comb.isString(s)) {
           sources.push(this.stringToIdentifier(s))
       } else {
           sources.push(s);
       }
   }, this);
   var o = {from:sources.length ? sources : null}
   if (tableAliasNum) {
       o.numDatasetSources = tableAliasNum;
   }
   return this.mergeOptions(o)
           
}
    </pre>
    


  
    <a name="fromSelf"></a>
    <h3>
        fromSelf
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a dataset selecting from the current dataset.
Supplying the alias option controls the alias of the result.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
ds = DB.from(&quot;items&quot;).order(&quot;name&quot;).select(&quot;id&quot;, &quot;name&quot;)
     //=&gt; SELECT id,name FROM items ORDER BY name

ds.fromSelf().sql;
     //=&gt; SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS t1

ds.fromSelf({alias : &quot;foo&quot;}).sql;
     //=&gt; SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS foo
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>opts?</em>  : options</li>
    
        <li> <em>opts.alias?</em> <code>String|patio.sql.Identifier</code> : alias to use</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the FROM clause set as the current dataset.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (opts){
   opts = comb.isUndefined(opts) ? {} : opts;
   var fs = {};
   var nonSqlOptions = this._static.NON_SQL_OPTIONS;
   Object.keys(this.__opts).forEach(function (k) {
       if (nonSqlOptions.indexOf(k) == -1) {
           fs[k] = null;
       }
   });
   return this.mergeOptions(fs).from(opts[&quot;alias&quot;] ? this.as(opts[&quot;alias&quot;]) : this);
           
}
    </pre>
    


  
    <a name="functionSql"></a>
    <h3>
        functionSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>f</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (f){
   var args = f.args
   return string.format(&quot;%s%s&quot;, f.f, args.length == 0 ? &#x27;()&#x27; : this.literal(args));
           
}
    </pre>
    


  
    <a name="get"></a>
    <h3>
        get
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Return the column value for the first matching record in the dataset.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT id FROM table LIMIT 1
 DB.from(&quot;table&quot;).get(&quot;id&quot;).then(function(val){
  // val === 3
 });


// SELECT sum(id) FROM table LIMIT 1
ds.get(sql.sum(&quot;id&quot;)).then(function(val){
     // val === 6;
});

// SELECT sum(id) FROM table LIMIT 1
ds.get(function(){
     return this.sum(&quot;id&quot;);
}).then(function(val){
     // val === 6;
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : the column to filter on can be anything that            <a href='./patio_Dataset.html#select'> patio.Dataset#select</a> accepts.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that will be resolved will the value requested.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   return this.select(column).singleValue(cb);
           
}
    </pre>
    


  
    <a name="graph"></a>
    <h3>
        graph
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/graph.js</em>

<p>
Allows you to join multiple datasets/tables and have the result set
split into component tables.

This differs from the usual usage of join, which returns the result set
as a single hash.

<pre class="code">

//CREATE TABLE artists (id INTEGER, name TEXT);
//CREATE TABLE albums (id INTEGER, name TEXT, artist_id INTEGER);

var DB = patio.defaultDatabase, ds = db.from("artists");
ds.leftAuterJoin("albums", {artistId : "id"}).first
  //=> {id : albums.id, name : albums.name, artist_id : albums.artist_id}

var p = comb.executeInOrder(ds, function(ds){
  var graphedDs = ds.graph("albums", {artist_id : "id"});
  return graphedDs.first();
});
p.then(function(obj){
   //obj == {artists : {
                 id : artists.id,
                 name : artists.name
                 },
            albums : {
                 id : albums.id,
                 name : albums.name,
                 artist_id=>albums.artist_id
                 }
            }
});
</pre>

Using a join such as leftOuterJoin, the attribute names that are shared between
the tables are combined in the single return hash.  You can get around that by
using <a href='./patio_Dataset.html#select'> patio.Dataset#select</a> with correct aliases for all of the columns, but it is simpler to
use <a href='./patio_Dataset.html#graph'> patio.Dataset#graph</a> and have the result set split for you.  In addition, <a href='./patio_Dataset.html#graph'> patio.Dataset#graph</a> respects
any <a href='./patio_Dataset.html#rowCb'> patio.Dataset#rowCb</a> of the current dataset and the datasets you use with <a href='./patio_Dataset.html#graph'> patio.Dataset#graph</a>.

If you are graphing a table and all columns for that table are null, this
indicates that no matching rows existed in the table, so graph will return null.
instead of a hash with all nil values:

<pre class="code">
  // Psuedo code there will be promises returned
  /// If the artist doesn't have any albums

  var DB = patio.defaultDatabase, ds = db.from("artists");
  var obj = ds.graph(:albums, :artist_id=>:id).first()
  //obj == { artists : {id : artists.id, name : artists.name}, albums : null};
</pre>


</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>dataset</em>  : This can be a string (representing a table), another <a href='./patio_Dataset.html#'> patio.Dataset</a>,            or an object that has a dataset property that returns a string or dataset.</li>
    
        <li> <em>joinConditions</em>  : Any condition(s) allowed by <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a>.</li>
    
        <li> <em>options?</em>  : options to use when creating the graph</li>
    
        <li> <em>block</em>  : A function that is passed to <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a>.</li>
    
        <li> <em>options.fromSelfAlias?</em> <code>String|sql.LiteralString|sql.Identifier</code> : The alias to use when the
                     receiver is not a graphed dataset but it contains multiple FROM tables or a JOIN.
                     In this case, the receiver is wrapped in a <a href='./patio_Dataset.html#fromSelf'> patio.Dataset#fromSelf</a> before graphing,
                     and this option determines the alias to use.</li>
    
        <li> <em>options.implicitQualifier?</em> <code>String|sql.LiteralString|sql.Identifier</code> : The qualifier of implicit conditions,
             see <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a>.</li>
    
        <li> <em>String?</em>  : [options.joinType="leftOuter"] The type of join to use (passed to <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a>.).</li>
    
        <li> <em>String[]|sql.LiteralString[]|sql.Identifier[]|Boolean?</em>  : [options.select] An array of columns to select.  When not used, selects
           all columns in the given dataset.  When set to false, selects no
           columns and is like simply joining the tables, though graph keeps
           some metadata about the join that makes it important to use <a href='./patio_Dataset.html#graph'> patio.Dataset#graph</a> instead
           of <a href='./patio_Dataset.html#joinTable'> patio.Dataset#joinTable</a></li>
    
        <li> <em>options.tableAlias?</em> <code>String|sql.LiteralString|sql.Identifier</code> : The alias to use for the table.  If not specified, doesn't
                alias the table.  You will get an error if the the alias (or table) name is
                used more than once.</li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (dataset,joinConditions,options,block){
   var ret = new comb.Promise();
   var args = comb.argsToArray(arguments).slice(1);
   block = comb.isFunction(args[args.length - 1]) ? args.pop() : null;
   joinConditions = args.shift() || null;
   options = args.shift() || {};
   // Allow the use of a model, dataset, or string as the first argument
   // Find the table name/dataset based on the argument
   dataset.hasOwnProperty(&quot;dataset&quot;) &amp;&amp; (dataset = dataset.dataset);
   var tableAlias = options.tableAlias, table;
   if (comb.isString(dataset)) {
     table = sql.identifier(dataset);
     dataset = this.db.from(dataset);
     comb.isUndefinedOrNull(tableAlias) &amp;&amp; (tableAlias = table);
   } else if (comb.isInstanceOf(dataset, Dataset)) {
     if (dataset.isSimpleSelectAll) {
       table = dataset.__opts.from[0];
       comb.isUndefinedOrNull(tableAlias) &amp;&amp; (tableAlias = table);
     } else {
       table = dataset;
       comb.isUndefinedOrNull(tableAlias) &amp;&amp; (tableAlias = this._datasetAlias((this.__opts.numDatasetSources || 0) + 1));
     }
   } else {
     throw new QueryError(&quot;The dataset arg should be a string, dataset or model&quot;);
   }
   var aliases;
   // Only allow table aliases that haven&#x27;t been used
   var thisOpts = this.__opts, thisOptsGraph = thisOpts.graph;
   if (comb.isObject(thisOptsGraph) &amp;&amp; comb.isHash((aliases = thisOptsGraph.tableAliases)) &amp;&amp; !comb.isUndefinedOrNull(aliases[tableAlias.value])) {
     raiseAliasError(options);
   }
   // Use a from_self if this is already a joined table
   var ds = (!thisOptsGraph &amp;&amp; (thisOpts.from.length &gt; 1 || thisOpts.join)) ? this.fromSelf({alias:options.fromSelfAlias || this.firstSourceAlias}) : this;
   // Join the table early in order to avoid cloning the dataset twice
   ds = ds.joinTable(options.joinType || &quot;leftOuter&quot;, table, joinConditions, {tableAlias:tableAlias, implicitQualifier:options.implicitQualifier}, block);
   var opts = ds.__opts;
   // Whether to include the table in the result set
   var addTable = comb.isBoolean(options.select) ? options.select : true;
   // Whether to add the columns to the list of column aliases
   var addColumns = comb.isUndefinedOrNull(opts.graphAliases);
   // Setup the initial graph data structure if it doesn&#x27;t exist
   var graph;
   var populateGraphPromise = new comb.Promise();
   if (comb.isUndefinedOrNull((graph = opts.graph))) {
     var master = this._toTableName(ds.firstSourceAlias);
     (master == tableAlias) &amp;&amp; raiseAliasError(options);
     // Master hash storing all .graph related information
     graph = opts.graph = {};
     // Associates column aliases back to tables and columns
     var columnAliases = graph.columnAliases = {};
     // Associates table alias (the master is never aliased)
     var tableAliases = graph.tableAliases = {};
     tableAliases[master] = this;
     // All columns in the master table are never
     // aliased, but are not included if set_graph_aliases
     // has been used.
     if (addColumns) {
       var select = opts.select = [];
       this.columns.then(hitch(this, function(cols) {
         cols.forEach(function(column) {
           columnAliases[column] = [master, column];
           select.push(new sql.QualifiedIdentifier(master, column));
         });
         populateGraphPromise.callback(graph);
       }), hitch(ret, &quot;errback&quot;));
     } else {
       populateGraphPromise.callback(graph);
     }
   } else {
     populateGraphPromise.callback(graph);
   }
   populateGraphPromise.then(hitch(this, function(graph) {
     // Add the table alias to the list of aliases
     // Even if it isn&#x27;t been used in the result set,
     // we add a key for it with a nil value so we can check if it
     // is used more than once
     var tableAliases = graph.tableAliases;
     tableAliases[tableAlias] = addTable ? dataset : null;
     // Add the columns to the selection unless we are ignoring them
     if (addTable &amp;&amp; addColumns) {
       var select = opts.select;
       var columnAliases = graph.columnAliases;
       // Which columns to add to the result set
       var dsColPromise;
       if (options.select) {
         dsColPromise = new comb.Promise().callback(options.select)
       } else {
         dsColPromise = dataset.columns;
       }
       // If the column hasn&#x27;t been used yet, don&#x27;t alias it.
       // If it has been used, try tableColumn.
       dsColPromise.then(hitch(this, function(cols) {
         cols.forEach(function(column) {
           var colAlias, identifier;
           if (columnAliases[column]) {
             var columnAlias = format(&quot;%s_%s&quot;, [tableAlias, column]);
             colAlias = columnAlias, identifier = new sql.QualifiedIdentifier(tableAlias, column).as(columnAlias);
           } else {
             colAlias = column, identifier = new sql.QualifiedIdentifier(tableAlias, column);
           }
           columnAliases[colAlias] = [tableAlias, column];
           select.push(identifier)
         });
         ret.callback(ds);
       }), hitch(ret, &quot;errback&quot;));
     } else {
       ret.callback(ds);
     }
   }), hitch(ret, &quot;errback&quot;));
   return ret;
       
}
    </pre>
    


  
    <a name="graphEach"></a>
    <h3>
        graphEach
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/graph.js</em>

<p>
Fetch the rows, split them into component table parts,
transform and run the <a href='./patio_Dataset.html#rowCb'> patio.Dataset#rowCb</a> on each part (if applicable),
and yield a hash of the parts.
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cb</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cb){
   // Reject tables with nil datasets, as they are excluded from
   // the result set
   var datasets = comb.array.toArray(this.__opts.graph.tableAliases).filter(function(e) {
     return !comb.isUndefinedOrNull(e[1])
   });
   // Get just the list of table aliases into a local variable, for speed
   var tableAliases = datasets.map(function(e) {
     return e[0]
   });
   datasets = datasets.map(function(e) {
     return [e[0], e[1], e[1].rowCb]
   });
   // Use the manually set graph aliases, if any, otherwise
   // use the ones automatically created by .graph
   var columnAliases = this.__opts.graphAliases || this.__opts.graph.columnAliases;
   var ret = new comb.Promise();
   return this.fetchRows(this.selectSql, function(r) {
     var graph = {};
     // Create the sub hashes, one per table
     tableAliases.forEach(function(ta) {
       graph[ta] = {};
     });
     // Split the result set based on the column aliases
     // If there are columns in the result set that are
     // not in column_aliases, they are ignored
     for (var colAlias in columnAliases) {
       var tc = columnAliases[colAlias];
       var ta = tc[0], column = tc[1];
       !graph[ta] &amp;&amp; (graph[ta] = {});
       graph[ta][column] = r[colAlias];
     }
     datasets.forEach(function(d) {
       var ta = d[0], ds = d[1], dsCb = d[2];
       var g = graph[ta];
       if (!comb.isEmpty(g) &amp;&amp; Object.keys(g).some(function(x) {
         return !comb.isUndefinedOrNull(g[x]);
       })) {
         graph[ta] = dsCb ? dsCb(g) : g;
       } else {
         graph[ta] = null;
       }
     });
     cb(graph);
   });
       
}
    </pre>
    


  
    <a name="grep"></a>
    <h3>
        grep
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Match any of the columns to any of the patterns. The terms can be
strings (which use LIKE) or regular expressions (which are only
supported on MySQL and PostgreSQL).  Note that the total number of
pattern matches will be columns[].length * terms[].length,
which could cause performance issues.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).grep(&quot;a&quot;, &quot;%test%&quot;).sql;
     //=&gt; SELECT * FROM items WHERE (a LIKE &#x27;%test%&#x27;);

DB.from(&quot;items&quot;).grep([&quot;a&quot;, &quot;b&quot;], [&quot;%test%&quot; &quot;foo&quot;]).sql;
     //=&gt; SELECT * FROM items WHERE ((a LIKE &#x27;%test%&#x27;) OR (a LIKE &#x27;foo&#x27;) OR (b LIKE &#x27;%test%&#x27;) OR (b LIKE &#x27;foo&#x27;))

DB.from(&quot;items&quot;).grep([&#x27;a&#x27;, &#x27;b&#x27;], [&quot;%foo%&quot;, &quot;%bar%&quot;], {allPatterns : true}).sql;
     //=&gt; SELECT * FROM a WHERE (((a LIKE &#x27;%foo%&#x27;) OR (b LIKE &#x27;%foo%&#x27;)) AND ((a LIKE &#x27;%bar%&#x27;) OR (b LIKE &#x27;%bar%&#x27;)))

DB.from(&quot;items&quot;).grep([&quot;a&quot;, &quot;b&quot;], [&#x27;%foo%&quot;, &quot;%bar%&quot;, {allColumns : true})sql;
     //=&gt; SELECT * FROM a WHERE (((a LIKE &#x27;%foo%&#x27;) OR (a LIKE &#x27;%bar%&#x27;)) AND ((b LIKE &#x27;%foo%&#x27;) OR (b LIKE &#x27;%bar%&#x27;)))

DB.from(&quot;items&quot;).grep([&quot;a&quot;, &quot;b&quot;], [&quot;%foo%&quot;, &quot;%bar%&quot;], {allPatterns : true, allColumns : true}).sql;
     //=&gt; SELECT * FROM a WHERE ((a LIKE &#x27;%foo%&#x27;) AND (b LIKE &#x27;%foo%&#x27;) AND (a LIKE &#x27;%bar%&#x27;) AND (b LIKE &#x27;%bar%&#x27;))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>columns</em>  : columns to search</li>
    
        <li> <em>patterns</em>  : patters to search with</li>
    
        <li> <em>opts?</em>  : options to use when searching. NOTE If both allColumns and allPatterns are true, all columns must match all patterns</li>
    
        <li> <em>opts.allColumns?</em> <code>Boolean</code> : All columns must be matched to any of the given patterns.</li>
    
        <li> <em>opts.allPatterns?</em> <code>Boolean</code> : All patterns must match at least one of the columns.</li>
    
        <li> <em>opts.caseInsensitive?</em> <code>Boolean</code> : Use a case insensitive pattern match (the default is
                     case sensitive if the database supports it).</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a dataset with the LIKE clauses added</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (columns,patterns,opts){
   opts = comb.isUndefined(opts) ? {} : opts;
   var conds;
   if (opts.hasOwnProperty(&quot;allPatterns&quot;)) {
       conds = array.toArray(patterns).map(function (pat) {
           return BooleanExpression.fromArgs(
               [(opts.allColumns ? &quot;AND&quot; : &quot;OR&quot;)]
                   .concat(array.toArray(columns)
                   .map(function (c) {
                       return StringExpression.like(c, pat, opts);
                   })));
       });
       return this.filter(BooleanExpression.fromArgs([opts.allPatterns ? &quot;AND&quot; : &quot;OR&quot;].concat(conds)));
   } else {
       conds = array.toArray(columns)
           .map(function (c) {
               return BooleanExpression.fromArgs([&quot;OR&quot;].concat(array.toArray(patterns).map(function (pat) {
                   return StringExpression.like(c, pat, opts);
               })));
           });
       return this.filter(BooleanExpression.fromArgs([opts.allColumns ? &quot;AND&quot; : &quot;OR&quot;].concat(conds)));
   }
           
}
    </pre>
    


  
    <a name="group"></a>
    <h3>
        group
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the results grouped by the value of
the given columns.
</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).group(&quot;id&quot;)
         //=&gt;SELECT * FROM items GROUP BY id
  DB.from(&quot;items&quot;).group(&quot;id&quot;, &quot;name&quot;)
         //=&gt; SELECT * FROM items GROUP BY id, name
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>columns</em>  : columns to group by.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the GROUP BY clause added.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (columns){
   columns = comb.argsToArray(arguments);
   return this.mergeOptions({group:(array.compact(columns).length == 0 ? null : columns.map(function (c) {
       return comb.isString(c) ? new Identifier(c) : c;
   }))});
           
}
    </pre>
    


  
    <a name="groupAndCount"></a>
    <h3>
        groupAndCount
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a dataset grouped by the given column with count by group.
Column aliases may be supplied, and will be included in the select clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).groupAndCount(&quot;name&quot;).all()
     //=&gt; SELECT name, count(*) AS count FROM items GROUP BY name
     //=&gt; [{name : &#x27;a&#x27;, count : 1}, ...]

DB.from(&quot;items&quot;).groupAndCount(&quot;first_name&quot;, &quot;last_name&quot;).all()
     //SELECT first_name, last_name, count(*) AS count FROM items GROUP BY first_name, last_name
     //=&gt; [{first_name : &#x27;a&#x27;, last_name : &#x27;b&#x27;, count : 1}, ...]

DB.from(&quot;items&quot;).groupAndCount(&quot;first_name___name&quot;).all()
     //=&gt; SELECT first_name AS name, count(*) AS count FROM items GROUP BY first_name
     //=&gt; [{name : &#x27;a&#x27;, count:1}, ...]
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>columns</em>  : columns to croup and count on.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the GROUP clause and count added.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (columns){
   columns = comb.argsToArray(arguments);
   var group = this.group.apply(this, columns.map(function (c) {
       return this._unaliasedIdentifier(c);
   }, this));
   return group.select.apply(group, columns.concat([this._static.COUNT_OF_ALL_AS_COUNT]));
           
}
    </pre>
    


  
    <a name="groupBy"></a>
    <h3>
        groupBy
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.group.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="gt"></a>
    <h3>
        gt
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>

Returns a cloned dataset with a greater than expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).gt({x : 1});
         //=&gt; SELECT * FROM test WHERE (x &gt; 1)
 DB.from(&quot;test&quot;).gt({x : 1, y : 10});
         //=&gt; SELECT * FROM test WHERE ((x &gt; 1) AND (y &gt; 10))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object used to create the greater than expression.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the greater than expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBoolExpression(&quot;gt&quot;, obj));
           
}
    </pre>
    


  
    <a name="gte"></a>
    <h3>
        gte
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>

Returns a cloned dataset with a greater than or equal to expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).gte({x : 1});
         //=&gt; SELECT * FROM test WHERE (x &gt;= 1)
 DB.from(&quot;test&quot;).gte({x : 1, y : 10});
         //=&gt; SELECT * FROM test WHERE ((x &gt;= 1) AND (y &gt;= 10))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : </li>
    
        <li> <em>obj</em> <code>Object</code> : object used to create the greater than or equal to expression.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the greater than or equal to expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr){
   arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), &quot;gte&quot;);
   return this.filter(this.__createBoolExpression(&quot;gte&quot;, arr));
           
}
    </pre>
    


  
    <a name="having"></a>
    <h3>
        having
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the HAVING conditions changed. See <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a> for argument types.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).group(&quot;sum&quot;).having({sum : 10}).sql;
     //=&gt; SELECT * FROM items GROUP BY sum HAVING (sum = 10)
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with HAVING clause changed or added.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var cond = comb.argsToArray(arguments).map(function (s) {
       return comb.isString(s) &amp;&amp; s !== &#x27;&#x27; ? this.stringToIdentifier(s) : s
   }, this);
   return this._filter.apply(this, [&quot;having&quot;].concat(cond));
           
}
    </pre>
    


  
    <a name="import"></a>
    <h3>
        import
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Inserts multiple records into the associated table. This method can be
used to efficiently insert a large number of records into a table in a
single query if the database supports it. Inserts
are automatically wrapped in a transaction.

This method is called with a columns array and an array of value arrays:
<pre class="code">
  // INSERT INTO table (x, y) VALUES (1, 2)
  // INSERT INTO table (x, y) VALUES (3, 4)
  DB.from("table").import(["x", "y"], [[1, 2], [3, 4]]).
</pre>

This method also accepts a dataset instead of an array of value arrays:

<pre class="code">
 // INSERT INTO table (x, y) SELECT a, b FROM table2
 DB.from("table").import(["x", "y"], DB.from("table2").select("a", "b"));
</pre>

The method also accepts a commitEvery option that specifies
the number of records to insert per transaction. This is useful especially
when inserting a large number of records, e.g.:

<pre class="code">
  // this will commit every 50 records
 DB.from("table").import(["x", "y"], [[1, 2], [3, 4], ...], {commitEvery : 50});
</pre>

</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>columns</em>  : The columns to insert values for.                  This array will be used as the base for each values item in the values array.</li>
    
        <li> <em>values</em>  : Array of arrays of values to insert into the columns.</li>
    
        <li> <em>opts?</em>  : options</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
        <li> <em>opts.commitEvery?</em> <code>Number</code> : the number of records to insert per transaction.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved once all records have been inserted.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (columns,values,opts,cb){
   if (comb.isFunction(opts)) {
       cb = opts;
       opts = null;
   }
   opts = opts || {};
   var ret;
   if (comb.isInstanceOf(values, Dataset)) {
       ret = this.db.transaction(hitch(this, function () {
           return this.insert(columns, values);
       }));
   } else {
       ret = new comb.Promise();
       if (!values.length) {
           ret.callback();
       }
       if (!columns.length) {
           throw new QueryError(&quot;Invalid columns in import&quot;);
       }
       var sliceSize = opts.commitEvery || opts.slice;
       if (sliceSize) {
           var offset = 0;
           var execute = hitch(this, function () {
               if (offset &gt;= values.length) {
                   ret.callback();
                   return;
               }
               this.db.transaction(opts, hitch(this, function () {
                   this.multiInsertSql(columns, values.slice(offset, sliceSize + offset)).forEach(hitch(this, function (st) {
                       return this.executeDui(st);
                   }));
               })).then(hitch(this, function () {
                   offset += sliceSize;
                   execute();
               }), hitch(ret, &quot;errback&quot;));
           });
           execute();
       } else {
           var statements = this.multiInsertSql(columns, values);
           ret = this.db.transaction(hitch(this, function () {
               statements.forEach(function (st) {
                   this.executeDui(st);
               }, this);
           }));
       }
   }
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="inputIdentifier"></a>
    <h3>
        inputIdentifier
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   var i = this.__identifierInputMethod;
   v = v.toString(this);
   return !comb.isUndefinedOrNull(i) ?
       comb.isFunction(v[i]) ?
           v[i]() :
           comb.isFunction(comb[i]) ?
               comb[i](v)
               : v
       : v;
           
}
    </pre>
    


  
    <a name="insert"></a>
    <h3>
        insert
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Inserts values into the associated table. The returned value is generally
the value of the primary key for the inserted row, but that is adapter dependent.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// INSERT INTO items DEFAULT VALUES
DB.from(&quot;items&quot;).insert()

// INSERT INTO items DEFAULT VALUES
DB.from(&quot;items&quot;).insert({});

// INSERT INTO items VALUES (1, 2, 3)
DB.from(&quot;items&quot;).insert([1,2,3]);

// INSERT INTO items (a, b) VALUES (1, 2)
DB.from(&quot;items&quot;).insert([&quot;a&quot;, &quot;b&quot;], [1,2]);

// INSERT INTO items (a, b) VALUES (1, 2)
DB.from(&quot;items&quot;).insert({a : 1, b : 2});

// INSERT INTO items SELECT * FROM old_items
DB.from(&quot;items&quot;).insert(DB.from(&quot;old_items&quot;));

// INSERT INTO items (a, b) SELECT * FROM old_items
DB.from(&quot;items&quot;).insert([&quot;a&quot;, &quot;b&quot;], DB.from(&quot;old_items&quot;));
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>values</em> <code>patio.Dataset|patio.sql.LiteralString|Array|Object|patio.sql.BooleanExpression|...</code> : values to      insert into the database. The INSERT statement generated depends on the type.      <ul>          <li>Empty object| Or no arugments: then DEFAULT VALUES is used.</li>          <li>Object: the keys will be used as the columns, and values will be the values inserted.</li>          <li>Single <a href='./patio_Dataset.html#'> patio.Dataset</a> : an insert with subselect will be performed.</li>          <li>Array with <a href='./patio_Dataset.html#'> patio.Dataset</a> : The array will be used for columns and a subselect will performed with the dataset for the values.</li>          <li><a href='./patio_sql_LiteralString.html#'> patio.sql.LiteralString</a> : the literal value will be used.</li>          <li>Single Array : the values in the array will be used as the VALUES clause.</li>          <li>Two Arrays: the first array is the columns the second array is the values.</li>          <li><a href='./patio_sql_BooleanExpression.html#'> patio.sql.BooleanExpression</a> : the expression will be used as the values.          <li>An arbitrary number of arguments : the <a href='./patio_Dataset.html#literal'> patio.Dataset#literal</a> version of the values will be used</li>      </ul></li>
    
        <li> <em>cb?</em> <code>Function</code> : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is typically resolved with the ID of the inserted row.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var args = comb.argsToArray(arguments);
   var cb = comb.isFunction(args[args.length - 1]) ? args.pop() : null;
   return this.executeInsert(this.insertSql.apply(this, args)).classic(cb);
           
}
    </pre>
    


  
    <a name="insertMultiple"></a>
    <h3>
        insertMultiple
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Inserts multiple values. If a block is given it is invoked for each
item in the given array before inserting it.  See <a href='./patio_Dataset.html#multiInsert'> patio.Dataset#multiInsert</a> as
a possible faster version that inserts multiple records in one SQL statement.

<b> Params see @link patio.Dataset#insert</b>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;table&quot;).insertMultiple([{x : 1}, {x : 2}]);
     //=&gt; INSERT INTO table (x) VALUES (1)
     //=&gt; INSERT INTO table (x) VALUES (2)

DB.from(&quot;table&quot;).insertMultiple([{x : 1}, {x : 2}], function(row){
     row.y = row.x * 2;
});
     //=&gt; INSERT INTO table (x, y) VALUES (1, 2)
     //=&gt; INSERT INTO table (x, y) VALUES (2, 4)
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>array</em>  : See <a href='./patio_Dataset.html#insert'> patio.Dataset#insert</a> for possible values.</li>
    
        <li> <em>block?</em>  : a function to be called before each item is inserted.</li>
    
        <li> <em>cb?</em>  : a function to be called when the aciton is complete</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.PromiseList</code> a promiseList that should be resolved with the id of each item inserted
         in the order that was in the array.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (array,block,cb){
   var promises;
   if (block) {
       promises = array.map(function (i) {
           return this.insert(block(i));
       }, this);
   } else {
       promises = array.map(function (i) {
           return this.insert(i);
       }, this);
   }
   var ret = new PromiseList(promises, true);
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="insertSql"></a>
    <h3>
        insertSql
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Returns an INSERT SQL query string.  See <a href='./patio_dataset.html#insert'> patio.dataset._Actions#insert</a>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).insertSql({a : 1});
     //=&gt; INSERT INTO items (a) VALUES (1)

var ds = DB.from(&quot;test&quot;);

//default values
ds.insertSql();
     //=&gt; INSERT INTO test DEFAULT VALUES

//with hash
ds.insertSql({name:&#x27;wxyz&#x27;, price:342});
     //=&gt; INSERT INTO test (name, price) VALUES (&#x27;wxyz&#x27;, 342)
ds.insertSql({});
     //=&gt; INSERT INTO test DEFAULT VALUES

//object that has a values property
ds.insertSql({values:{a:1}});
     //=&gt; INSERT INTO test (a) VALUES (1)

//arbitrary value
ds.insertSql(123);
     //=&gt; INSERT INTO test VALUES (123)

//with dataset
ds.insertSql(DB.from(&quot;something&quot;).filter({x:2}));
     //=&gt; INSERT INTO test SELECT * FROM something WHERE (x = 2)

//with array
ds.insertSql(&#x27;a&#x27;, 2, 6.5);
     //=&gt; INSERT INTO test VALUES (&#x27;a&#x27;, 2, 6.5)
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>values</em>  : values to      insert into the database. The INSERT statement generated depends on the type.      <ul>          <li>Empty object| Or no arugments: then DEFAULT VALUES is used.</li>          <li>Object: the keys will be used as the columns, and values will be the values inserted.</li>          <li>Single <a href='./patio_Dataset.html#'> patio.Dataset</a> : an insert with subselect will be performed.</li>          <li>Array with <a href='./patio_Dataset.html#'> patio.Dataset</a> : The array will be used for columns and a subselect will performed with the dataset for the values.</li>          <li><a href='./patio_sql_LiteralString.html#'> patio.sql.LiteralString</a> : the literal value will be used.</li>          <li>Single Array : the values in the array will be used as the VALUES clause.</li>          <li>Two Arrays: the first array is the columns the second array is the values.</li>          <li><a href='./patio_sql_BooleanExpression.html#'> patio.sql.BooleanExpression</a> : the expression will be used as the values.          <li>An arbitrary number of arguments : the <a href='./patio_Dataset.html#literal'> patio.Dataset#literal</a> version of the values will be used</li>      </ul></li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String</code> a INSERT SQL query string</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> if there are Different number of values and columns given to insertSql or
                                 if an invalid BooleanExpresion is given.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (values){
   values = comb.argsToArray(arguments);
   var opts = this.__opts;
   if (opts.sql) {
       return this._staticSql(opts.sql);
   }
   this.__checkModificationAllowed();
   var columns = [];
   switch (values.length) {
       case 0 :
           //we have no values
           return this.insertSql({});
       case 1 :
           var vals = values[0], v;
           if (comb.isInstanceOf(vals, Dataset, LiteralString) || comb.isArray(vals)) {
               values = vals;
           } else if (vals.hasOwnProperty(&quot;values&quot;) &amp;&amp; comb.isObject((v = vals.values))) {
               return this.insertSql(v);
           } else if (comb.isHash(vals)) {
               vals = comb.merge({}, opts.defaults || {}, vals);
               vals = comb.merge({}, vals, opts.overrides || {});
               values = [];
               for (var i in vals) {
                   columns.push(i);
                   values.push(vals[i]);
               }
           } else if (comb.isInstanceOf(vals, BooleanExpression)) {
               var op = vals.op;
               values = [];
               if (!comb.isUndefinedOrNull(this._static.TWO_ARITY_OPERATORS[op])) {
                   var args = vals.args;
                   columns.push(args[0]);
                   values.push(args[1]);
               } else {
                   throw new QueryError(&quot;Invalid Expression op: &quot; + op);
               }
           }
           break;
       case 2 :
           var v0 = values[0], v1 = values[1]
           if (comb.isArray(v0) &amp;&amp; comb.isArray(v1) || comb.isInstanceOf(v1, Dataset, LiteralString)) {
               columns = v0, values = v1;
               if (comb.isArray(values) &amp;&amp; columns.length != values.length) {
                   throw new QueryError(&quot;Different number of values and columns given to insertSql&quot;);
               }
           }
           break;
   }
   columns = columns.map(function (k) {
       return comb.isString(k) ? new Identifier(k) : k;
   }, this);
   return this.mergeOptions({columns:columns, values:values})._insertSql();
           
}
    </pre>
    


  
    <a name="intersect"></a>
    <h3>
        intersect
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Adds an INTERSECT clause using a second dataset object.
An INTERSECT compound dataset returns all rows in both the current dataset
and the given dataset.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).intersect(DB.from(&quot;other_items&quot;)).sql;
  //=&gt; SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS t1

DB.from(&quot;items&quot;).intersect(DB.from(&quot;other_items&quot;), {all : true, fromSelf : false}).sql;
  //=&gt; SELECT * FROM items INTERSECT ALL SELECT * FROM other_items

DB.from(&quot;items&quot;).intersect(DB.from(&quot;other_items&quot;), {alias : &quot;i&quot;}).sql;
  //=&gt; SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS i
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>dataset</em>  : the dataset to intersect</li>
    
        <li> <em>opts?</em>  : options</li>
    
        <li> <em>opts.alias?</em> <code>String|patio.sql.Identifier</code> : Use the given value as the <a href='./patio_Dataset.html#fromSelf'> patio.Dataset#fromSelf</a> alias</li>
    
        <li> <em>opts.all?</em> <code>Boolean</code> : Set to true to use INTERSECT ALL instead of INTERSECT, so duplicate rows can occur</li>
    
        <li> <em>opts.fromSelf?</em> <code>Boolean</code> : Set to false to not wrap the returned dataset in a <a href='./patio_Dataset.html#fromSelf'> patio.Dataset#fromSelf</a>.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the INTERSECT clause.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> if the operation is not supported.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (dataset,opts){
   opts = comb.isUndefined(opts) ? {} : opts;
   if (!comb.isHash(opts)) {
       opts = {all:opts};
   }
   if (!this.supportsIntersectExcept) {
       throw new QueryError(&quot;INTERSECT not supported&quot;);
   } else if (opts.all &amp;&amp; !this.supportsIntersectExceptAll) {
       throw new QueryError(&quot;INTERSECT ALL not supported&quot;);
   }
   return this.compoundClone(&quot;intersect&quot;, dataset, opts);
           
}
    </pre>
    


  
    <a name="interval"></a>
    <h3>
        interval
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise that is resolved with the interval between minimum and maximum values
for the given column.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT (max(id) - min(id)) FROM table LIMIT 1
  DB.from(&quot;table&quot;).interval(&quot;id&quot;).then(function(interval){
     //(e.g) interval === 6
  });
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : to find the interval of.</li>
    
        <li> <em>cb?</em>  : a function to be called when the aciton is complete</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that will be resolved with the interval between the min and max values
of the column.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   return this.__aggregateDataset().get(sql.max(column).minus(sql.min(column)), cb);
           
}
    </pre>
    


  
    <a name="invert"></a>
    <h3>
        invert
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Inverts the current filter.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).filter({category : &#x27;software&#x27;}).invert()
     //=&gt; SELECT * FROM items WHERE (category != &#x27;software&#x27;)
        </pre>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).filter({category : &#x27;software&#x27;, id : 3}).invert()
     //=&gt; SELECT * FROM items WHERE ((category != &#x27;software&#x27;) OR (id != 3))
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the filter inverted.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var having = this.__opts.having, where = this.__opts.where;
   if (!(having || where)) {
       throw new QueryError(&quot;No current filter&quot;);
   }
   var o = {}
   if (having) {
       o.having = BooleanExpression.invert(having);
   }
   if (where) {
       o.where = BooleanExpression.invert(where);
   }
   return this.mergeOptions(o);
           
}
    </pre>
    


  
    <a name="is"></a>
    <h3>
        is
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).is({boolFlag : null});
     =&gt; SELECT * FROM test WHERE (boolFlag IS NULL);
DB.from(&quot;test&quot;).is({boolFlag : false, otherFlag : true, name : null});
     =&gt; SELECT * FROM test WHERE ((boolFlag IS FALSE) AND (otherFlag IS TRUE) AND (name IS NULL));
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object used to create the IS expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBoolExpression(&quot;is&quot;, obj));
           
}
    </pre>
    


  
    <a name="isEmpty"></a>
    <h3>
        isEmpty
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise that is resolved with true if no records exist in the dataset,
false otherwise.
</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT 1 FROM table LIMIT 1
DB.from(&quot;table&quot;).isEmpty().then(function(isEmpty){
  // isEmpty === false
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cb?</em>  : a function to callback when action is done</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved with a boolean indicating if the table is empty.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cb){
   var ret = new Promise();
   this.get(1).then(hitch(this, function (res) {
       ret.callback(comb.isUndefinedOrNull(res) || res.length === 0);
   }), hitch(ret, &quot;errback&quot;));
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="isFalse"></a>
    <h3>
        isFalse
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS FALSE boolean expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).isFalse(&quot;boolFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS FALSE);
DB.from(&quot;test&quot;).isFalse(&quot;boolFlag&quot;, &quot;otherFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS FALSE AND otherFlag IS FALSE);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : variable number of arguments to create an IS FALSE expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS FALSE expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr){
   arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), false);
   return this.filter(this.__createBoolExpression(&quot;is&quot;, arr));
           
}
    </pre>
    


  
    <a name="isNot"></a>
    <h3>
        isNot
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS NOT expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).isNot({boolFlag : null});
     =&gt; SELECT * FROM test WHERE (boolFlag IS NOT NULL);
DB.from(&quot;test&quot;).isNot({boolFlag : false, otherFlag : true, name : null});
     =&gt; SELECT * FROM test WHERE ((boolFlag IS NOT FALSE) AND (otherFlag IS NOT TRUE) AND (name IS NOT NULL));
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object used to create the IS NOT expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS NOT expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBoolExpression(&quot;isNot&quot;, obj));
           
}
    </pre>
    


  
    <a name="isNotFalse"></a>
    <h3>
        isNotFalse
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS NOT FALSE boolean expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).isNotFalse(&quot;boolFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NOT FALSE);
DB.from(&quot;test&quot;).isNotFalse(&quot;boolFlag&quot;, &quot;otherFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NOT FALSE AND otherFlag IS NOT FALSE);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : variable number of arguments to create an IS NOT FALSE expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS NOT FALSE expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr){
   arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), false);
   return this.filter(this.__createBoolExpression(&quot;isNot&quot;, arr));
           
}
    </pre>
    


  
    <a name="isNotNull"></a>
    <h3>
        isNotNull
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS NOT NULL boolean expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).isNotNull(&quot;boolFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NOT NULL);
DB.from(&quot;test&quot;).isNotNull(&quot;boolFlag&quot;, &quot;otherFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NOT NULL AND otherFlag IS NOT NULL);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : variable number of arguments to create an IS NOT NULL expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS NOT NULL expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr){
   arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), null);
   return this.filter(this.__createBoolExpression(&quot;isNot&quot;, arr));
           
}
    </pre>
    


  
    <a name="isNotTrue"></a>
    <h3>
        isNotTrue
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS NOT TRUE boolean expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).isNotTrue(&quot;boolFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NOT TRUE);
DB.from(&quot;test&quot;).isNotTrue(&quot;boolFlag&quot;, &quot;otherFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NOT TRUE AND otherFlag IS NOT TRUE);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : variable number of arguments to create an IS NOT TRUE expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS NOT TRUE expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr){
   arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), true);
   return this.filter(this.__createBoolExpression(&quot;isNot&quot;, arr));
           
}
    </pre>
    


  
    <a name="isNull"></a>
    <h3>
        isNull
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS NULL boolean expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).isNull(&quot;boolFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NULL);
DB.from(&quot;test&quot;).isNull(&quot;boolFlag&quot;, &quot;otherFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS NULL AND otherFlag IS NULL);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : variable number of arguments to create an IS NULL expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS NULL expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr){
   arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), null);
   return this.filter(this.__createBoolExpression(&quot;is&quot;, arr));
           
}
    </pre>
    


  
    <a name="isTrue"></a>
    <h3>
        isTrue
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returnes a cloned dataset with the IS TRUE boolean expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).isTrue(&quot;boolFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS TRUE);
DB.from(&quot;test&quot;).isTrue(&quot;boolFlag&quot;, &quot;otherFlag&quot;);
     =&gt; SELECT * FROM test WHERE (boolFlag IS TRUE AND otherFlag IS TRUE);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>arr</em>  : variable number of arguments to create an IS TRUE expression for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the IS TRUE expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (arr){
   arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), true);
   return this.filter(this.__createBoolExpression(&quot;is&quot;, arr));
           
}
    </pre>
    


  
    <a name="join"></a>
    <h3>
        join
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a cloned dataset with an inner join applied.

</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.innerJoin.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="joinClauseSql"></a>
    <h3>
        joinClauseSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>jc</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (jc){
   var table = jc.table
   var tableAlias = jc.tableAlias
   if (table === tableAlias) {
       tableAlias = null;
   }
   var tref = this.__tableRef(table);
   return string.format(&quot; %s %s&quot;, this._joinTypeSql(jc.joinType),
       tableAlias ? this.__asSql(tref, tableAlias) : tref);
           
}
    </pre>
    


  
    <a name="joinOnClauseSql"></a>
    <h3>
        joinOnClauseSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>jc</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (jc){
   return string.format(&quot;%s ON %s&quot;, this.joinClauseSql(jc), this.literal(this._filterExpr(jc.on)));
           
}
    </pre>
    


  
    <a name="joinTable"></a>
    <h3>
        joinTable
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a joined dataset.  Uses the following arguments:

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).joinTable(&quot;leftOuter&quot;, &quot;categories&quot;, [[&quot;categoryId&quot;, &quot;id&quot;],[&quot;categoryId&quot;, [1, 2, 3]]]).sql;
     //=&gt;&#x27;SELECT
            *
           FROM
             &#x60;items&#x60;
                 LEFT OUTER JOIN
             &#x60;categories&#x60; ON (
                         (&#x60;categories&#x60;.&#x60;categoryId&#x60; = &#x60;items&#x60;.&#x60;id&#x60;)
                             AND
                         (&#x60;categories&#x60;.&#x60;categoryId&#x60; IN (1,2, 3))
                         )
DB.from(&quot;items&quot;).leftOuter(&quot;categories&quot;, [[&quot;categoryId&quot;, &quot;id&quot;],[&quot;categoryId&quot;, [1, 2, 3]]]).sql;
     //=&gt;&#x27;SELECT
            *
           FROM
             &#x60;items&#x60;
                 LEFT OUTER JOIN
             &#x60;categories&#x60; ON (
                         (&#x60;categories&#x60;.&#x60;categoryId&#x60; = &#x60;items&#x60;.&#x60;id&#x60;)
                             AND
                         (&#x60;categories&#x60;.&#x60;categoryId&#x60; IN (1,2, 3))
                         )

DB.from(&quot;items&quot;).leftOuterJoin(&quot;categories&quot;, {categoryId:&quot;id&quot;}).sql
         //=&gt; SELECT * FROM &quot;items&quot; LEFT OUTER JOIN &quot;categories&quot; ON (&quot;categories&quot;.&quot;categoryId&quot; = &quot;items&quot;.&quot;id&quot;)

DB.from(&quot;items&quot;).rightOuterJoin(&quot;categories&quot;, {categoryId:&quot;id&quot;}).sql
         //=&gt; SELECT * FROM &quot;items&quot; RIGHT OUTER JOIN &quot;categories&quot; ON (&quot;categories&quot;.&quot;categoryId&quot; = &quot;items&quot;.&quot;id&quot;)

DB.from(&quot;items&quot;).fullOuterJoin(&quot;categories&quot;, {categoryId:&quot;id&quot;}).sql
         //=&gt; SELECT * FROM &quot;items&quot; FULL OUTER JOIN &quot;categories&quot; ON (&quot;categories&quot;.&quot;categoryId&quot; = &quot;items&quot;.&quot;id&quot;)

DB.from(&quot;items&quot;).innerJoin(&quot;categories&quot;, {categoryId:&quot;id&quot;}).sql
         //=&gt; SELECT * FROM &quot;items&quot; INNER JOIN &quot;categories&quot; ON (&quot;categories&quot;.&quot;categoryId&quot; = &quot;items&quot;.&quot;id&quot;)

DB.from(&quot;items&quot;).leftJoin(&quot;categories&quot;, {categoryId:&quot;id&quot;}).sql
         //=&gt; SELECT * FROM &quot;items&quot; LEFT JOIN &quot;categories&quot; ON (&quot;categories&quot;.&quot;categoryId&quot; = &quot;items&quot;.&quot;id&quot;)

DB.from(&quot;items&quot;).rightJoin(&quot;categories&quot;, {categoryId:&quot;id&quot;}).sql
         //=&gt; SELECT * FROM &quot;items&quot; RIGHT JOIN &quot;categories&quot; ON (&quot;categories&quot;.&quot;categoryId&quot; = &quot;items&quot;.&quot;id&quot;)

DB.from(&quot;items&quot;).fullJoin(&quot;categories&quot;, {categoryId:&quot;id&quot;}).sql
         //=&gt; SELECT * FROM &quot;items&quot; FULL JOIN &quot;categories&quot; ON (&quot;categories&quot;.&quot;categoryId&quot; = &quot;items&quot;.&quot;id&quot;)

DB.from(&quot;items&quot;).naturalJoin(&quot;categories&quot;).sql
         //=&gt; SELECT * FROM &quot;items&quot; NATURAL JOIN &quot;categories&quot;

DB.from(&quot;items&quot;).naturalLeftJoin(&quot;categories&quot;).sql
         //=&gt; SELECT * FROM &quot;items&quot; NATURAL LEFT JOIN &quot;categories&quot;

DB.from(&quot;items&quot;).naturalRightJoin(&quot;categories&quot;).sql
         //=&gt; SELECT * FROM &quot;items&quot; NATURAL RIGHT JOIN &quot;categories&quot;

DB.from(&quot;items&quot;).naturalFullJoin(&quot;categories&quot;).sql
         //=&gt; SELECT * FROM &quot;items&quot; NATURAL FULL JOIN &quot;categories&quot;&#x27;

DB.from(&quot;items&quot;).crossJoin(&quot;categories&quot;).sql
         //=&gt; SELECT * FROM &quot;items&quot; CROSS JOIN &quot;categories&quot;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>type</em>  : the type of join to do.</li>
    
        <li> <em>table</em>  : depends on the type.  <ul>      <li><a href='./patio_Dataset.html#'> patio.Dataset</a> - a subselect is performed with an alias</li>      <li>Object - an object that has a tableName property.</li>      <li>String|<a href='./patio_sql_Identifier.html#'> patio.sql.Identifier</a>  - the name of the table</li>  </ul></li>
    
        <li> <em>expr?</em>  : - depends on type
<ul>
    <li>Object|Array of two element arrays - Assumes key (1st arg) is column of joined table (unless already
    qualified), and value (2nd arg) is column of the last joined or primary table (or the
    implicitQualifier option</li>.
    <li>Array - If all members of the array are string or <a href='./patio_sql_Identifier.html#'> patio.sql.Identifier</a>, considers
    them as columns and uses a JOIN with a USING clause.  Most databases will remove duplicate columns from
    the result set if this is used.</li>
    <li>null|undefined(not passed in) - If a cb is not given, doesn't use ON or USING, so the JOIN should be a NATURAL
    or CROSS join. If a block is given, uses an ON clause based on the block, see below.</li>
    <li>Everything else - pretty much the same as a using the argument in a call to <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>,
    so strings are considered literal, <a href='./patio_sql_Identifiers.html#'> patio.sql.Identifiers</a> specify boolean columns, and patio.sql
     expressions can be used. Uses a JOIN with an ON clause.</li>
</ul></li>
    
        <li> <em>options</em>  : an object of options.</li>
    
        <li> <em>cb?</em>  : cb - The cb argument should only be given if a JOIN with an ON clause is used,
  in which case it is called with
  <ul>
      <li>table alias/name for the table currently being joined</li>
      <li> the table alias/name for the last joined (or first table)
      <li>array of previous</li>
  </ul>
  the cb should return an expression to be used in the ON clause.</li>
    
        <li> <em>[options.tableAlias= <code>undefined</code>]</em> <code>String|patio.sql.Identifier</code> : the name of the table's alias when joining, necessary for joining
    to the same table more than once.  No alias is used by default.</li>
    
        <li> <em>[options.implicitQualifier= <code>undefined</code>]</em> <code>String|patio.sql.Identifier</code> : The name to use for qualifying implicit conditions.  By default,
    the last joined or primary table is used.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset joined using the arguments.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (type,table,expr,options,cb){
   var args = comb.argsToArray(arguments);
   if (comb.isFunction(args[args.length - 1])) {
       cb = args[args.length - 1];
       args.pop();
   } else {
       cb = null;
   }
   type = args.shift(), table = args.shift(), expr = args.shift(), options = args.shift();
   expr = comb.isUndefined(expr) ? null : expr, options = comb.isUndefined(options) ? {} : options;
   var h;
   var usingJoin = comb.isArray(expr) &amp;&amp; expr.length &amp;&amp; expr.every(function (x) {
       return comb.isString(x) || comb.isInstanceOf(x, Identifier)
   });
   if (usingJoin &amp;&amp; !this.supportsJoinUsing) {
       h = {};
       expr.forEach(function (s) {
           h[s] = s;
       });
       return this.joinTable(type, table, h, options);
   }
   var tableAlias, lastAlias;
   if (comb.isHash(options)) {
       tableAlias = options.tableAlias;
       lastAlias = options.implicitQualifier;
   } else if (comb.isString(options) || comb.isInstanceOf(options, Identifier)) {
       tableAlias = options;
       lastAlias = null;
   } else {
       throw new QueryError(&quot;Invalid options format for joinTable %j4&quot;, [options]);
   }
   var tableAliasNum, tableName;
   if (comb.isInstanceOf(table, Dataset)) {
       if (!tableAlias) {
           tableAliasNum = (this.__opts.numDatasetSources || 0) + 1;
           tableAlias = this._datasetAlias(tableAliasNum);
       }
       tableName = tableAlias;
   } else {
       if (!comb.isUndefined(table.tableName)) {
           table = table.tableName;
       }
       if (comb.isArray(table)) {
           table = table.map(this.stringToIdentifier, this);
       } else {
           table = comb.isString(table) ? this.stringToIdentifier(table) : table;
           var parts = this._splitAlias(table), implicitTableAlias = parts[1];
           table = parts[0]
           tableAlias = tableAlias || implicitTableAlias;
           tableName = tableAlias || table;
       }
   }
   var join;
   if (!expr &amp;&amp; !cb) {
       join = new JoinClause(type, table, tableAlias);
   } else if (usingJoin) {
       if (cb) {
           throw new QueryError(&quot;cant use a cb if an array is given&quot;);
       }
       join = new JoinUsingClause(expr, type, table, tableAlias);
   } else {
       lastAlias = lastAlias || this.__opts[&quot;lastJoinedTable&quot;] || this.firstSourceAlias;
       if (Expression.isConditionSpecifier(expr)) {
           var newExpr = [];
           for (var i in expr) {
               var val = expr[i];
               if (comb.isArray(val) &amp;&amp; val.length == 2) {
                   i = val[0], val = val[1];
               }
               var k = this.qualifiedColumnName(i, tableName), v;
               if (comb.isInstanceOf(val, Identifier)) {
                   v = val.qualify(lastAlias);
               } else {
                   v = val;
               }
               newExpr.push([k, v]);
           }
           expr = newExpr;
       }
       if (comb.isFunction(cb)) {
           var expr2 = cb.apply(sql, [tableName, lastAlias, this.__opts.join || []]);
           expr = expr ? new BooleanExpression(&quot;AND&quot;, expr, expr2) : expr2;
       }
       join = new JoinOnClause(expr, type, table, tableAlias);
   }
   var opts = {join:(this.__opts.join || []).concat([join]), lastJoinedTable:tableName};
   if (tableAliasNum) {
       opts.numDatasetSources = tableAliasNum;
   }
   return this.mergeOptions(opts);
           
}
    </pre>
    


  
    <a name="joinUsingClauseSql"></a>
    <h3>
        joinUsingClauseSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>jc</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (jc){
   return string.format(&quot;%s USING (%s)&quot;, this.joinClauseSql(jc), this.__columnList(jc.using));
           
}
    </pre>
    


  
    <a name="last"></a>
    <h3>
        last
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Reverses the order and then runs first.  Note that this
will not necessarily give you the last record in the dataset,
unless you have an unambiguous order.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT * FROM table ORDER BY id DESC LIMIT 1
 DB.from(&quot;table&quot;).order(&quot;id&quot;).last().then(function(lastItem){
     //...(e.g lastItem === {id : 10})
 });

 // SELECT * FROM table ORDER BY id ASC LIMIT 2
  DB.from(&quot;table&quot;).order(sql.id.desc()).last(2).then(function(lastItems){
     //...(e.g lastItems === [{id : 1}, {id : 2});
 });
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : See <a href='./patio_Dataset.html#first'> patio.Dataset#first</a> for argument types.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that will be resolved with a single object or array depending on the
arguments provided.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.error.QueryError</code> If there is not currently an order for this dataset.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args){
   if (!this.__opts.order) {
       throw new QueryError(&quot;No order specified&quot;);
   }
   var ds = this.reverse();
   return ds.first.apply(ds, arguments);
           
}
    </pre>
    


  
    <a name="like"></a>
    <h3>
        like
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.grep.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="limit"></a>
    <h3>
        limit
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
If given an integer, the dataset will contain only the first l results.
         If a second argument is given, it is used as an offset. To use
an offset without a limit, pass null as the first argument.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).limit(10)
     //=&gt; SELECT * FROM items LIMIT 10
DB.from(&quot;items&quot;).limit(10, 20)
     //=&gt; SELECT * FROM items LIMIT 10 OFFSET 20
DB.from(&quot;items&quot;).limit([3, 7]).sql
     //=&gt; SELECT * FROM items LIMIT 5 OFFSET 3&#x27;);
DB.from(&quot;items&quot;).limit(null, 20)
     //=&gt; SELECT * FROM items OFFSET 20

DB.from(&quot;items&quot;).limit(&#x27;6&#x27;, sql[&#x27;a() - 1&#x27;]).sql
     =&gt; &#x27;SELECT * FROM items LIMIT 6 OFFSET a() - 1&#x27;);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>limit</em>  : the limit to apply</li>
    
        <li> <em>offset</em>  : the offset to apply</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset witht the LIMIT and OFFSET applied.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (limit,offset){
   if (this.__opts.sql) {
       return this.fromSelf().limit(limit, offset);
   }
   if (comb.isArray(limit) &amp;&amp; limit.length == 2) {
       offset = limit[0];
       limit = limit[1] - limit[0] + 1;
   }
   if (comb.isString(limit) || comb.isInstanceOf(limit, LiteralString)) {
       limit = parseInt(&quot;&quot; + limit, 10);
   }
   if (comb.isNumber(limit) &amp;&amp; limit &lt; 1) {
       throw new QueryError(&quot;Limit must be &gt;= 1&quot;);
   }
   var opts = {limit:limit};
   if (offset) {
       if (comb.isString(offset) || comb.isInstanceOf(offset, LiteralString)) {
           offset = parseInt(&quot;&quot; + offset, 10);
           isNaN(offset) &amp;&amp; (offset = 0);
       }
       if (comb.isNumber(offset) &amp;&amp; offset &lt; 0) {
           throw new QueryError(&quot;Offset must be &gt;= 0&quot;);
       }
       opts.offset = offset;
   }
   return this.mergeOptions(opts);
           
}
    </pre>
    


  
    <a name="literal"></a>
    <h3>
        literal
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Returns a literal representation of a value to be used as part
of an SQL expression.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).literal(&quot;abc&#x27;def\\&quot;) //=&gt; &quot;&#x27;abc&#x27;&#x27;def\\\\&#x27;&quot;
 DB.from(&quot;items&quot;).literal(&quot;items__id&quot;) //=&gt; &quot;items.id&quot;
 DB.from(&quot;items&quot;).literal([1, 2, 3]) //=&gt; &quot;(1, 2, 3)&quot;
 DB.from(&quot;items&quot;).literal(DB.from(&quot;items&quot;)) //=&gt; &quot;(SELECT * FROM items)&quot;
 DB.from(&quot;items&quot;).literal(sql.x.plus(1).gt(&quot;y&quot;)); //=&gt; &quot;((x + 1) &gt; y)&quot;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : the value to convert the the SQL literal representation</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String</code> a literal representation of the value.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> If an unsupported object is given.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   if (comb.isInstanceOf(v, LiteralString)) {
       return &quot;&quot; + v;
   } else if (comb.isString(v)) {
       return this._literalString(v);
   } else if (comb.isNumber(v)) {
       return this._literalNumber(v);
   }
   else if (comb.isInstanceOf(v, Expression)) {
       return this._literalExpression(v);
   }
   else if (comb.isInstanceOf(v, Dataset)) {
       return this._literalDataset(v);
   }
   else if (comb.isArray(v)) {
       return this._literalArray(v);
   } else if (comb.isInstanceOf(v, sql.Year)) {
       return this._literalYear(v);
   } else if (comb.isInstanceOf(v, sql.TimeStamp, sql.DateTime)) {
       return this._literalTimestamp(v);
   } else if (comb.isDate(v)) {
       return this._literalDate(v);
   } else if (comb.isInstanceOf(v, sql.Time)) {
       return this._literalTime(v);
   } else if (Buffer.isBuffer(v)) {
       return this._literalBuffer(v);
   } else if (comb.isNull(v)) {
       return this._literalNull();
   }
   else if (comb.isBoolean(v)) {
       return this._literalBoolean(v);
   }
   else if (comb.isHash(v)) {
       return this._literalObject(v);
   } else {
       return this._literalOther(v);
   }
           
}
    </pre>
    


  
    <a name="lockStyle"></a>
    <h3>
        lockStyle
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a cloned dataset with the given lock style.  If style is a
string, it will be used directly.Currently "update" is respected
by most databases, and "share" is supported by some.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).lockStyle(&#x27;FOR SHARE&#x27;) # SELECT * FROM items FOR SHARE
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>style</em>  : the lock style to use.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned datase with the given lock style.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (style){
   return this.mergeOptions({lock:style});
           
}
    </pre>
    


  
    <a name="lt"></a>
    <h3>
        lt
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>

Returns a cloned dataset with a less than expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).lt({x : 1});
         //=&gt; SELECT * FROM test WHERE (x &lt; 1)
 DB.from(&quot;test&quot;).lt({x : 1, y : 10});
         //=&gt; SELECT * FROM test WHERE ((x &lt; 1) AND (y &lt; 10))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object used to create the less than expression.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the less than expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBoolExpression(&quot;lt&quot;, obj));
           
}
    </pre>
    


  
    <a name="lte"></a>
    <h3>
        lte
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>

Returns a cloned dataset with a less than or equal to expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).gte({x : 1});
         //=&gt; SELECT * FROM test WHERE (x &lt;= 1)
 DB.from(&quot;test&quot;).gte({x : 1, y : 10});
         //=&gt; SELECT * FROM test WHERE ((x &lt;= 1) AND (y &lt;= 10))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object used to create the less than or equal to expression.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the less than or equal to expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   var arr = this.__arrayToConditionSpecifier(comb.argsToArray(arguments), &quot;lte&quot;);
   return this.filter(this.__createBoolExpression(&quot;lte&quot;, obj));
           
}
    </pre>
    


  
    <a name="map"></a>
    <h3>
        map
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Maps column values for each record in the dataset (if a column name is
given).

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT * FROM table
DB.from(&quot;table&quot;).map(&quot;id&quot;).then(function(ids){
  // e.g. ids === [1, 2, 3, ...]
});

 // SELECT * FROM table
DB.from(&quot;table&quot;).map(function(r){
     return r.id * 2;
}).then(function(ids){
    // e.g. ids === [2, 4, 6, ...]
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : if a string is provided then then it is assumed to be the name of a column in that table and the value of the column for each row will be returned. If column is a function then the return value of the function will be used.</li>
    
        <li> <em>cb?</em>  : a function to be called when the aciton is complete</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise resolved with the array of mapped values.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   var ret = new Promise(), block;
   if (comb.isFunction(column)) {
       block = column;
       column = null;
   }
   var a = [], forEachP;
   forEachP = this.forEach(function (r) {
       var item = column ? r[column] : (block ? block(r) : r);
       return comb.when(item, function (mapped) {
           a.push(mapped);
       });
   });
   forEachP.then(hitch(this, function () {
       ret.callback(a);
   }), hitch(ret, &quot;errback&quot;));
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="max"></a>
    <h3>
        max
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with  the maximum value for the given column.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT max(id) FROM table LIMIT 1
DB.from(&quot;table&quot;).max(&quot;id&quot;).then(function(max){
  // e.g. max === 10.
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : the column to find the maximum value for.</li>
    
        <li> <em>cb?</em>  : callback to invoke when action is done</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>*</code> the maximum value for the column.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   return this.__aggregateDataset().get(sql.max(this.stringToIdentifier(column)), cb);
           
}
    </pre>
    


  
    <a name="mergeOptions"></a>
    <h3>
        mergeOptions
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/index.js</em>

<p>
Returns a new clone of the dataset with with the given options merged into the current datasets options.
If the options changed include options in <a href='./patio_dataset_Query.html#COLUMN_CHANGE_OPTS'> patio.dataset.Query#COLUMN_CHANGE_OPTS</a>, the cached
columns are deleted.  This method should generally not be called
directly by user code.

</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>opts</em>  : options to merge into the curred datasets options and applied to the returned dataset.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li>  [patio.Dataset] a cloned dataset with the merged options</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (opts){
   opts = comb.isUndefined(opts) ? {} : opts;
   var ds = new this._static(this.db, {});
   ds.rowCb = this.rowCb;
   this._static.FEATURES.forEach(function (f) {
       ds[f] = this[f]
   }, this);
   ds.__opts = comb.merge({}, this.__opts, opts);
   ds.identifierInputMethod = this.identifierInputMethod;
   ds.identifierOutputMethod = this.identifierOutputMethod;
   var columnChangeOpts = this._static.COLUMN_CHANGE_OPTS;
   if (Object.keys(opts).some(function (o) {
       return columnChangeOpts.indexOf(o) != -1;
   })) {
       ds.__opts.columns = null;
   }
   return ds;
           
}
    </pre>
    


  
    <a name="min"></a>
    <h3>
        min
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with  the minimum value for the given column.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT min(id) FROM table LIMIT 1
DB.from(&quot;table&quot;).min(&quot;id&quot;).then(function(min){
  // e.g. max === 0.
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : the column to find the minimum value for.</li>
    
        <li> <em>cb?</em>  : callback to invoke when action is done</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>*</code> the minimum value for the column.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   return this.__aggregateDataset().get(sql.min(this.stringToIdentifier(column)), cb);
           
}
    </pre>
    


  
    <a name="multiInsert"></a>
    <h3>
        multiInsert
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
This is the recommended function to do the insert of multiple items into the
database. This acts as a proxy to the <a href='./patio_Dataset.html#import'> patio.Dataset#import</a> method so
one can use an array of hashes rather than an array of columns and an array of values.
See <a href='./patio_Dataset.html#import'> patio.Dataset#import</a> for more information regarding the method of inserting.
<p>
    <b>NOTE:</b>All hashes should have the same keys other wise some values could be missed</b>
</p>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// INSERT INTO table (x) VALUES (1)
// INSERT INTO table (x) VALUES (2)
DB.from(&quot;table&quot;).multiInsert([{x : 1}, {x : 2}]).then(function(){
    //...do something
})

//commit every 50 inserts
DB.from(&quot;table&quot;).multiInsert([{x : 1}, {x : 2},....], {commitEvery : 50}).then(function(){
    //...do something
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>hashes</em>  : an array of objects to insert into the database. The keys of the first item in the array will be used to look up columns in all subsequent objects. If the array is empty then the promise is resolved immediatly.</li>
    
        <li> <em>opts</em>  : See <a href='./patio_Dataset.html#import'> patio.Dataset#import</a>.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> See <a href='./patio_Dataset.html#import'> patio.Dataset#import</a> for return functionality.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (hashes,opts,cb){
   if (comb.isFunction(opts)) {
       cb = opts;
       opts = null;
   }
   opts = opts || {};
   hashes = hashes || [];
   var ret = new Promise().classic(cb);
   if (!hashes.length) {
       ret.callback();
   } else {
       var columns = Object.keys(hashes[0]);
       return this[&quot;import&quot;](columns, hashes.map(function (h) {
           return columns.map(function (c) {
               return h[c];
           });
       }), opts, cb);
   }
   return ret;
           
}
    </pre>
    


  
    <a name="multiInsertSql"></a>
    <h3>
        multiInsertSql
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Returns an array of insert statements for inserting multiple records.
This method is used by <a href='./patio_dataset.html#multiInsert'> patio.dataset._Actions#multiInsert</a> to format insert statements.
<b>This method is not typically used directly.</b>

<p>
     <b>Note:</b>This method should be overridden by descendants if there is support for
                     inserting multiple records in a single SQL statement.
</p>

</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>columns</em>  : The columns to insert values for.                  This array will be used as the base for each values item in the values array.</li>
    
        <li> <em>values</em>  : Array of arrays of values to insert into the columns.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String[]</code> array of insert statements.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (columns,values){
   return values.map(function (r) {
       return this.insertSql(columns, r)
   }, this);
           
}
    </pre>
    


  
    <a name="naked"></a>
    <h3>
        naked
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns the a cloned dataset with out the <a href='./patio_Dataset.html#rowCb'> patio.Dataset#rowCb</a>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
var ds = DB.from(&quot;test&quot;);
ds.rowCb = function(r){
    r.a = r.a * 2;
}

ds.all().then(function(ret){
     //ret === [{a : 4}, {a : 6}]
});
ds.naked().all().then(function(ret){
     //ret ===  [{a : 2}, {a : 3}];
});
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with out the <a href='./patio_Dataset.html#rowCb'> patio.Dataset#rowCb</a></li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var ds = this.mergeOptions({});
   ds.rowCb = null;
   return ds;
           
}
    </pre>
    


  
    <a name="negativeBooleanConstantSql"></a>
    <h3>
        negativeBooleanConstantSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>constant</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (constant){
   return string.format(&quot;NOT %s&quot;, this.booleanConstantSql(constant));
           
}
    </pre>
    


  
    <a name="neq"></a>
    <h3>
        neq
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>

Returns a cloned dataset with a not equal expression added to the WHERE
clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).neq({x : 1});
         //=&gt; SELECT * FROM test WHERE (x != 1)
 DB.from(&quot;test&quot;).neq({x : 1, y : 10});
         //=&gt; SELECT * FROM test WHERE ((x != 1) AND (y != 10))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object used to create the not equal expression</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the not equal expression added to the WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBoolExpression(&quot;neq&quot;, obj));
           
}
    </pre>
    


  
    <a name="notBetween"></a>
    <h3>
        notBetween
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a cloned dataset with a not between clause added
to the where clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
ds.notBetween({x:[1, 2]}).sql;
         //=&gt; SELECT * FROM test WHERE ((x &lt; 1) OR (x &gt; 2))

 ds.find({x:{notBetween:[1, 2]}}).sql;
         //=&gt; SELECT * FROM test WHERE ((x &lt; 1) OR (x &gt; 2))
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>obj</em>  : object where the key is the column and the value is an array where the first element                     is the item to be less than and the second item is greater than.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with a not between clause added
to the where clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (obj){
   return this.filter(this.__createBetweenExpression(obj, true));
           
}
    </pre>
    


  
    <a name="one"></a>
    <h3>
        one
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Same as <a href='./patio_Dataset.html#singleRecord'> patio.Dataset#singleRecord</a> but accepts arguments
to filter the dataset. See <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a> for argument types.

<b>NOTE</b> If the last argument is a function that accepts arguments it is not assumed to
be a filter function but instead a callback.

</p>



    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise resolved with a single row from the database that matched the filter.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var args = comb.argsToArray(arguments), cb;
   var last = args[args.length - 1];
   if (comb.isFunction(last) &amp;&amp; last.length &gt; 0) {
       cb = args.pop();
   }
   if (args.length) {
       return this.filter.apply(this, args).singleRecord(cb);
   } else {
       return this.singleRecord(cb);
   }
           
}
    </pre>
    


  
    <a name="or"></a>
    <h3>
        or
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Adds an alternate filter to an existing WHERE/HAVING using OR.

<p>
    <b>For parameter types see <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>.</b>
</p>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).filter(&quot;a&quot;).or(&quot;b&quot;)
     //=&gt; SELECT * FROM items WHERE a OR b
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the condtion added to the WHERE/HAVING clause added.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>patio.QueryError</code> If no WHERE?HAVING clause exists.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var tOpts = this.__opts;
   var clause = (tOpts.having ? &quot;having&quot; : &quot;where&quot;), clauseObj = tOpts[clause];
   if (clauseObj) {
       var args = comb.argsToArray(arguments);
       args = args.length == 1 ? args[0] : args;
       var opts = {};
       opts[clause] = new BooleanExpression(&quot;OR&quot;, clauseObj, this._filterExpr(args))
       return this.mergeOptions(opts);
   } else {
       throw new QueryError(&quot;No existing filter found&quot;);
   }
           
}
    </pre>
    


  
    <a name="order"></a>
    <h3>
        order
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the order changed. If the dataset has an
existing order, it is ignored and overwritten with this order. If null is given
the returned dataset has no order. This can accept multiple arguments
of varying kinds, such as SQL functions.  This also takes a function similar
to <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).order(&quot;name&quot;)
         //=&gt; SELECT * FROM items ORDER BY name

 DB.from(&quot;items&quot;).order(&quot;a&quot;, &quot;b&quot;)
         //=&gt; SELECT * FROM items ORDER BY a, b

 DB.from(&quot;items&quot;).order(sql.literal(&#x27;a + b&#x27;))
         //=&gt; SELECT * FROM items ORDER BY a + b

 DB.from(&quot;items&quot;).order(sql.identifier(&quot;a&quot;).plus(&quot;b&quot;))
         //=&gt; SELECT * FROM items ORDER BY (a + b)

 DB.from(&quot;items&quot;).order(sql.identifier(&quot;name&quot;).desc())
         //=&gt; SELECT * FROM items ORDER BY name DESC

 DB.from(&quot;items&quot;).order(sql.identifier(&quot;name&quot;).asc({nulls : &quot;last&quot;))
         //=&gt; SELECT * FROM items ORDER BY name ASC NULLS LAST

 DB.from(&quot;items&quot;).order(function(){
         return this.sum(&quot;name&quot;).desc();
 }); //=&gt; SELECT * FROM items ORDER BY sum(name) DESC

 DB.from(&quot;items&quot;).order(null)
         //=&gt;SELECT * FROM items
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : </li>
    
        <li> <em>arg</em>  : variable number of arguments similar to <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a></li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the order changed.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args){
   args = comb.argsToArray(arguments);
   var order = [];
   args = array.compact(args).length ? args : null;
   if (args) {
       args.forEach(function (a) {
           if (comb.isString(a)) {
               order.push(this.stringToIdentifier(a));
           } else if (comb.isFunction(a)) {
               var res = a.apply(sql, [sql]);
               order = order.concat(comb.isArray(res) ? res : [res]);
           } else {
               order.push(a);
           }
       }, this);
   } else {
       order = null;
   }
   return this.mergeOptions({order:order});
           
}
    </pre>
    


  
    <a name="orderAppend"></a>
    <h3>
        orderAppend
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Alias of <a href='./patio_Dataset.html#orderMore'> patio.Dataset#orderMore</a>;
         </p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.orderMore.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="orderBy"></a>
    <h3>
        orderBy
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.order.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="orderMore"></a>
    <h3>
        orderMore
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the order columns added
to the end of the existing order. For more detail
</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).order(&quot;a&quot;).order(&quot;b&quot;);
     //=&gt; SELECT * FROM items ORDER BY b

DB.from(&quot;items&quot;).order(&quot;a&quot;).orderMore(&quot;b&quot;);
     //=&gt;SELECT * FROM items ORDER BY a, b
        </pre>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var args = comb.argsToArray(arguments);
   if (this.__opts.order) {
       args = this.__opts.order.concat(args);
   }
   return this.order.apply(this, args);
           
}
    </pre>
    


  
    <a name="orderPrepend"></a>
    <h3>
        orderPrepend
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the order columns added
to the beginning of the existing order. For more detail
</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).order(&quot;a&quot;).order(&quot;b&quot;);
     //=&gt; SELECT * FROM items ORDER BY b

DB.from(&quot;items&quot;).order(&quot;a&quot;).orderPrepend(&quot;b&quot;);
     //=&gt;SELECT * FROM items ORDER BY b, a
        </pre>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   var ds = this.order.apply(this, arguments);
   return this.__opts.order ? ds.orderMore.apply(ds, this.__opts.order) : ds;
           
}
    </pre>
    


  
    <a name="orderedExpressionSql"></a>
    <h3>
        orderedExpressionSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>oe</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (oe){
   var s = string.format(&quot;%s %s&quot;, this.literal(oe.expression), oe.descending ? &quot;DESC&quot; : &quot;ASC&quot;);
   if (oe.nulls) {
       s = string.format(&quot;%s NULLS %s&quot;, s, oe.nulls == &quot;first&quot; ? &quot;FIRST&quot; : &quot;LAST&quot;);
   }
   return s;
           
}
    </pre>
    


  
    <a name="outputIdentifier"></a>
    <h3>
        outputIdentifier
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>v</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (v){
   (v == &#x27;&#x27; &amp;&amp; (v = &#x27;untitled&#x27;));
   var i = this.__identifierOutputMethod;
   return !comb.isUndefinedOrNull(i) ?
       comb.isFunction(v[i]) ?
           v[i]() :
           comb.isFunction(comb[i]) ?
               comb[i](v)
               : v
       : v;
           
}
    </pre>
    


  
    <a name="placeholderLiteralStringSql"></a>
    <h3>
        placeholderLiteralStringSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>pls</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (pls){
   var args = pls.args;
   var s;
   if (comb.isHash(args)) {
       for (var i in args) {
           args[i] = this.literal(args[i]);
       }
       s = string.format(pls.str, args);
   } else {
       s = pls.str.replace(this._static.QUESTION_MARK, &quot;%s&quot;);
       args = args.map(this.literal, this);
       s = string.format(s, args);
   }
   if (pls.parens) {
       s = string.format(&quot;(%s)&quot;, s);
   }
   return s;
           
}
    </pre>
    


  
    <a name="postLoad"></a>
    <h3>
        postLoad
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
This is run inside <a href='./patio_Dataset.html#all'> patio.Dataset#all</a>, after all of the records have been loaded
via <a href='./patio_Dataset.html#forEach'> patio.Dataset#forEach</a>, but before any block passed to all is called.  It is called with
a single argument, an array of all returned records.  Does nothing by
default.
         </p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>allRecords</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (allRecords){
   return allRecords;
           
}
    </pre>
    


  
    <a name="qualifiedColumnName"></a>
    <h3>
        qualifiedColumnName
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Returns a qualified column name (including a table name) if the column
name isn't already qualified.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
dataset.qualifiedColumnName(&quot;b1&quot;, &quot;items&quot;);
     //=&gt; items.b1

dataset.qualifiedColumnName(&quot;ccc__b&quot;));
     //=&gt; &#x27;ccc.b&#x27;

dataset.qualifiedColumnName(&quot;ccc__b&quot;, &quot;items&quot;));
     //=&gt; &#x27;ccc.b&#x27;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : the column to qualify. If the column is already qualified (e.g. ccc__b) then the                        table name (e.g. ccc) will override the provided table.</li>
    
        <li> <em>table</em>  : the name of the table to qualify the column to.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String</code> the qualified column name..</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,table){
   if (comb.isString(column)) {
       var parts = this._splitString(column);
       var columnTable = parts[0], alias = parts[2], tableAlias;
       column = parts[1];
       if (!columnTable) {
           if (comb.isInstanceOf(table, Identifier)) {
               table = table.value;
           }
           if (comb.isInstanceOf(table, AliasedExpression)) {
               tableAlias = table.alias;
           } else if (comb.isInstanceOf(table, QualifiedIdentifier)) {
               tableAlias = table;
           } else {
               parts = this._splitString(table);
               var schema = parts[0], tableAlias = parts[2];
               table = parts[1];
               if (schema) {
                   tableAlias = new Identifier(tableAlias) || new QualifiedIdentifier(schema, table);
               }
           }
           columnTable = tableAlias || table;
       }
       return new QualifiedIdentifier(columnTable, column);
   } else if (comb.isInstanceOf(column, Identifier)) {
       return column.qualify(table);
   } else {
       return column;
   }
           
}
    </pre>
    


  
    <a name="qualifiedIdentifierSql"></a>
    <h3>
        qualifiedIdentifierSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>qcr</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (qcr){
   return [qcr.table, qcr.column].map(
       function (x) {
           return [QualifiedIdentifier, Identifier, String].some(function (c) {
               return x instanceof c
           }) ? this.literal(x) : this.quoteIdentifier(x)
       }, this).join(&#x27;.&#x27;);
           
}
    </pre>
    


  
    <a name="qualify"></a>
    <h3>
        qualify
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Qualify to the given table, or <a href='./patio_Dataset.html#firstSourceAlias'> patio.Dataset#firstSourceAlias</a> if not table is given.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).filter({id : 1}).qualify();
   //=&gt; SELECT items.* FROM items WHERE (items.id = 1)

DB.from(&quot;items&quot;).filter({id : 1}).qualify(&quot;i&quot;);
  //=&gt; SELECT i.* FROM items WHERE (i.id = 1)
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>[table= <code>{@link patio.Dataset#firstSourceAlias}</code>]</em>  : the table name to qualify to.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset qualified to the table or @link patio.Dataset#firstSourceAlias}</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (table){
   table = table || this.firstSourceAlias;
   return this.qualifyTo(table);
           
}
    </pre>
    


  
    <a name="qualifyTo"></a>
    <h3>
        qualifyTo
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Return a copy of the dataset with unqualified identifiers in the
SELECT, WHERE, GROUP, HAVING, and ORDER clauses qualified by the
given table. If no columns are currently selected, select all
columns of the given table.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).filter({id : 1}).qualifyTo(&quot;i&quot;);
     //=&gt; SELECT i.* FROM items WHERE (i.id = 1)
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>table</em>  : the name to qualify identifier to.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with unqualified identifiers qualified.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (table){
   var o = this.__opts;
   if (o.sql) {
       return this.mergeOptions();
   }
   var h = {};
   array.intersect(Object.keys(o), this._static.QUALIFY_KEYS).forEach(function (k) {
       h[k] = this._qualifiedExpression(o[k], table);
   }, this);
   if (!o.select || comb.isEmpty(o.select)) {
       h.select = [new ColumnAll(table)];
   }
   return this.mergeOptions(h);
           
}
    </pre>
    


  
    <a name="qualifyToFirstSource"></a>
    <h3>
        qualifyToFirstSource
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Qualify the dataset to its current first source(first from clause).  This is useful
if you have unqualified identifiers in the query that all refer to
the first source, and you want to join to another table which
has columns with the same name as columns in the current dataset.
See <a href='./patio_Dataset.html#qualifyTo'> patio.Dataset#qualifyTo</a>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).filter({id : 1}).qualifyToFirstSource();
     //=&gt; SELECT items.* FROM items WHERE (items.id = 1)
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset that is qualified with the first source.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.qualifyTo(this.firstSourceAlias);
           
}
    </pre>
    


  
    <a name="quoteIdentifier"></a>
    <h3>
        quoteIdentifier
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>name</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (name){
   if (comb.isInstanceOf(name, LiteralString)) {
       return name;
   } else {
       if (comb.isInstanceOf(name, Identifier)) {
           name = name.value;
       }
       name = this.inputIdentifier(name);
       if (this.quoteIdentifiers) {
           name = this._quotedIdentifier(name)
       }
   }
   return name;
           
}
    </pre>
    


  
    <a name="quoteSchemaTable"></a>
    <h3>
        quoteSchemaTable
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>table</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (table){
   var parts = this.schemaAndTable(table);
   var schema = parts[0];
   table = parts[1];
   return string.format(&quot;%s%s&quot;, schema ? this.quoteIdentifier(schema) + &quot;.&quot; : &quot;&quot;, this.quoteIdentifier(table));
           
}
    </pre>
    


  
    <a name="range"></a>
    <h3>
        range
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with  a range from the minimum and maximum values for the
given column.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT max(id) AS v1, min(id) AS v2 FROM table LIMIT 1
 DB.from(&quot;table&quot;).range(&quot;id&quot;).then(function(min, max){
     //e.g min === 1 AND max === 10
 });
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : the column to find the min and max value for.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved with the min and max value, as the first
and second args respectively.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   var ret = new Promise();
   this.__aggregateDataset().select(sql.min(this.stringToIdentifier(column)).as(&quot;v1&quot;), sql.max(this.stringToIdentifier(column)).as(&quot;v2&quot;)).first().then(hitch(this, function (r) {
       ret.callback(r.v1, r.v2);
   }), hitch(ret, &quot;errback&quot;));
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="remove"></a>
    <h3>
        remove
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Deletes the records in the dataset.  The returned Promise should be resolved with the
number of records deleted, but that is adapter dependent.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// DELETE * FROM table
DB.from(&quot;table&quot;).remove().then(function(numDeleted){
    //numDeleted === 3
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise resolved with the
number of records deleted, but that is adapter dependent.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cb){
   var ret = this.executeDui(this.deleteSql);
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="returning"></a>
    <h3>
        returning
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Adds a RETURNING clause, which is not supported by all databases. If returning is
used instead of returning the autogenerated primary key or update/delete returning the number of rows modified.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
ds.from(&quot;items&quot;).returning() //&quot;RETURNING *&quot;
ds.from(&quot;items&quot;).returning(null) //&quot;RETURNING NULL&quot;
ds.from(&quot;items&quot;).returning(&quot;id&quot;, &quot;name&quot;) //&quot;RETURNING id, name&quot;
ds.from(&quot;items&quot;).returning([&quot;id&quot;, &quot;name&quot;]) //&quot;RETURNING id, name&quot;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>values</em>  : columns to return. If values is an array then the array is assumed to contain the columns to return. Otherwise the arguments will be used.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a new dataset with the retuning option added.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (values){
   var args;
   if (Array.isArray(values)) {
       args = values;
   } else {
       args = comb.argsToArray(arguments);
   }
   return this.mergeOptions({returning:args.map(function (v) {
       return comb.isString(v) ? sql.stringToIdentifier(v) : v;
   })});
           
}
    </pre>
    


  
    <a name="reverse"></a>
    <h3>
        reverse
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the order reversed. If no order is
given, the existing order is inverted.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).reverse(&quot;id&quot;);
     //=&gt; SELECT * FROM items ORDER BY id DESC

DB.from(&quot;items&quot;).order(&quot;id&quot;).reverse();
     //=&gt; SELECT * FROM items ORDER BY id DESC

DB.from(&quot;items&quot;).order(&quot;id&quot;).reverse(sql.identifier(&quot;name&quot;).asc);
     //=&gt; SELECT * FROM items ORDER BY name ASC
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : variable number of columns add to order before reversing.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the order reversed.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args){
   args = comb.argsToArray(arguments);
   return this.order.apply(this, this._invertOrder(args.length ? args : this.__opts.order));
           
}
    </pre>
    


  
    <a name="reverseOrder"></a>
    <h3>
        reverseOrder
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.reverse.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="save"></a>
    <h3>
        save
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.insert.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="saveMultiple"></a>
    <h3>
        saveMultiple
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.insertMultiple.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="schemaAndTable"></a>
    <h3>
        schemaAndTable
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>tableName</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (tableName){
   var sch = this.db ? this.db.defaultSchema || null : null;
   if (comb.isString(tableName)) {
       var parts = this._splitString(tableName);
       var s = parts[0], table = parts[1];
       return [s || sch, table];
   } else if (comb.isInstanceOf(tableName, QualifiedIdentifier)) {
       return [tableName.table, tableName.column]
   } else if (comb.isInstanceOf(tableName, Identifier)) {
       return [null, tableName.value];
   } else {
       throw new QueryError(&quot;table should be a QualifiedIdentifier, Identifier, or String&quot;);
   }
           
}
    </pre>
    


  
    <a name="select"></a>
    <h3>
        select
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the columns selected changed
to the given columns. This also takes a function similar to <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).select(&quot;a&quot;);
     //=&gt; SELECT a FROM items

  DB.from(&quot;items&quot;).select(&quot;a&quot;, &quot;b&quot;);
     //=&gt; SELECT a, b FROM items

  DB.from(&quot;items&quot;).select(&quot;a&quot;, function(){
         return this.sum(&quot;b&quot;)
  }).sql;  //=&gt; SELECT a, sum(b) FROM items
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>args</em>  : variable number of colums to select</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the columns selected changed.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (args){
   args = comb.argsToArray(arguments);
   var columns = [];
   args.forEach(function (c) {
       if (comb.isFunction(c)) {
           var res = c.apply(sql, [sql]);
           columns = columns.concat(comb.isArray(res) ? res : [res]);
       } else {
           columns.push(c);
       }
   });
   var select = [];
   columns.forEach(function (c) {
       if (comb.isHash(c)) {
           for (var i in c) {
               select.push(new AliasedExpression(new Identifier(i), c[i]));
           }
       } else if (comb.isString(c)) {
           select.push(this.stringToIdentifier(c));
       } else {
           select.push(c);
       }
   }, this);
   return this.mergeOptions({select:select});
           
}
    </pre>
    


  
    <a name="selectAll"></a>
    <h3>
        selectAll
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a cloned dataset that selects *.

</p>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset that selects *.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.mergeOptions({select:null});
           
}
    </pre>
    


  
    <a name="selectAppend"></a>
    <h3>
        selectAppend
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the given columns added
to the existing selected columns. If no columns are currently selected,
it will select the columns given in addition to *.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).select(&quot;a&quot;).selectAppend(&quot;b&quot;).sql;
     //=&gt; SELECT b FROM items

  DB.from(&quot;items&quot;).select(&quot;a&quot;).selectAppend(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;).sql
     //=&gt; SELECT a, b, c, d FROM items

  DB.from(&quot;items&quot;).selectAppend(&quot;b&quot;).sql
     //=&gt; SELECT *, b FROM items
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cols</em>  : </li>
    
        <li> <em>...?</em>  : cols variable number of columns to add to the select statement</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> returns a cloned dataset with the new select columns appended.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cols){
   cols = comb.argsToArray(arguments);
   var currentSelect = this.__opts.select;
   if (!currentSelect || !currentSelect.length) {
       currentSelect = [this._static.WILDCARD];
   }
   return this.select.apply(this, currentSelect.concat(cols));
           
}
    </pre>
    


  
    <a name="selectHash"></a>
    <h3>
        selectHash
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with a hash with keyColumn values as keys and valueColumn values as
values.  Similar to <a href='./patio_Dataset.html#toHash'> patio.Dataset#toHash</a>, but only selects the two columns.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT id, name FROM table
 DB.from(&quot;table&quot;).selectHash(&quot;id&quot;, &quot;name&quot;).then(function(hash){
  // e.g {1 : &#x27;a&#x27;, 2 : &#x27;b&#x27;, ...}
 });
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>keyColumn</em>  : the column to use as the key in the hash.</li>
    
        <li> <em>valueColumn</em>  : the column to use as the value in the hash.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved with an array of hashes, that have the keyColumn
as the key and the valueColumn as the value.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (keyColumn,valueColumn,cb){
   var map = {}, args = comb.argsToArray(arguments);
   cb = comb.isFunction(args[args.length - 1]) ? args.pop() : null;
   var ret = new Promise().classic(cb);
   var k = this.__hashIdentifierToName(keyColumn), v = this.__hashIdentifierToName(valueColumn);
   var mapPromise = this.select.apply(this, args).map(function (r) {
       map[r[k]] = v ? r[v] : r;
   });
   mapPromise.then(function () {
       ret.callback(map);
   }, ret);
   return ret;
           
}
    </pre>
    


  
    <a name="selectMap"></a>
    <h3>
        selectMap
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Selects the column given (either as an argument or as a callback), and
returns an array of all values of that column in the dataset.  If you
give a block argument that returns an array with multiple entries,
the contents of the resulting array are undefined.


</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT id FROM table
 DB.from(&quot;table&quot;).selectMap(&quot;id&quot;).then(function(selectMap){
  // e,g. selectMap === [3, 5, 8, 1, ...]
});

// SELECT abs(id) FROM table
DB.from(&quot;table&quot;).selectMap(function(){
     return this.abs(&quot;id&quot;);
}).then(function(selectMap){
  //e.g selectMap === [3, 5, 8, 1, ...]
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : The column to return the values for.      See <a href='./patio_Dataset.html#select'> patio.Dataset#select</a> for valid column values.</li>
    
        <li> <em>cb?</em>  : a function to be called when the aciton is complete</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise resolved with the array of mapped values.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   var ds = this.naked().ungraphed().select(column);
   return ds.map(function (r) {
       return r[Object.keys(r)[0]];
   }, cb);
           
}
    </pre>
    


  
    <a name="selectMore"></a>
    <h3>
        selectMore
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the given columns added
to the existing selected columns. If no columns are currently selected
it will just select the columns given.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).select(&quot;a&quot;).select(&quot;b&quot;).sql;
     //=&gt; SELECT b FROM items

  DB.from(&quot;items&quot;).select(&quot;a&quot;).selectMore(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;).sql
     //=&gt; SELECT a, b, c, d FROM items

  DB.from(&quot;items&quot;).selectMore(&quot;b&quot;).sql
     //=&gt; SELECT b FROM items
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cols</em>  : </li>
    
        <li> <em>...?</em>  : cols variable number of columns to add to the select statement</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> returns a cloned dataset with the new select columns appended.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cols){
   cols = comb.argsToArray(arguments);
   var currentSelect = this.__opts.select;
   return this.select.apply(this, (currentSelect || []).concat(cols));
           
}
    </pre>
    


  
    <a name="selectOrderMap"></a>
    <h3>
        selectOrderMap
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
The same as <a href='./patio_Dataset.html#selectMap'> patio.Dataset#selectMap</a>, but in addition orders the array by the column.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT id FROM table ORDER BY id
DB.from(&quot;table&quot;).selectOrderMap(&quot;id&quot;).then(function(mappedIds){
  //e.g. [1, 2, 3, 4, ...]
});

 // SELECT abs(id) FROM table ORDER BY abs(id)
 DB.from(&quot;table&quot;).selectOrderMap(function(){
         return this.abs(&quot;id&quot;);
 }).then(function(mappedIds){
     //e.g. [1, 2, 3, 4, ...]
 });
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : The column to return the values for.      See <a href='./patio_Dataset.html#select'> patio.Dataset#select</a> for valid column values.</li>
    
        <li> <em>cb</em>  : </li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise resolved with the array of mapped values.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   var ds = this.naked()
       .ungraphed()
       .select(column)
       .order(comb.isFunction(column) ? column : this._unaliasedIdentifier(column));
   return ds.map(function (r) {
       return r[Object.keys(r)[0]];
   }, cb);
           
}
    </pre>
    


  
    <a name="set"></a>
    <h3>
        set
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
</p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   this.update.apply(this, arguments);
           
}
    </pre>
    


  
    <a name="setDefaults"></a>
    <h3>
        setDefaults
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Set the default values for insert and update statements.  The values hash passed
to insert or update are merged into this hash, so any values in the hash passed
to insert or update will override values passed to this method.

 </p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).setDefaults({a : &#x27;a&#x27;, c : &#x27;c&#x27;}).insert({a : &#x27;d&#x27;, b : &#x27;b&#x27;}).insertSql();
     //=&gt; INSERT INTO items (a, c, b) VALUES (&#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;)
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>hash</em>  : object with key value pairs to use as override values</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the defaults added to the current datasets defaults.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (hash){
   return this.mergeOptions({defaults:comb.merge({}, this.__opts.defaults || {}, hash)});
           
}
    </pre>
    


  
    <a name="setGraphAliases"></a>
    <h3>
        setGraphAliases
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/graph.js</em>

<p>
This allows you to manually specify the graph aliases to use
when using graph.  You can use it to only select certain
columns, and have those columns mapped to specific aliases
in the result set.  This is the equivalent of <a href='./patio_Dataset.html#select'> patio.Dataset#select</a> for a
graphed dataset, and must be used instead of <a href='./patio_Dataset.html#select'> patio.Dataset#select</a> whenever
graphing is used.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
var DB = patio.defaultDatabase, ds = DB.from(&quot;artists&quot;);
var p = comb.executeInOrder(ds, function(ds){
    var graphedDs = ds.graph(&quot;albums&quot;, {artist_id : id});
    //SELECT artists.name AS artist_name, albums.name AS album_name, 42 AS forty_two FROM table
    return graphedDs.setGraphAliases({artist_name : [&quot;artists&quot;, &quot;name&quot;],
                      album_name : [&quot;albums&quot;, &quot;name&quot;],
                      forty_two : [&quot;albums&quot;, &quot;fourtwo&quot;, 42]).first();
});

p.then(function(obj){
   //obj == {artists : {name : artists.name}, albums : {name : albums.name, fourtwo : 42}}
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>graphAliases</em>  : Should be a hash with keys being  column aliases, and values being                  arrays with two or three elements. The first element of the array should be the table alias,                  and the second should be the actual column name. If the array                  has a third element, it is used as the value returned, instead of                  tableAlias.columnName.</li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (graphAliases){
   var ds = this.select.apply(this, this.__graphAliasColumns(graphAliases));
   ds.__opts.graphAliases = graphAliases;
   return ds;
       
}
    </pre>
    


  
    <a name="setOverrides"></a>
    <h3>
        setOverrides
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Set values that override hash arguments given to insert and update statements.
This hash is merged into the hash provided to insert or update, so values
will override any values given in the insert/update hashes.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).setOverrides({a : &#x27;a&#x27;, c : &#x27;c&#x27;}).insert({a : &#x27;d&#x27;, b : &#x27;b&#x27;}).insertSql();
     //=&gt; INSERT INTO items (a, c, b) VALUES (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;)
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>hash</em>  : object with key value pairs to use as override values</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the overrides added to the current datasets overrides.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (hash){
   return this.mergeOptions({overrides:comb.merge({}, this.__opts.overrides || {}, hash)});
           
}
    </pre>
    


  
    <a name="singleRecord"></a>
    <h3>
        singleRecord
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with  the first record in the dataset, or null if the dataset
has no records. Users should probably use <a href='./patio_Dataset.html#first'> patio.Dataset#first</a> instead of
this method.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
//&#x27;SELECT * FROM test LIMIT 1&#x27;
DB.from(&quot;test&quot;).singleRecord().then(function(r) {
    //e.g r === {id : 1, name : &quot;firstName&quot;}
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cb?</em>  : a function to be called when the aciton is complete</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise resolved with the first record returned from the query.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cb){
   var ret = new Promise().classic(cb);
   this.mergeOptions({limit:1}).all().then(function (r) {
       ret.callback(r &amp;&amp; r.length ? r[0] : null);
   }, ret);
   return ret;
           
}
    </pre>
    


  
    <a name="singleValue"></a>
    <h3>
        singleValue
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with the first value of the first record in the dataset.
Returns null if dataset is empty.  Users should generally use
<a href='./patio_Dataset.html#get'> patio.Dataset#get</a> instead of this method.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
//&#x27;SELECT * FROM test LIMIT 1&#x27;
DB.from(&quot;test&quot;).singleValue().then(function(r) {
    //e.g r === 1
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that will be resolved with the first value of the first row returned
from the dataset.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cb){
   var ret = new Promise().classic(cb);
   this.naked().ungraphed().singleRecord().then(function (r) {
       ret.callback(r ? r[Object.keys(r)[0]] : null);
   }, hitch(ret, &quot;errback&quot;));
   return ret;
           
}
    </pre>
    


  
    <a name="stringToIdentifier"></a>
    <h3>
        stringToIdentifier
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/index.js</em>

<p>
Converts a string to an <a href='./patio_sql_Identifier.html#'> patio.sql.Identifier</a>, <a href='./patio_sql_QualifiedIdentifier.html#'> patio.sql.QualifiedIdentifier</a>,
or <a href='./patio_sql_AliasedExpression.html#'> patio.sql.AliasedExpression</a>, depending on the format:

<ul>
     <li>For columns : table__column___alias.</li>
     <li>For tables : schema__table___alias.</li>
</ul>
each portion of the identifier is optional. See example below

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
ds.stringToIdentifier(&quot;a&quot;) //= &gt; new patio.sql.Identifier(&quot;a&quot;);
ds.stringToIdentifier(&quot;table__column&quot;); //=&gt; new patio.sql.QualifiedIdentifier(table, column);
ds.stringToIdentifier(&quot;table__column___alias&quot;);
     //=&gt; new patio.sql.AliasedExpression(new patio.sql.QualifiedIdentifier(table, column), alias);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>name</em>  : the name to covert to an an <a href='./patio_sql_Identifier.html#'> patio.sql.Identifier</a>, <a href='./patio_sql_QualifiedIdentifier.html#'> patio.sql.QualifiedIdentifier</a>, or <a href='./patio_sql_AliasedExpression.html#'> patio.sql.AliasedExpression</a>.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.sql.Identifier|patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression</code> an identifier generated based on the name string.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (name){
   if (comb.isString(name)) {
       var parts = this._splitString(name);
       var schema = parts[0], table = parts[1], alias = parts[2];
       return (schema &amp;&amp; table &amp;&amp; alias
               ? new AliasedExpression(new QualifiedIdentifier(schema, table), alias)
               : (schema &amp;&amp; table
               ? new QualifiedIdentifier(schema, table)
               : (table &amp;&amp; alias
               ? new AliasedExpression(new Identifier(table), alias) : new Identifier(table))));
   } else {
       return name;
   }
           
}
    </pre>
    


  
    <a name="subscriptSql"></a>
    <h3>
        subscriptSql
        
        
        <span class="label label-label">Function</span>
        
        
        <span class="label label-important">Private</span>
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
</p>


    <em>Arguments</em>
    <ul>
    
        <li> <em>s</em>  : </li>
    
     </ul>




    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (s){
   return string.format(&quot;%s[%s]&quot;, this.literal(s.f), this.__expressionList(s.sub));
           
}
    </pre>
    


  
    <a name="sum"></a>
    <h3>
        sum
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved the sum for the given column.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT sum(id) FROM table LIMIT 1
DB.from(&quot;table&quot;).sum(&quot;id&quot;).then(function(sum){
  // e.g sum === 55
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>column</em>  : the column to find the sum of.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise resolved with the sum of the column.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (column,cb){
   return this.__aggregateDataset().get(sql.sum(this.stringToIdentifier(column)), cb);
           
}
    </pre>
    


  
    <a name="toCsv"></a>
    <h3>
        toCsv
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with a string in CSV format containing the dataset records. By
default the CSV representation includes the column titles in the
first line. You can turn that off by passing false as the
includeColumnTitles argument.

<p>
   <b>NOTE:</b> This does not use a CSV library or handle quoting of values in
         any way.  If any values in any of the rows could include commas or line
         endings, you shouldn't use this.
</p>

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT * FROM table
 DB.from(&quot;table&quot;).toCsv().then(function(csv){
     console.log(csv);
     //outputs
       id,name
       1,Jim
       2,Bob
 });

   // SELECT * FROM table
 DB.from(&quot;table&quot;).toCsv(false).then(function(csv){
     console.log(csv);
     //outputs
       1,Jim
       2,Bob
 });
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>[includeColumnTitles= <code>true</code>]</em>  : Set to false to prevent the printing of the column
 titles as the first line.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that will be resolved with the CSV string of the results of the
 query.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (includeColumnTitles,cb){
   var n = this.naked();
   if(comb.isFunction(includeColumnTitles)){
       cb = includeColumnTitles;
       includeColumnTitles = true;
   }
   includeColumnTitles = comb.isBoolean(includeColumnTitles) ? includeColumnTitles : true;
   var csv = null, cols = [];
   var ret = new comb.Promise().classic(cb);
   n.columns.then(hitch(this, function (cols) {
       var vals = [];
       if (includeColumnTitles) {
           vals.push(cols.join(&quot;, &quot;));
       }
       n.forEach(
           function (r) {
               vals.push(cols.map(
                   function (c) {
                       return r[c] || &quot;&quot;;
                   }).join(&quot;, &quot;));
           }).then(function () {
               ret.callback(vals.join(&quot;\r\n&quot;) + &quot;\r\n&quot;);
           }, hitch(ret, &quot;errback&quot;));
   }), hitch(ret, &quot;errback&quot;));
   return ret;
           
}
    </pre>
    


  
    <a name="toHash"></a>
    <h3>
        toHash
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Returns a promise resolved with a hash with one column used as key and another used as value.
If rows have duplicate values for the key column, the latter row(s)
will overwrite the value of the previous row(s). If the valueColumn
is not given or null, uses the entire hash as the value.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// SELECT * FROM table
 DB.from(&quot;table&quot;).toHash(&quot;id&quot;, &quot;name&quot;).then(function(hash){
   // {1 : &#x27;Jim&#x27;, 2 : &#x27;Bob&#x27;, ...}
 });

// SELECT * FROM table
DB.from(&quot;table&quot;).toHash(&quot;id&quot;).then(function(hash){
  // {1 : {id : 1, name : &#x27;Jim&#x27;}, 2 : {id : 2, name : &#x27;Bob&#x27;}, ...}
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>keyColumn</em>  : the column  to use as the key in the returned hash.</li>
    
        <li> <em>valueColumn</em>  : </li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
        <li> <em>[keyValue= <code>null</code>]</em> <code>String|patio.sql.Identifier\patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression</code> : the
 key of the column to use as the value in the hash</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that will be resolved with the resulting hash.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (keyColumn,valueColumn,cb){
   var ret = new Promise(), map = {};
   if (comb.isFunction(valueColumn)) {
       cb = valueColumn;
       valueColumn = null;
   }
   var k = this.__hashIdentifierToName(keyColumn), v = this.__hashIdentifierToName(valueColumn);
   var mapPromise = this.map(function (r) {
       map[r[k]] = v ? r[v] : r;
   });
   mapPromise.then(function () {
       ret.callback(map);
   }, hitch(ret, &quot;errback&quot;));
   ret.classic(cb);
   return ret;
           
}
    </pre>
    


  
    <a name="truncate"></a>
    <h3>
        truncate
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Truncates the dataset.  Returns a promise that is resolved once truncation is complete.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// TRUNCATE table
DB.from(&quot;table&quot;).truncate().then(function(){
    //...do something
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is resolved once truncation is complete.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (cb){
   return this.executeDdl(this.truncateSql).classic(cb);
           
}
    </pre>
    


  
    <a name="unfiltered"></a>
    <h3>
        unfiltered
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with no filters (HAVING or WHERE clause) applied.
</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).group(&quot;a&quot;).having({a : 1}).where(&quot;b&quot;).unfiltered().sql;
     //=&gt; SELECT * FROM items GROUP BY a
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with no HAVING or WHERE clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.mergeOptions({where:null, having:null});
           
}
    </pre>
    


  
    <a name="ungraphed"></a>
    <h3>
        ungraphed
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/graph.js</em>

<p>
Remove the splitting of results into subhashes, and all metadata
related to the current graph (if any).
     </p>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.mergeOptions({graph:null});
       
}
    </pre>
    


  
    <a name="ungrouped"></a>
    <h3>
        ungrouped
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with no GROUP or HAVING clause.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;t&quot;).group(&quot;a&quot;).having({a : 1}).where(&quot;b&quot;).ungrouped().sql;
     //=&gt; SELECT * FROM t WHERE b
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with no GROUP or HAVING clause.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.mergeOptions({group:null, having:null});
           
}
    </pre>
    


  
    <a name="union"></a>
    <h3>
        union
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Adds a UNION clause using a second dataset object.
A UNION compound dataset returns all rows in either the current dataset
or the given dataset.
Options:
:alias :: Use the given value as the from_self alias
:all :: Set to true to use UNION ALL instead of UNION, so duplicate rows can occur
:from_self :: Set to false to not wrap the returned dataset in a from_self, use with care.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).union(DB.from(&quot;otherItems&quot;)).sql;
     //=&gt; SELECT * FROM items UNION SELECT * FROM other_items

DB.from(&quot;items&quot;).union(DB.from(&quot;otherItems&quot;), {all : true, fromSelf : false}).sql;
     //=&gt; SELECT * FROM items UNION ALL SELECT * FROM other_items

DB.from(&quot;items&quot;).union(DB.from(&quot;otherItems&quot;), {alias : &quot;i&quot;})
     //=&gt; SELECT * FROM (SELECT * FROM items UNION SELECT * FROM other_items) AS i
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>dataset</em>  : dataset to union with</li>
    
        <li> <em>opts</em>  : addional options</li>
    
        <li> <em>opts.alias?</em> <code>String|patio.sql.Identifier</code> : Alias to use as the fromSelf alias.</li>
    
        <li> <em>[opt.all= <code>false</code>]</em> <code>Boolean</code> : Set to true to use UNION ALL instead of UNION so duplicate rows can occur</li>
    
        <li> <em>[opts.fromSelf= <code>true</code>]</em> <code>Boolean</code> : Set to false to not wrap the returned dataset in a fromSelf.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the union.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (dataset,opts){
   opts = comb.isUndefined(opts) ? {} : opts;
   if (!comb.isHash(opts)) {
       opts = {all:opts};
   }
   return this.compoundClone(&quot;union&quot;, dataset, opts);
           
}
    </pre>
    


  
    <a name="unlimited"></a>
    <h3>
        unlimited
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with no limit or offset.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;t&quot;).limit(10, 20).unlimited().sql;
     //=&gt; SELECT * FROM t
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with no limit or offset.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.mergeOptions({limit:null, offset:null});
           
}
    </pre>
    


  
    <a name="unordered"></a>
    <h3>
        unordered
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with no order.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;t&quot;).order(&quot;a&quot;, sql.identifier(&quot;b&quot;).desc()).unordered().sql;
     //=&gt; SELECT * FROM t
        </pre>



    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with no order.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this.order(null);
           
}
    </pre>
    


  
    <a name="unusedTableAlias"></a>
    <h3>
        unusedTableAlias
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Creates a unique table alias that hasn't already been used in this dataset.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;table&quot;).unusedTableAlias(&quot;t&quot;);
      //=&gt; &quot;t&quot;

DB.from(&quot;table&quot;).unusedTableAlias(&quot;table&quot;);
  //=&gt; &quot;table0&quot;

DB.from(&quot;table&quot;, &quot;table0&quot;]).unusedTableAlias(&quot;table&quot;);
  //=&gt; &quot;table1&quot;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>tableAlias</em>  : the table to get an unused alias for.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String</code> the implicit alias that is in tableAlias with a possible "N"
                 if the alias has already been used, where N is an integer starting at 0.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (tableAlias){
   tableAlias = this._toTableName(tableAlias);
   var usedAliases = [], from, join;
   if ((from = this.__opts.from) != null) {
       usedAliases = usedAliases.concat(from.map(function (n) {
           return this._toTableName(n)
       }, this));
   }
   if ((join = this.__opts.join) != null) {
       usedAliases = usedAliases.concat(join.map(function (join) {
           if (join.tableAlias) {
               return this.__toAliasedTableName(join.tableAlias);
           } else {
               return this._toTableName(join.table);
           }
       }, this));
   }
   if (usedAliases.indexOf(tableAlias) != -1) {
       var base = tableAlias, i = 0;
       do {
           tableAlias = comb.string.format(&quot;%s%d&quot;, base, i++);
       } while (usedAliases.indexOf(tableAlias) != -1)
   }
   return tableAlias;
           
}
    </pre>
    


  
    <a name="update"></a>
    <h3>
        update
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/actions.js</em>

<p>
Updates values for the dataset.  The returned promise is resolved with a value that is generally the
number of rows updated, but that is adapter dependent.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
// UPDATE table SET x = NULL
 DB.from(&quot;table&quot;).update({x : null}).then(function(numRowsUpdated){
     //e.g. numRowsUpdated === 10
 });

// UPDATE table SET x = (x + 1), y = 0
DB.from(&quot;table&quot;).update({ x : sql.x.plus(1), y : 0}).then(function(numRowsUpdated){
  // e.g. numRowsUpdated === 10
});
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>values</em>  : See <a href='./patio_Dataset.html#updateSql'> patio.Dataset#updateSql</a> for parameter types.</li>
    
        <li> <em>cb?</em>  : the callback to invoke when the action is done.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>comb.Promise</code> a promise that is generally resolved with the
number of rows updated, but that is adapter dependent.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (values,cb){
   return this.executeDui(this.updateSql(values)).classic(cb);
           
}
    </pre>
    


  
    <a name="updateSql"></a>
    <h3>
        updateSql
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/sql.js</em>

<p>
Formats an UPDATE statement using the given values.  See <a href='./patio_dataset.html#update'> patio.dataset._Actions#update</a>.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).updateSql({price : 100, category : &#x27;software&#x27;});
     //=&gt; &quot;UPDATE items SET price = 100, category = &#x27;software&#x27;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>values</em>  : </li>
    
        <li> <em>Variable</em> <code>*...</code> : number of values to update the table with.  The UPDATE statement created depends on the values passed in.          <ul>              <li>Object : the keys will be used as the columns and the values will be the values to set to columns to</li>              <li><a href='./patio_sql_Expression.html#'> patio.sql.Expression</a> : the <a href='./patio_dataset.html#literal'> patio.dataset._Sql#literal</a> representation of the                      <a href='./patio_sql_Expression.html#'> patio.sql.Expression</a> will be used as the value              </li>              </li> Other : the <a href='./patio_dataset.html#literal'> patio.dataset._Sql#literal</a> value will be used as the value</li>          </ul></li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>String</code> the UPDATE statement.</li>
    
    </ul>


    <em>Throws</em>
    <ul>
    
        <li> <code>QueryError</code> If the dataset is grouped or includes more than one table.</li>
    
    </ul>


    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (values){
   values = comb.argsToArray(arguments);
   if (this.__opts.sql) return this._staticSql(this.__opts.sql);
   this.__checkModificationAllowed();
   return this.mergeOptions({values:values})._updateSql();
           
}
    </pre>
    


  
    <a name="where"></a>
    <h3>
        where
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Add a condition to the WHERE clause.  See <a href='./patio_Dataset.html#filter'> patio.Dataset#filter</a> for argument types.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;test&quot;).where(&#x27;price &lt; ? AND id in ?&#x27;, 100, [1, 2, 3]).sql;
     //=&gt; &quot;SELECT * FROM test WHERE (price &lt; 100 AND id in (1, 2, 3))&quot;
  DB.from(&quot;test&quot;).where(&#x27;price &lt; {price} AND id in {ids}&#x27;, {price:100, ids:[1, 2, 3]}).sql;
     //=&gt; &quot;SELECT * FROM test WHERE (price &lt; 100 AND id in (1, 2, 3))&quot;)
        </pre>





    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (){
   return this._filter.apply(this, [&quot;where&quot;].concat(comb.argsToArray(arguments)));
           
}
    </pre>
    


  
    <a name="with"></a>
    <h3>
        with
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Add a common table expression (CTE) with the given name and a dataset that defines the CTE.
A common table expression acts as an inline view for the query.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;t&quot;)[&quot;with&quot;](&quot;t&quot;, db.from(&quot;x&quot;))[&quot;with&quot;](&quot;j&quot;, db.from(&quot;y&quot;)).sql;
     //=&gt; &#x27;WITH t AS (SELECT * FROM x), j AS (SELECT * FROM y) SELECT * FROM t&#x27;

DB.from(&quot;t&quot;)[&quot;with&quot;](&quot;t&quot;, db.from(&quot;x&quot;)).withRecursive(&quot;j&quot;, db.from(&quot;y&quot;), db.from(&quot;j&quot;)).sql;
     //=&gt; &#x27;WITH t AS (SELECT * FROM x), j AS (SELECT * FROM y UNION ALL SELECT * FROM j) SELECT * FROM t&#x27;

DB.from(&quot;t&quot;)[&quot;with&quot;](&quot;t&quot;, db.from(&quot;x&quot;), {args:[&quot;b&quot;]}).sql;
     //=&gt; &#x27;WITH t(b) AS (SELECT * FROM x) SELECT * FROM t&#x27;
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>name</em>  : the name of the to assign to the CTE.</li>
    
        <li> <em>dataset</em>  : the dataset to use for the CTE.</li>
    
        <li> <em>opts</em>  : extra options.</li>
    
        <li> <em>opts.args?</em> <code>String[]</code> : colums/args for the CTE.</li>
    
        <li> <em>opts.recursive?</em> <code>Boolean</code> : set to true that the CTE is recursive.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the CTE.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (name,dataset,opts){
   if (!this.supportsCte) {
       throw new QueryError(&quot;this dataset does not support common table expressions&quot;);
   }
   return this.mergeOptions({
       &quot;with&quot;:(this.__opts[&quot;with&quot;] || []).concat([comb.merge(opts || {}, {name:this.stringToIdentifier(name), dataset:dataset})])
   });
           
}
    </pre>
    


  
    <a name="withRecursive"></a>
    <h3>
        withRecursive
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Add a recursive common table expression (CTE) with the given name, a dataset that
defines the nonrecursive part of the CTE, and a dataset that defines the recursive part
of the CTE.

 </p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
//Sing withRecursive call.
DB.from(&quot;t&quot;).withRecursive(&quot;t&quot;, db.from(&quot;x&quot;), db.from(&quot;t&quot;)).sql;
         //=&gt; &#x27;WITH t AS (SELECT * FROM x UNION ALL SELECT * FROM t) SELECT * FROM t&#x27;

//Multiple withRecursive calls.
DB.from(&quot;t&quot;).withRecursive(&quot;t&quot;, db.from(&quot;x&quot;), db.from(&quot;t&quot;))
   .withRecursive(&quot;j&quot;, db.from(&quot;y&quot;), db.from(&quot;j&quot;)).sql;
         //=&gt; &#x27;WITH t AS (SELECT * FROM x UNION ALL SELECT * FROM t),
                    j AS (SELECT * FROM y UNION ALL SELECT * FROM j) SELECT * FROM t&#x27;;

//Adding args
DB.from(&quot;t&quot;).withRecursive(&quot;t&quot;, db.from(&quot;x&quot;), db.from(&quot;t&quot;), {args:[&quot;b&quot;, &quot;c&quot;]}).sql;
         //=&gt; &#x27;WITH t(b, c) AS (SELECT * FROM x UNION ALL SELECT * FROM t) SELECT * FROM t&#x27;

//Setting union all to false
DB.from(&quot;t&quot;).withRecursive(&quot;t&quot;, db.from(&quot;x&quot;), db.from(&quot;t&quot;), {unionAll:false}).sql;
         //=&gt; &#x27;WITH t AS (SELECT * FROM x UNION SELECT * FROM t) SELECT * FROM t&#x27;);
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>name</em>  : the name to assign to the CTE</li>
    
        <li> <em>nonRecursive</em>  : the non-recursive part of the CTE</li>
    
        <li> <em>recursive</em>  : the recursive part of the CTE</li>
    
        <li> <em>[opts= <code>{}</code>]</em>  : extra options</li>
    
        <li> <em>opts.args?</em> <code>String[]</code> : columns to include with the CTE</li>
    
        <li> <em>opts.unionAll?</em> <code>Boolena</code> : set to false to use UNION instead of UNION ALL when combining non recursive
                               with recursive.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the CTE.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (name,nonRecursive,recursive,opts){
   if (!this.supportsCte) {
       throw new QueryError(&quot;This dataset does not support common table expressions&quot;);
   }
   opts = opts || {};
   var wit = (this.__opts[&quot;with&quot;] || []).concat([comb.merge(opts, {recursive:true, name:this.stringToIdentifier(name), dataset:nonRecursive.union(recursive, {all:opts.unionAll != false, fromSelf:false})})]);
   return this.mergeOptions({&quot;with&quot;:wit});
           
}
    </pre>
    


  
    <a name="withSql"></a>
    <h3>
        withSql
        
        
        <span class="label label-label">Function</span>
        
        
                
         <span class="label label-success">Public</span>
                
        
   </h3>

<hr/>
<em>Defined dataset/query.js</em>

<p>
Returns a copy of the dataset with the static SQL used.  This is useful if you want
to keep the same <a href='./patio_Dataset.html#rowCb'> patio.Dataset#rowCb</a>/<a href='./patio_Dataset.html#graph'> patio.Dataset#graph</a>,
 but change the SQL used to custom SQL.

</p>

    <em>Example</em>
        <pre class="prettyprint linenums lang-js">
DB.from(&quot;items&quot;).withSql(&#x27;SELECT * FROM foo&#x27;)
         //=&gt; SELECT * FROM foo
        </pre>


    <em>Arguments</em>
    <ul>
    
        <li> <em>sql</em>  : sql for the dataset to use.</li>
    
     </ul>


    <em>Returns</em>
    <ul>
    
        <li> <code>patio.Dataset</code> a cloned dataset with the static sql set.</li>
    
    </ul>



    
    <em>Source</em>
    <pre class="prettyprint linenums lang-js">
function (sql){
   var args = comb.argsToArray(arguments).slice(1);
   if (args.length) {
       sql = new PlaceHolderLiteralString(sql, args)
   }
   return this.mergeOptions({sql:sql});
           
}
    </pre>
    


  

</div>
</div>
<script type="text/javascript" src="./assets/js/jquery.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-transition.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-dropdown.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-tab.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-tooltip.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-popover.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-button.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-collapse.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap-carousel.js"></script>
<script type="text/javascript"
        src="./assets/js/google-code-prettify/prettify.js"></script>

</body>
</html>
