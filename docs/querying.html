<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>patio</title>
    <link rel="stylesheet" href="./assets/css/bootstrap.css">
    <link rel="stylesheet" href="./assets/css/prettify.css">
    <style type="text/css">
        

/*.subnav-inner {*/
    /*width: 100%;*/
    /*height: 36px;*/
    /*background-color: #EEE;*/
    /*background-repeat: repeat-x;*/
    /*background-image: -moz-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, whiteSmoke), color-stop(100%, #EEE));*/
    /*background-image: -webkit-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -ms-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -o-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(startColorstr = '#f5f5f5', endColorstr = '#eeeeee', GradientType = 0);*/
    /*background-image: linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*-webkit-border-radius: 4px;*/
    /*-moz-border-radius: 4px;*/
    /*border-radius: 4px;*/
/*}*/

/*.subnav .nav > li > a:hover {*/
    /*color: black !important;*/
/*}*/

/*.subnav .nav li.dropdown .dropdown-toggle .caret,*/
/*.subnav .nav li.dropdown.open .caret {*/
    /*border-top-color: #999 !important;*/
    /*border-bottom-color: #999 !important;*/
/*}*/

/*.subnav-fixed {*/
    /*position: fixed;*/
    /*width : 90%;*/
    /*margin-right: auto;*/
    /*margin-left: auto;*/
    /*top: 40px;*/
    /*left: 0;*/
    /*right: 0;*/
    /*z-index: 1020;*/
    /*border-color: #D5D5D5;*/
    /*border-width: 0 0 1px;*/
    /*-webkit-border-radius: 0;*/
    /*-moz-border-radius: 0;*/
    /*border-radius: 0;*/
    /*-webkit-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*-moz-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);*/
/*}*/

/*.navbar .nav  .dropdown-menu {*/
    /*max-height: 500px;*/
    /*overflow: auto;*/
/*}â€‹*/

    </style>
    <style type="text/css">
        body {
            padding: 90px;
        }

        .subnav{
            margin-top: 40px;
            margin-right: auto;
            margin-left: auto;
            z-index: 1000;
        }

        @media (max-width:979px) {
            .subnav{
                margin-top: auto;
            }
        }
    </style>
    <link rel="stylesheet" href="./assets/css/bootstrap-responsive.css">
    <script type="text/javascript">
        var init = (function () {
            "use strict";

            var processScroll = (function () {
                var curr = null, prev = null;
                return function (nav) {
                    var $win = $(window);
                    $('.subnav').each(function () {
                        var nav = $(this);
                        var navTop = $win.width() < 980 ? 0 : nav.offset().top - 40;

                        var scrollTop = $win.scrollTop();
                        if (scrollTop >= navTop && curr != nav) {
                            if(curr){
                                curr.removeClass('subnav-fixed')
                                prev = curr;
                            }
                            curr = nav;
                            curr.addClass('subnav-fixed')
                        } else if (curr == nav && scrollTop <= navTop) {
                            curr.removeClass('subnav-fixed');
                            prev.addClass('subnav-fixed');
                            curr = prev;
                        }else{
                            nav.removeClass('subnav-fixed');
                        }
                    });
                };
            })();

            return function () {
                window.prettyPrint && prettyPrint();
                $(".collapse").collapse();
                var $window = $(window);
                //$(".subnav").affix ();
                // fix sub nav on scroll
//                processScroll();
//                $(window).on('scroll', processScroll)
            }
        })();
    </script>
</head>
<body onload="init()">
<div class="navbar navbar-fixed-top navbar-inverse">
    <div class="navbar-inner">
        <div class="container">
            <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"> </span>
            </a>
            
            <a href="./index.html" class="brand">patio</a>
            
            <div class="nav-collapse">
                <ul class="nav">
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Docs<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
                            <li><a href="./connecting.html">Connecting</a></li>
                            
                            <li><a href="./models.html">Models</a></li>
                            
                            <li><a href="./associations.html">Associations</a></li>
                            
                            <li><a href="./model-inheritance.html">Model Inheritance</a></li>
                            
                            <li><a href="./validation.html">Model Validation</a></li>
                            
                            <li><a href="./plugins.html">Model Plugins</a></li>
                            
                            <li><a href="./querying.html">Querying</a></li>
                            
                            <li><a href="./DDL.html">DDL</a></li>
                            
                            <li><a href="./migrations.html">Migrations</a></li>
                            
                            <li><a href="./logging.html">Logging</a></li>
                            
                            <li><a href="./coverage.html">Test Coverage</a></li>
                            
                        </ul>
                        

                        
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
                            <li><a href="patio_sql.html">patio.sql</a></li>
                            
                            <li><a href="patio_sql_Constants.html">patio.sql.Constants</a></li>
                            
                        </ul>
                    </li>
                    
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
                            <li><a href="./patio.html">patio</a></li>
                            
                            <li><a href="./patio_AlterTableGenerator.html">patio.AlterTableGenerator</a></li>
                            
                            <li><a href="./patio_AssociationError.html">patio.AssociationError</a></li>
                            
                            <li><a href="./patio_ConnectionPool.html">patio.ConnectionPool</a></li>
                            
                            <li><a href="./patio_Database.html">patio.Database</a></li>
                            
                            <li><a href="./patio_DatabaseError.html">patio.DatabaseError</a></li>
                            
                            <li><a href="./patio_Dataset.html">patio.Dataset</a></li>
                            
                            <li><a href="./patio_DatasetError.html">patio.DatasetError</a></li>
                            
                            <li><a href="./patio_ExpressionError.html">patio.ExpressionError</a></li>
                            
                            <li><a href="./patio_MigrationError.html">patio.MigrationError</a></li>
                            
                            <li><a href="./patio_Model.html">patio.Model</a></li>
                            
                            <li><a href="./patio_ModelError.html">patio.ModelError</a></li>
                            
                            <li><a href="./patio_NotImplemented.html">patio.NotImplemented</a></li>
                            
                            <li><a href="./patio_PatioError.html">patio.PatioError</a></li>
                            
                            <li><a href="./patio_QueryError.html">patio.QueryError</a></li>
                            
                            <li><a href="./patio_SchemaGenerator.html">patio.SchemaGenerator</a></li>
                            
                            <li><a href="./patio_Time.html">patio.Time</a></li>
                            
                            <li><a href="./patio_associations_Association.html">patio.associations.Association</a></li>
                            
                            <li><a href="./patio_associations_ManyToMany.html">patio.associations.ManyToMany</a></li>
                            
                            <li><a href="./patio_associations_ManyToOne.html">patio.associations.ManyToOne</a></li>
                            
                            <li><a href="./patio_associations_ManyToOne.html">patio.associations.ManyToOne</a></li>
                            
                            <li><a href="./patio_associations_OneToMany.html">patio.associations.OneToMany</a></li>
                            
                            <li><a href="./patio_dataset.html#._Query">patio.dataset._Query</a></li>
                            
                            <li><a href="./patio_migrations_IntegerMigrator.html">patio.migrations.IntegerMigrator</a></li>
                            
                            <li><a href="./patio_migrations_Migrator.html">patio.migrations.Migrator</a></li>
                            
                            <li><a href="./patio_migrations_TimestampMigrator.html">patio.migrations.TimestampMigrator</a></li>
                            
                            <li><a href="./patio_plugins_CachePlugin.html">patio.plugins.CachePlugin</a></li>
                            
                            <li><a href="./patio_plugins_ClassTableInheritancePlugin.html">patio.plugins.ClassTableInheritancePlugin</a></li>
                            
                            <li><a href="./patio_plugins_ColumnMapper.html">patio.plugins.ColumnMapper</a></li>
                            
                            <li><a href="./patio_plugins_TimeStampPlugin.html">patio.plugins.TimeStampPlugin</a></li>
                            
                            <li><a href="./patio_plugins_ValidatorPlugin.html">patio.plugins.ValidatorPlugin</a></li>
                            
                            <li><a href="./patio_sql_AliasMethods.html">patio.sql.AliasMethods</a></li>
                            
                            <li><a href="./patio_sql_AliasedExpression.html">patio.sql.AliasedExpression</a></li>
                            
                            <li><a href="./patio_sql_BitWiseMethods.html">patio.sql.BitWiseMethods</a></li>
                            
                            <li><a href="./patio_sql_BooleanConstant.html">patio.sql.BooleanConstant</a></li>
                            
                            <li><a href="./patio_sql_BooleanExpression.html">patio.sql.BooleanExpression</a></li>
                            
                            <li><a href="./patio_sql_BooleanMethods.html">patio.sql.BooleanMethods</a></li>
                            
                            <li><a href="./patio_sql_CaseExpression.html">patio.sql.CaseExpression</a></li>
                            
                            <li><a href="./patio_sql_Cast.html#.constructor">patio.sql.Cast.constructor</a></li>
                            
                            <li><a href="./patio_sql_CastMethods.html">patio.sql.CastMethods</a></li>
                            
                            <li><a href="./patio_sql_ColumnAll.html">patio.sql.ColumnAll</a></li>
                            
                            <li><a href="./patio_sql_ComplexExpression.html">patio.sql.ComplexExpression</a></li>
                            
                            <li><a href="./patio_sql_ComplexExpressionMethods.html">patio.sql.ComplexExpressionMethods</a></li>
                            
                            <li><a href="./patio_sql_Constant.html">patio.sql.Constant</a></li>
                            
                            <li><a href="./patio_sql_DateTime.html">patio.sql.DateTime</a></li>
                            
                            <li><a href="./patio_sql_Decimal.html">patio.sql.Decimal</a></li>
                            
                            <li><a href="./patio_sql_Expression.html">patio.sql.Expression</a></li>
                            
                            <li><a href="./patio_sql_Float.html">patio.sql.Float</a></li>
                            
                            <li><a href="./patio_sql_GenericExpression.html">patio.sql.GenericExpression</a></li>
                            
                            <li><a href="./patio_sql_Identifier.html">patio.sql.Identifier</a></li>
                            
                            <li><a href="./patio_sql_InequalityMethods.html">patio.sql.InequalityMethods</a></li>
                            
                            <li><a href="./patio_sql_JoinClause.html">patio.sql.JoinClause</a></li>
                            
                            <li><a href="./patio_sql_JoinOnClause.html">patio.sql.JoinOnClause</a></li>
                            
                            <li><a href="./patio_sql_JoinUsingClause.html">patio.sql.JoinUsingClause</a></li>
                            
                            <li><a href="./patio_sql_LiteralString.html#.constructor">patio.sql.LiteralString.constructor</a></li>
                            
                            <li><a href="./patio_sql_NoBooleanInputMethods.html">patio.sql.NoBooleanInputMethods</a></li>
                            
                            <li><a href="./patio_sql_NumericExpression.html">patio.sql.NumericExpression</a></li>
                            
                            <li><a href="./patio_sql_NumericMethods.html">patio.sql.NumericMethods</a></li>
                            
                            <li><a href="./patio_sql_OrderedExpression.html">patio.sql.OrderedExpression</a></li>
                            
                            <li><a href="./patio_sql_OrderedMethods.html">patio.sql.OrderedMethods</a></li>
                            
                            <li><a href="./patio_sql_PlaceHolderLiteralString.html">patio.sql.PlaceHolderLiteralString</a></li>
                            
                            <li><a href="./patio_sql_QualifiedIdentifier.html">patio.sql.QualifiedIdentifier</a></li>
                            
                            <li><a href="./patio_sql_QualifyingMethods.html">patio.sql.QualifyingMethods</a></li>
                            
                            <li><a href="./patio_sql_SQLFunction.html">patio.sql.SQLFunction</a></li>
                            
                            <li><a href="./patio_sql_StringConcatenationMethods.html">patio.sql.StringConcatenationMethods</a></li>
                            
                            <li><a href="./patio_sql_StringExpression.html">patio.sql.StringExpression</a></li>
                            
                            <li><a href="./patio_sql_StringMethods.html">patio.sql.StringMethods</a></li>
                            
                            <li><a href="./patio_sql_SubScript.html">patio.sql.SubScript</a></li>
                            
                            <li><a href="./patio_sql_SubscriptMethods.html">patio.sql.SubscriptMethods</a></li>
                            
                            <li><a href="./patio_sql_Time.html">patio.sql.Time</a></li>
                            
                            <li><a href="./patio_sql_TimeStamp.html">patio.sql.TimeStamp</a></li>
                            
                            <li><a href="./patio_sql_Year.html">patio.sql.Year</a></li>
                            
                        </ul>
                    </li>
                    
                </ul>
                
                <ul class="nav pull-right">

                    <li class="divider-vertical"></li>
                    <li><a href="https://github.com/Pollenware/patio" target="#github" class="pull-right">github</a></li>
                </ul>
                
            </div>
        </div>
    </div>
</div>



<div class="container-fluid">
    <a name="top"></a>
    <div class="container">



<h1>Querying</h1>
<h2>Reading objects</h2>
<p>patio provides a few separate methods for retrieving objects from the database. The underlying
method is <a href="./patio_Dataset.html#forEach">forEach</a>, which interates each row as the <a href="./patio_Database.html">patio.Database</a> provides it. However, while <a href="./patio_Dataset.html#forEach">forEach</a> can and often is used directly, in many cases there is a more convenient retrieval method you can use.

</p>
<p><strong>Note</strong> For all examples below a generic error handler is used which could be defined as follows

</p>
<pre class='prettyprint linenums lang-js'><code>var errorHandler = function(err){
   console.log(err.stack);
}</code></pre>
<h2>Getting a dataset</h2>
<p>To get a dataset use the <a href="./patio_Database.html#from">DB.from</a> method.

</p>
<pre class='prettyprint linenums lang-js'><code>var DB = patio.connect(&lt;CONNECTION_URI&gt;)
var User = DB.from(&quot;user&quot;);</code></pre>
<h2>Retrieving a Single Object</h2>
<h3>Using a Primary Key</h3>
<p>The <a href="./patio_Model.html#.findById">findById</a> is the easiest method to use to find a model instance by its primary key value:

</p>
<pre class='prettyprint linenums lang-js'><code>// Find user with primary key (id) 1
User.findById(1).then(function(user){
    // SELECT * FROM user WHERE id = 1
}, errorHandler);</code></pre>
<p><strong>Note</strong> If there is no record with the given primary key, the promise will resolve with null.

</p>
<h3><a href="./patio_Dataset.html#first">first</a></h3>
<p>If you just want the first record in the dataset use <a href="./patio_Dataset.html#first">first</a>.

</p>
<pre class='prettyprint linenums lang-js'><code>User.first().then(function(user){
    // SELECT * FROM user LIMIT 1
}, errorHandler);</code></pre>
<p>Any options you pass to first will be used as a filter:

</p>
<pre class='prettyprint linenums lang-js'><code>User.first({name : &#39;Bob&#39;}).then(function(bob){
    // SELECT * FROM user WHERE (name = &#39;Bob&#39;) LIMIT 1
}, errorHandler);
var sql = patio.sql;
User.first(sql.name.like(&#39;B%&#39;)).then(function(user){
    // SELECT * FROM user WHERE (name LIKE &#39;B%&#39;) LIMIT 1
}, errorHandler);</code></pre>
<h3><a href="./patio_Dataset.html#last">last</a></h3>
<p>If you want the last record in the dataset use <a href="./patio_Dataset.html#last">last</a>.

</p>
<p><strong>Note:</strong> last will throws an Error if there is no order on the dataset. Because otherwise it would provide the same record as first, and most users would find that confusing.

</p>
<p><strong>Note:</strong> that last is not necessarily going to give you the last record in the dataset unless you give the dataset an unambiguous order.

</p>
<pre class='prettyprint linenums lang-js'><code> User.order(&quot;name&quot;).last().then(function(user){
     // SELECT * FROM user ORDER BY name DESC LIMIT 1
}, errorHandler);</code></pre>
<h3><a href="./patio_Dataset.html#get">get</a></h3>
<p>Sometimes, instead of wanting an entire row, you only want the value of a specific column. For this <a href="./patio_Dataset.html#get">get</a> is the method you want:

</p>
<pre class='prettyprint linenums lang-js'><code>User.get(&quot;name&quot;).then(function(name){
    // SELECT name FROM user LIMIT 1
}, errorHandler);</code></pre>
<h2>Reading Multiple Records</h2>
<h3><a href="./patio_Dataset.html#all">all</a></h3>
<p>If you want an array of all of the rows associated with the dataset you should use the <a href="./patio_Dataset.html#all">all</a> method:

</p>
<pre class='prettyprint linenums lang-js'><code>User.all().then(function(users){
    // SELECT * FROM user
}, errorHandlers);</code></pre>
<h3>Array methods</h3>
<p><a href="./patio_Dataset.html">patio.Dataset</a> has a few array like methods such as

</p>
<ul>
<li><a href="./patio_Dataset.html#forEach">forEach</a></li>
<li><a href="./patio_Dataset.html#map">map</a></li>
</ul>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user
User.forEach(function(user){
    console.log(user.name);
});</code></pre>
<p>If you return a promise from forEach then the promise from forEach will not resolve until each promise has resolved.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user
var forEachPromise = User.forEach(function(user){
    if(user.isVerified){
        return user.update({isVerified : false});
    }
}).then(function(){
    //all user updated
}, errorHandler);</code></pre>
<p><a href="./patio_Dataset.html#map">map</a>  is like <a href="./patio_Dataset.html#forEach">forEach</a> except that whatever is returning from the block is what the promise is resolved with, as opposed to forEach which always resolves with the original 
rows.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user
User.map(function(user){
    return user.name;
}).then(function(userNames){
    console.log(userNames);
}, errorHandler);</code></pre>
<p>If you return a promise from the mapping function then the promise from map will not resolve until each promise has resolved.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user
var mapPromise = User.map(function(user){
    return Blogs.filter({userId : userId}).map(function(blog){
          return blog.title;
    });
}).then(function(userBlogTitles){
    userBlogTitles.forEach(function(blogTitles){
        console.log(blogTitles);
    });
}, errorHandler);</code></pre>
<p><a href="./patio_Dataset.html#map">map</a> method also can take an arugment other than a function this is useful if you just want to select a list of column values.

</p>
<pre class='prettyprint linenums lang-js'><code>User.map(&quot;name&quot;).then(function(userNames){
    // SELECT * FROM user
}, errorHandler);</code></pre>
<h3><a href="./patio_Dataset.html#selectMap">selectMap</a></h3>
<pre class='prettyprint linenums lang-js'><code>User.selectMap(&quot;name&quot;).then(function(names){
    // SELECT name FROM user
}, errorHandler);</code></pre>
<h3><a href="./patio_Dataset.html#selectOrderMap">selectOrderMap</a></h3>
<pre class='prettyprint linenums lang-js'><code>User.selectOrderMap(&quot;name&quot;).then(function(){
    // SELECT name FROM user ORDER BY name
}, errorHandler);</code></pre>
<h3><a href="./patio_Dataset.html#toHash">toHash</a></h3>
<p>patio makes it easy to take an SQL query and return it as a plain object, using the <a href="./patio_Dataset.html">toHash</a> method:

</p>
<pre class='prettyprint linenums lang-js'><code>User.toHash(&quot;name&quot;, &quot;id&quot;).then(function(nameIdMap){
    // SELECT * FROM user
    //{&quot;Bob Yukon&quot;:1,&quot;Suzy Yukon&quot;:2}
}, errorHandler);</code></pre>
<p>The <a href="./patio_Dataset.html#toHash">toHash</a> method uses the first column as the key and the second column as the value. So if you swap the two arguments the hash will have its keys and values transposed:

</p>
<pre class='prettyprint linenums lang-js'><code>User.toHash(&quot;id&quot;, &quot;name&quot;).then(function(nameIdMap){
    // SELECT * FROM user
    //{&quot;1&quot;:&quot;Bob Yukon&quot;,&quot;2&quot;:&quot;Suzy Yukon&quot;}
}, errorHandler);</code></pre>
<p>If you provide only one argument to <a href="./patio_Dataset.html#toHash">toHash</a>, it uses the entire object or model object as the value:

</p>
<pre class='prettyprint linenums lang-js'><code>Users.toHash(&quot;name&quot;).then(function(){
    // SELECT * FROM user
    //{&quot;Bob Yukon&quot;:{&quot;name&quot;:&quot;Bob Yukon&quot;},&quot;Suzy Yukon&quot;:{&quot;name&quot;:&quot;Suzy Yukon&quot;}}
}):</code></pre>
<h3><a href="./patio_Dataset.html#selectHash">selectHash</a></h3>
<p><strong>Note</strong>: <a href="./patio_Dataset.html#toHash">toHash</a> selects all columns. However, <a href="./patio_Dataset.html#selectHash">selectHash</a> will only select the columns specified.

</p>
<pre class='prettyprint linenums lang-js'><code>User.selectHash(&quot;name&quot;, &quot;id&quot;).then(function(){
    // SELECT name, id FROM user
    //{bob : 1, suzy : 2}
});</code></pre>
<h1>Filtering</h1>
<h2><a href="./patio_Dataset.html#filter">filter</a></h2>
<p>The <a href="./patio_Dataset.html#filter">filter</a> method is one of the most used methods when querying a dataset. The filter method similar to <a href="./patio_Dataset.html#where">where</a> except that it will apply the filter to the WHERE or HAVING clause depending on if a HAVING clause should be used.


</p>
<h3>Filtering With Objects</h3>
<p>The most common format for providing filters is via an object. In general, patio treats conditions specified with an object as equality or inclusion. What type of condition is used depends on the values in the object.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE id = 1
User.filter({id : 1})

// SELECT * FROM user WHERE name = &#39;bob&#39; 
User.filter({name : &#39;bob&#39;})</code></pre>
<p>For arrays, patio uses the IN operator.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE id IN (1, 2)
User.filter({id : [1, 2]})</code></pre>
<p>For datasets, patio uses the IN operator with a subselect:

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE id IN (SELECT user_id FROM blog);
User.filter({id : Blog.select(&quot;userId&quot;)});</code></pre>
<p>For boolean values such as null, true, and false, patio uses the IS operator:

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE name IS NULL
User.filter({name : null})</code></pre>
<p>For RegExp, patio uses an SQL regular expression. Note that this is probably only supported onPostgreSQL and MySQL.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE name ~ &#39;Bo$&#39;
User.filter({name : /Bo$/});</code></pre>
<p>If there are multiple arguments in the hash, the filters are <code>AND</code>ed together:

</p>
<pre class='prettyprint linenums lang-js'><code>//SELECT * FROM user WHERE id IN (1, 2, 3) AND name ~ &#39;Bo$&#39;
 User.filter({id : [1,2,3], name : /Bo$/});</code></pre>
<p>This works the same as if you used two separate filter calls:

</p>
<pre class='prettyprint linenums lang-js'><code> // SELECT * FROM user WHERE id IN (1, 2, 3) AND name ~ &#39;Bo$&#39;
 User.filter({id : [1,2,3]}).filter({name : /Bo$/});</code></pre>
<p>If you nest hashes for a top level key then each condition will be applied to the key. This can often be used inplace of a filter block.

</p>
<pre class='prettyprint linenums lang-js'><code> // SELECT * FROM user WHERE ((name ~ &#39;ob$&#39;) AND (name &gt;= &#39;A&#39;) AND (name &lt;= &#39;Z&#39;))
 User.filter({name : {like : /ob$/, between : [&quot;A&quot;, &quot;Z&quot;]}});

  // SELECT * FROM user WHERE ((name ~ &#39;ob$&#39;) AND (name &gt;= &#39;A&#39;) AND (name &lt;= &#39;Z&#39;))
 User.filter(function(){
    this.name.like(/ob$/).and(this.name.between(&quot;A&quot;, &quot;Z&quot;));
 });</code></pre>
<h3>Array of Two Element Arrays</h3>
<p>If you use an array of two element arrays, it is treated as an Object. The only advantage to using an array of two element arrays is that it allows you to use values other than strings for keys, so you can do:

</p>
<pre class='prettyprint linenums lang-js'><code> // SELECT * FROM user WHERE name ~ &#39;oB$&#39; AND name ~ &#39;^Bo&#39;
 User.filter([[&quot;name&quot;, /oB$/], [sql.name, /^Bo/]]);</code></pre>
<h3>Filter Blocks</h3>
<p>Functions can also be provided to the filter method. Functions act as a &quot;virtual&quot; filter.   

</p>
<pre class='prettyprint linenums lang-js'><code> // SELECT * FROM user WHERE id &gt; 5
 User.filter(function(){
    return this.id.gt(5)
 });</code></pre>
<p>If you provde both regular arguments and a function the results will be ANDed together.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE name &gt;= &#39;K&#39; AND name &lt;= &#39;M&#39; AND id &gt; 5                
User.filter({name : {between : [&#39;K&#39;, &#39;M&#39;]}}, function(){
    return this.id.gt(5);
});</code></pre>
<h3>Strings</h3>
<p>If you have a Boolean column in the database you can provide just the column name.

</p>
<pre class='prettyprint linenums lang-js'><code> // SELECT * FROM user WHERE is_active
 User.filter(&quot;isActive&quot;);</code></pre>
<p><strong>Note:</strong> if you want the literal representation of string you must use the (literal)[./patio_sql.html#.literal] method.

</p>
<pre class='prettyprint linenums lang-js'><code> // SELECT * FROM user WHERE name &lt; &#39;A&#39;
 User.filter(sql.literal(&quot;name &lt; &#39;A&#39;&quot;));</code></pre>
<h3>Expressions</h3>
<p>patio SQL expressions are instances of subclasses of [Epression][./patio_sql_Expression.html].

</p>
<pre class='prettyprint linenums lang-js'><code>//SELECT * FROM user WHERE name LIKE &#39;B%&#39;
User.filter(sql.name.like(&#39;B%&#39;));</code></pre>
<p>In this case <a href="./patio_sql_StringExpression.html">patio.sql.StringExpression</a>.<a href="./patio_sql_StringExpression.html#like">like</a> returns a <a href="./patio_sql_BooleanExpression.html">patio.sql.BooleanExpression</a> object, which is used directly in the filter.

</p>
<p>You can use the sql methodMissing feature to create arbitrary complex expression.

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE name LIKE &#39;B%&#39; AND (b = 1 OR c != 3)
User.filter(sql.name.like(&#39;B%&#39;).and(sql.b.eq(1).or(sql.c.neq(3))));</code></pre>
<p>You can combine these expression operators with functions:

</p>
<pre class='prettyprint linenums lang-js'><code>// SELECT * FROM user WHERE ((a &lt;= 1) OR NOT b(c) OR NOT d)
User.filter(function(){
    return this.a.gt(1).and(this.b(&quot;c&quot;).and(this.d)).not();
});
``

###Strings with Placeholders

patio also supports place holder strings.</code></pre>
<p>// SELECT * FROM user WHERE name LIKE &#39;B%&#39;
User.filter(&quot;name LIKE ?&quot;, &#39;B%&#39;)

</p>
<pre class='prettyprint linenums lang-js'><code>
This is the most common type of placeholder, where each question mark is substituted with the corresponding argument.</code></pre>
<p>// SELECT * FROM user WHERE name LIKE &#39;B%&#39; AND id = 1
User.filter(&quot;name LIKE ? AND id = ?&quot;, &#39;B%&#39;, 1)
</p>
<pre class='prettyprint linenums lang-js'><code>
You can also use named placeholders with an object, where the named placeholders use `{}` that contain the placeholder key name</code></pre>
<p>//SELECT * FROM user WHERE name LIKE &#39;B%&#39; AND id = 1
User.filter(&quot;name LIKE {name} AND id = {id}&quot;, {name : &#39;B%&#39;, id : 1});
</p>
<pre class='prettyprint linenums lang-js'><code>
###Literal Strings

You can also provide a literal string using the [literal](./patio_sql.html#.literal)</code></pre>
<p>// SELECT * FROM user WHERE id = 2
User.filter(sql.literal(&quot;id = 2&quot;))
</p>
<pre class='prettyprint linenums lang-js'><code>
However, if you are using any untrusted input, you should use placeholders. In general, unless you are hardcoding values in the strings, you should use placeholders. You should never pass a string that has been built using concatenation becuase it can lead to SQL injection.</code></pre>
<p>//id is some user input

</p>
<p> User.filter(&quot;id = &quot; + id) //id could be anything so dont do it!
 User.filter(&quot;id = ?&quot;, id) //Do this as patio will escape it
 User.filter({ id : id}) // Best solution!
</p>
<pre class='prettyprint linenums lang-js'><code>
###Inverting filters               

You can use the [invert](.patio_Dataset.html#invert) method.</code></pre>
<p>// SELECT * FROM user WHERE id != 5
User.filter({id : 5}).invert(); 

</p>
<p>//OR

</p>
<p> // SELECT * FROM user WHERE id != 5
User.filter({id : {neq : 5}});
</p>
<pre class='prettyprint linenums lang-js'><code>
**NOTE:** the [invert](./patio_Dataset.html#invert) method inverts the entire filter!</code></pre>
<p>// SELECT * FROM user WHERE id != 5 OR name &lt;= &#39;A&#39;
 User.filter({id : 5}).filter(function(){ 
    return this.name.gt(&#39;A&#39;);
}).invert();
</p>
<pre class='prettyprint linenums lang-js'><code>
###Excluding filters
You can use [exclude](./patio_Dataset.html#exclude) to invert only specific filters:</code></pre>
<p>// SELECT * FROM user WHERE id != 5
User.exclude({id : 5});

</p>
<p>// SELECT * FROM user WHERE id = 5 OR name &lt;= &#39;A&#39; 
User.filter({id : 5}).exclude(function(){ 
    return this.name.gt(&#39;A&#39;)
});
</p>
<pre class='prettyprint linenums lang-js'><code>
So to do a NOT IN with an array:</code></pre>
<p>// SELECT * FROM user WHERE id NOT IN (1, 2)
User.exclude({id : [1, 2]});
</p>
<pre class='prettyprint linenums lang-js'><code>Or to use the NOT LIKE operator:</code></pre>
<p>// SELECT * FROM user WHERE name NOT LIKE &#39;%o%&#39;
User.exclude(sql.name.like(&#39;%o%&#39;)) 
</p>
<pre class='prettyprint linenums lang-js'><code>
###Removing

To remove all existing filters, use the [unfiltered](./patio_Dataset.html#unfiltered) method:</code></pre>
<p> // SELECT * FROM user
 User.filter({id : 1}).unfiltered();
</p>
<pre class='prettyprint linenums lang-js'><code>
##Ordering

To add order to an SQL statement use the [order](./patio_Dataset.html#order) method.</code></pre>
<p> // SELECT * FROM user ORDER BY id
 User.order(&quot;id&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>
You can also provide multiple columns to the order method.</code></pre>
<p> // SELECT * FROM album ORDER BY user_id, id
 User.order(&quot;userId&quot;, &quot;id&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>**Note:** order replaces any existing order</code></pre>
<p> User.order(&quot;id&quot;).order(&quot;name&quot;);
 // SELECT * FROM user ORDER BY name
</p>
<pre class='prettyprint linenums lang-js'><code>
If you want to append a column to the existing order use the [orderAppend](./patio_Dataset.html#orderAppend) method.</code></pre>
<p> // SELECT * FROM user ORDER BY id, name
 User.order(&quot;id&quot;).orderAppend(&quot;name&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>
If you want to prepend a column to the existing order use the [orderPrepend](./patio_Dataset.html#orderPrepend) method.</code></pre>
<p> User.order(&quot;id&quot;).orderPrepend(&quot;name&quot;);
 // SELECT * FROM user ORDER BY name, id
</p>
<pre class='prettyprint linenums lang-js'><code>
###Reversing                

To reverse the order of a SQL query use the [reverse](./patio_Dataset.html#reverse) method.</code></pre>
<p> // SELECT FROM user ORDER BY id DESC
 User.order(&quot;id&quot;).reverse();
</p>
<pre class='prettyprint linenums lang-js'><code>
You can also use the [desc](./patio_sql_OrderedMethods.html#desc) method.</code></pre>
<p> // SELECT FROM user ORDER BY id DESC
 User.order(sql.id.desc());
</p>
<pre class='prettyprint linenums lang-js'><code>
This allows for finer grained control of the ordering of columns.</code></pre>
<p> // SELECT FROM user ORDER BY name, id DESC
 User.order(&quot;name&quot;, sql.id.desc());
</p>
<pre class='prettyprint linenums lang-js'><code>
###Removing

To remove ordering use the [unordered](./patio_Dataset.html#unordered) method:</code></pre>
<p> User.order(&quot;name&quot;).unordered();
 // SELECT * FROM user
</p>
<pre class='prettyprint linenums lang-js'><code>
##Selecting columns

To only return certain columns use the [select](./patio_Dataset.html#select) method.</code></pre>
<p>// SELECT id, name FROM user
User.select(&quot;id&quot;, &quot;name&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>
**NOTE:** If you are dealing with Model objects, you&#39;ll want to include the primary key if you want to update or remove the object. You&#39;ll also want to include any keys (primary or foreign) related to associations you plan to use.

**NOTE:** If a column is not selected, and you attempt to access it, you will get null:</code></pre>
<p>// SELECT name FROM user LIMIT 1<br>User.select(&quot;name&quot;).first().then(function(user){
    //user.id === null<br>});
</p>
<pre class='prettyprint linenums lang-js'><code>
select replaces any columns previously selected.</code></pre>
<p> User.select(&quot;id&quot;).select(&quot;name&quot;);
 // SELECT name FROM user
</p>
<pre class='prettyprint linenums lang-js'><code>
Like order you can use the [selectAppend](./patio_Dataset.html#selectAppend) method to append columns to be returned.</code></pre>
<p>// SELECT id, name FROM user
User.select(&quot;id&quot;).selectAppend(&quot;name&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>
To remove selected columns and revert to `SELECT *` use the [selectAll](./patio_Dataset.html#selectAll) method.</code></pre>
<p> User.select(&quot;id&quot;).selectAll();
 // SELECT * FROM user
</p>
<pre class='prettyprint linenums lang-js'><code>
##Distinct

To add a `DISTINCT` clause to filter out duplicate rows use the [distinct](./patio_Dataset.html#distinct) method.

**Note:** `DISTINCT` is separate from the select clause,</code></pre>
<p>// SELECT DISTINCT name FROM user
User.distinct().select(&quot;name&quot;)
</p>
<pre class='prettyprint linenums lang-js'><code>
##Limit and Offset

To limit the number of rows returned use the [limit](./patio_Dataset.html#limit) method.</code></pre>
<p>//SELECT * FROM user LIMIT 5
User.limit(5);
</p>
<pre class='prettyprint linenums lang-js'><code>
To provide an offset you can provide limit with a second argument.

The following would return the 11th through 15th records in the original dataset.</code></pre>
<p>// SELECT * FROM user LIMIT 5 OFFSET 10
 User.limit(5, 10);
</p>
<pre class='prettyprint linenums lang-js'><code>
To remove the LIMIT and OFFSET clause use the [unlimited](./patio_Dataset.html#unlimited) method.</code></pre>
<p> // SELECT * FROM user
 User.limit(5, 10).unlimited();
</p>
<pre class='prettyprint linenums lang-js'><code>

##Grouping

The GROUP clause is used to results based on the values of a given group of columns. To provide grouping use the [group](./patio_Dataset.html#group) method:</code></pre>
<p> // SELECT * FROM user GROUP BY user_id
 User.group(&quot;userId&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>
You can remove an existing grouping use the [ungrouped](./patio_Dataset.html#ungrouped) method:</code></pre>
<p> User.group(&quot;userId&quot;).ungrouped();
 // SELECT * FROM user
</p>
<pre class='prettyprint linenums lang-js'><code>
A common use of grouping is to count based on the number of grouped rows, so patio provides a [groupAndCount](./patio_Dataset.html#groupAndCount) method.</code></pre>
<p>// SELECT user_id, COUNT(*) AS count FROM user GROUP BY user_id
 User.groupAndCount(&quot;userId&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>
##Having

The HAVING clause filters the results after the grouping has been applied, instead of before.</code></pre>
<p> // SELECT user_id, COUNT(*) AS count FROM user GROUP BY user_id HAVING count &gt;= 10
 User.groupAndCount(&quot;dateOfBirth&quot;).having({count : {gte : 10}});

</p>
<pre class='prettyprint linenums lang-js'><code>
If you have a HAVING clause then filter will apply the filter to the HAVING clause.</code></pre>
<p> // SELECT user_id, COUNT(*) AS count FROM user GROUP BY user_id HAVING count &gt;= 10 AND count &lt; 15
 User.groupAndCount(&quot;dateOfBirth&quot;).having({count : {gte : 10}}).filter({count : {lt : 15}});
</p>
<pre class='prettyprint linenums lang-js'><code>
##Where                

Unlike filter, the where method will always affect the WHERE clause:</code></pre>
<p>// SELECT user_id, COUNT(*) AS count FROM user WHERE name LIKE &#39;A%&#39; GROUP BY id HAVING count &gt;= 10
 User.groupAndCount(&quot;id&quot;).having({count : {gte : 10}}).where({name  : {like : &#39;A%&#39;}});
</p>
<pre class='prettyprint linenums lang-js'><code>
Both the WHERE clause and the HAVING clause can be removed by using the unfiltered method:</code></pre>
<p>// SELECT user_id, COUNT(*) AS count FROM user GROUP BY user_id
User.groupAndCount(&quot;id&quot;).having({count : {gte : 10}}).where({name  : {like : &#39;A%&#39;}}).unfiltered();
</p>
<pre class='prettyprint linenums lang-js'><code>
##Joins

To join a dataset to another table or dataset. The underlying method used is [joinTable](./patio_Dataset.html#joinTable):</code></pre>
<p>// SELECT * FROM user INNER JOIN user ON blog.user_id = user.id
User.joinTable(&quot;inner&quot;, &quot;blog&quot;, {userId : sql.id});
</p>
<pre class='prettyprint linenums lang-js'><code>**Note:** unlike other querying methods when specifying the join condition you must specify the value as a [sql.Identifier](./patio_sql.html#.identifier) if it is a column otherwise it will be assumed to be a literal value.</code></pre>
<p>// SELECT * FROM user INNER JOIN blog ON blog.user_id = user.id
User.joinTable(&quot;inner&quot;, &quot;blog&quot;, {userId : sql.id});

</p>
<p>// SELECT * FROM user INNER JOIN blog ON blog.userId = &#39;id&#39;
User.joinTable(&quot;inner&quot;, &quot;blog&quot;, {userId : &quot;id&quot;});
</p>
<pre class='prettyprint linenums lang-js'><code>
joinTable is not typically used directly, but instead by named join methods:</code></pre>
<p>// SELECT * FROM user INNER JOIN blog ON blog.user_id = user.id
 User.join(&quot;blog&quot;, {userId : sql.id});

</p>
<p> // SELECT * FROM user LEFT JOIN blog ON blog.user_id = user.id
 User.leftJoin(&quot;blog&quot;, {userId: sql.id});
</p>
<pre class='prettyprint linenums lang-js'><code>

###Table/Dataset to Join

For the join methods, the first argument is generally the name of the table to which you are joining. However, you can also provide a

* model class:</code></pre>
<p> User.join(Blog, {userId : sql.id});
</p>
<pre class='prettyprint linenums lang-js'><code>
* dataset, in which case a subselect is used:</code></pre>
<p> //SELECT <em> FROM user INNER JOIN (SELECT </em> FROM blog WHERE (title &lt; &#39;A&#39;)) AS t1 ON (t1.user_id = user.id)
 User.join(Blog.filter({title : {lt : &#39;A&#39;}}), {userId : sql.id});
</p>
<pre class='prettyprint linenums lang-js'><code>
###Join Conditions

The second argument to the specialized join methods is the conditions to use when joining, which is similar to a filter expression, with a few minor exceptions.


**Implicit Qualification**

An object used as the join conditions operates similarly to a filter, except that keys are automatically qualified with the table from the first argument, and unqualified values, that are sql.Identifiers, are automatically qualified with the first table or the last table joined. 

**Note:** both the id key and the userId value are qualified.</code></pre>
<p> //SELECT * FROM user INNER JOIN blog ON (blog.userId = user.id)
 User.join(&quot;blog&quot;, {userId : sql.id});
</p>
<pre class='prettyprint linenums lang-js'><code>

Because patio uses the last joined table for implicit qualifications of values, you can do things like:</code></pre>
<p> //SELECT * FROM user
 //    INNER JOIN blog ON (blog.user_id = user.id)
 //    INNER JOIN posts ON (posts.blog_id = blog.id)


</p>
<p> User.join(&quot;blog&quot;, {userId : sql.id}).join(&quot;posts&quot;, {blogId : sql.id});
</p>
<pre class='prettyprint linenums lang-js'><code>**Note** blogId is qualified with posts and id is qualified with blog.


Implicit qualification is not always correct:</code></pre>
<p>// SELECT * FROM user INNER JOIN blog ON (blog.user_id = user.id) INNER JOIN posts ON (posts.user_id = blog.id)
User.join(&quot;blog&quot;, {userId : sql.id}).join(&quot;posts&quot;, {userId : sql.id});
</p>
<pre class='prettyprint linenums lang-js'><code>id is qualified with blog instead of user. This is wrong as the foreign key posts.user_id refers to user.id, not blog.id. To fix this, you need to explicitly qualify when joining:</code></pre>
<p>//SELECT * FROM user
//  INNER JOIN blog ON (blog.user_id = user.id)
//  INNER JOIN posts ON (posts.user_id = user.id)


</p>
<p>User.join(&quot;blog&quot;, {userId : sql.id}).join(&quot;posts&quot;, {userId : sql.id.qualify(&quot;user&quot;)});

</p>
<p>//OR

</p>
<p>User.join(&quot;blog&quot;, {userId : sql.id}).join(&quot;posts&quot;, {userId : sql.user__id}).sql

</p>
<pre class='prettyprint linenums lang-js'><code>
Just like the dataset filter method the join expression can be an array of two element arrays.</code></pre>
<p>// SELECT * FROM user
//     INNER JOIN blog ON ((blog.user_id = user.id) AND (blog.id &gt;= 1) AND (blog.id &lt;= 5))

</p>
<p>User.join(&quot;blog&quot;, [[sql.userId, sql.id], [sql.id, {between : [1, 5]}]]).sql

</p>
<pre class='prettyprint linenums lang-js'><code>
###USING Joins

JOIN ON is the most common type of join condition, however USING is also another valid SQL join expr that patio supports.

JOIN USING is useful when the columns you are using have the same names in both tables.</code></pre>
<p>// SELECT * FROM user INNER JOIN blog USING (user_id)
 User.join(&quot;blog&quot;, [sql.userId])
</p>
<pre class='prettyprint linenums lang-js'><code>
###NATURAL Joins

NATURAL Joins assume that all columns with the same names used for joining, so you do not need to use a join expression.</code></pre>
<p>// SELECT * FROM user NATURAL JOIN blog
 User.naturalJoin(&quot;blog&quot;);
</p>
<pre class='prettyprint linenums lang-js'><code>
###Join Blocks

The block should accept 3 arguments, the table alias for the table currently being joined, the table alias for the last table joined (or first table), and an array of previous [patio.sql.JoinClause](./patio_sql_JoinClause.html)s.


This allows you to qualify columns similar to how the implicit qualification works, without worrying about the specific aliases being used. For example, if you wanted to join the user and blog tables, but only want user where the user&#39;s name comes before the blog&#39;s title.</code></pre>
<p> //SELECT * FROM user INNER JOIN blog
 //     ON ((blog.user_id = user.id) AND (user.name &lt; blog.title))
 User.join(&quot;blog&quot;, {userId : sql.id}, function(currAlias, lastAlias, previousJoins){
            return sql.name.qualify(lastAlias).lt(sql.title.qualify(currAlias));
        })
</p>
<pre class='prettyprint linenums lang-js'><code>
or you could do this which is the same thing:</code></pre>
<p> User.join(&quot;blog&quot;, {userId : sql.id, title : {gt : sql.name.qualify(&quot;user&quot;)}});
//SELECT * FROM user INNER JOIN blog
//      ON ((blog.user_id = user.id) AND (blog.title &gt; user.name))
</p>
<pre class='prettyprint linenums lang-js'><code>
##From

The FROM table is typically the first clause populated when creating a dataset. For a standard [patio.Model](./patio_Model.html), the dataset already has the FROM clause populated, and the most common way to create datasets is with the Database from method.</code></pre>
<p>DB.from(&quot;user&quot;);
// SELECT * FROM user
</p>
<pre class='prettyprint linenums lang-js'><code>
However, you can also use the from method on the Dataset.</code></pre>
<p> User.from(&quot;user&quot;, &quot;oldUser&quot;);
 // SELECT * FROM user, old_user

</p>
<p>//Using from again will remove the previous FROM clause.
DB.from(&quot;user&quot;).from(&quot;oldUser&quot;);
 // SELECT * FROM old_user
</p>
<pre class='prettyprint linenums lang-js'><code>
**Note:** multiple tables in the FROM clause use a cross join by default, so the number of rows will be number of user times the number of old user.


##Subselects

If you want to perform a subselect you can use the [fromSelf](./patio_Dataset.html#fromSelf) method.</code></pre>
<p> Blog.order(&quot;userId&quot;).limit(100).fromSelf().group(&quot;userId&quot;);
 //SELECT <em> FROM (SELECT </em> FROM user ORDER BY user_id LIMIT 100) AS t1 GROUP BY user_id
</p>
<pre class='prettyprint linenums lang-js'><code>
If you did not use the `fromSelf` method the query would be:</code></pre>
<p> // SELECT * FROM user GROUP BY user_id ORDER BY user_id LIMIT 100
 Blog.order(&quot;userId&quot;).limit(100).group(&quot;userId&quot;)
</p>
<pre class='prettyprint linenums lang-js'><code>
Without fromSelf, you are doing the grouping, and limiting the number of grouped records returned to 100. So assuming you have blogs written by more than 100 user, you&#39;ll end up with 100 results.


With fromSelf, you are limiting the number of records before grouping. So if the user with the lowest id had 100 blogs, you&#39;d get 1 result, not 100.

##Locking for Update

patio allows you to easily add a FOR UPDATE clause to your queries so that the records returned can&#39;t be modified by another query until the current transaction commits. You just use the [forUpdate](./patio_Dataset.html#forUpdate) method:</code></pre>
<p> DB.transaction(function(){
    var ret = new comb.Promise();
    User.forUpdate().first({id : 1}).then(function(){
        // SELECT * FROM user WHERE id = 1 FOR UPDATE
        user.password = null;
        user.save().then(ret);
    }, ret);
    return ret;
 });
</p>
<pre class='prettyprint linenums lang-js'><code>
This will ensure that no other connection modifies the row between when you select it and when the transaction ends.

##Custom SQL

patio makes it easy to use custom SQL by providing the [fetch][./patio_Database.html#fetch] method.</code></pre>
<p> // SELECT <em> FROM user
 DB.fetch(&quot;SELECT </em> FROM user&quot;)
</p>
<pre class='prettyprint linenums lang-js'><code>
You can also use the withSql dataset method.</code></pre>
<p> DB.from(&quot;user&quot;).withSql(&quot;SELECT <em> FROM user&quot;);
 // SELECT </em> FROM user
</p>
<pre class='prettyprint linenums lang-js'><code>
You can also use placeholders:</code></pre>
<p> // SELECT <em> FROM user WHERE id = 5
 DB.fetch(&quot;SELECT </em> FROM user WHERE id = ?&quot;, 5);

</p>
<p> // SELECT <em> FROM user WHERE id = 5
 DB.from(&quot;user&quot;).withSql(&quot;SELECT </em> FROM user WHERE id = {id}&quot;, {id : 5});
</p>
<pre class='prettyprint linenums lang-js'><code>
##Checking for Records

To test if there are any records in the database use the isEmpty method</code></pre>
<p> User.isEmpty().then(function(isEmpty){
    // SELECT 1 FROM user LIMIT 1
 }, errorHandler);
 User.filter({id : 0}).isEmpty().then(function(isEmpty){
    // SELECT 1 FROM user WHERE id = 0 LIMIT 1
 },errorHandler);
 User.filter(sql.name.like(&#39;B%&#39;)).isEmpty().then(function(isEmpty){
    // SELECT 1 FROM user WHERE name LIKE &#39;B%&#39; LIMIT 1
 },errorHandler);

</p>
<pre class='prettyprint linenums lang-js'><code>##Aggregate Calculations

There are dataset methods for each of the following aggregate calculations:

* [count](./patio_Dataset.html#count) : count just returns the number of records in the dataset.</code></pre>
<p> User.count().then(function(count){
    // SELECT COUNT(*) AS count FROM user LIMIT 1
 });
</p>
<pre class='prettyprint linenums lang-js'><code>
* [sum](./patio_Dataset.html#sum) : makes a sum aggregate function call for the column.</code></pre>
<p> User.sum(&quot;id&quot;).then(function(){
    // SELECT sum(id) FROM user LIMIT 1
 });

</p>
<pre class='prettyprint linenums lang-js'><code>
* [avg](./patio_Dataset.html#avg): makes a avg aggregate function call for the column.</code></pre>
<p> User.avg(&quot;id&quot;).then(function(){
    // SELECT avg(id) FROM user LIMIT 1
 });
</p>
<pre class='prettyprint linenums lang-js'><code>
* [min](./patio_Dataset.html#min) : makes a min aggregate function call for the column.</code></pre>
<p> User.min(&quot;id&quot;).then(function(){
    // SELECT sum(id) FROM user LIMIT 1
 });
</p>
<pre class='prettyprint linenums lang-js'><code>
* [max](./patio_Dataset.html#max): makes a max aggregate function call for the column.</code></pre>
<p> User.max(&quot;id&quot;).then(function(){
    // SELECT sum(id) FROM user LIMIT 1
 });
```</p>

<hr>

Documentation generated using <a href="https://github.com/doug-martin/coddoc">coddoc</a>.


</div>
</div>
<script type="text/javascript" src="./assets/js/jquery.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap.min.js"></script>
<script type="text/javascript" src="./assets/js/prettify.js"></script>

</body>
</html>
