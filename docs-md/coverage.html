<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Test Coverage</title>
<style type="text/css">

body {
    margin: 10px;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 14px;
    line-height: 20px;
    color: #333333;
    background-color: #ffffff;
}

ol {
    padding: 0px;
}

pre.prettyprint {
    margin-bottom: 20px;
}

pre {
    display: block;
    padding: 9.5px;
    margin: 0 0 10px;
    font-size: 13px;
    line-height: 10px;
    word-break: break-all;
    word-wrap: break-word;
    white-space: pre;
    white-space: pre-wrap;
    background-color: whiteSmoke;
    border: 1px solid #CCC;
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
}

code, pre {
    padding: 0 3px 2px;
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    font-size: 12px;
    color: #333;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}

.prettyprint {
    padding: 8px;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8
}

.prettyprint.linenums {
    -webkit-box-shadow: inset 40px 0 0 #fbfbfc, inset 81px 0 0 #ececf0;
    -moz-box-shadow: inset 40px 0 0 #fbfbfc, inset 81px 0 0 #ececf0;
    box-shadow: inset 40px 0 0 #fbfbfc, inset 81px 0 0 #ececf0
}

ol.linenums {
    margin: 0 0 0 40px
}

ol.linenums li {
    padding-bottom: 2px;
    padding-top: 2px;
    vertical-align: middle;
    color: #bebec5;
    line-height: 0px;
    text-shadow: 0 1px 0 #fff
}

ol.linenums li span {
    padding-right: 40px !important;
    width: 30px;
    display: inline-block;
    text-align: right;
}

pre code {
    padding: 0;
    color: inherit;
    background-color: transparent;
    border: 0;
}

ol li.red {
    background-color: lightCoral;
    color: black;
    text-shadow: none;
    line-height: 5px;
}

.prettyprint li span.hits {
    padding: 5px 0 5px;
    color: #26ca4f;
}

.prettyprint li span.nohits {
    padding: 5px 0 5px;
}

h2 {
    font-size: 30px;
    line-height: 40px;
}

h1, h2, h3, h4, h5, h6 {
    margin: 10px 0;
    font-family: inherit;
    font-weight: bold;
    line-height: 1;
    color: inherit;
    text-rendering: optimizelegibility;
}

hr {
    margin: 20px 0;
    border: 0;
    border-top: 1px solid #EEE;
    border-bottom: 1px solid white;
}

.table-bordered {
    border: 1px solid #DDD;
    border-collapse: separate;
    border-left: 0;
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
}

.table {
    width: 325px;
    margin-bottom: 20px;
}

table {
    max-width: 100%;
    background-color: transparent;
    border-collapse: collapse;
    border-spacing: 0;
}

.table-striped tbody tr:nth-child(odd) td, .table-striped tbody tr:nth-child(odd) th {
    background-color: #F9F9F9;
}

.table-bordered th, .table-bordered td {
    border-left: 1px solid #DDD;
}

.table th, .table td {
    padding: 8px;
    line-height: 20px;
    text-align: left;
    vertical-align: top;
    border-top: 1px solid #DDD;
}

span.cov-label {
    font-weight: bold;
    width: 70px;
    display: inline-block;
    color: teal;
}

span.cov-value {
    width: 50px;
    display: inline-block;
    text-align: right;
    color: gray;
}

.cov-section-header {
    font-size: 16pt;
    font-weight: bold;
    color: darkOrange;
    padding: 10px;
}

.inline {
    display: inline-block;
    vertical-align: middle;
}

.cov-section {
    margin-right: auto;
    margin-left: auto;
    margin-bottom: 10px;
    padding: 10px;
    width: 80%;
}

.cov-section .source{
    display: none;
}

.cov-section-all .cov-section-header{
    color: #adff2f;
}

.cov-section-high .cov-section-header{
    color: #008080;
}

.cov-section-med .cov-section-header{
     color : #FFCC66;
}

.cov-section-low .cov-section-header{
    color: lightCoral;

}

.cov-section-hover {
    background-color: whiteSmoke;
    cursor: pointer;
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    border-radius: 10px;
}

.cov-section-hover:hover {
    -moz-box-shadow: 0px 0px 12px #707070;
    -webkit-box-shadow: 0px 0px 12px #707070;
    box-shadow: 0px 0px 12px #707070;

}

.section-table {
    width: 100%;
}

td.cov-stats {
    text-align: right;
}

.overview{
    color : #797979;
    font-size: 18pt;
}
</style>
</head>
<body>
<div class="cov-section">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header overview'>Overview</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>88.84</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>21807</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>5180</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>578</span>
                </div>
            </td>
        </tr>
    </table>
    <hr class="section">
</div>

<div class="cov-section cov-section-hover cov-section-low" id="database/schemaGenerators.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/schemaGenerators.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>70.83</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>650</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>96</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>28</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/schemaGenerators.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb-proxy"),</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isDefined = comb.isDefined,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    toArray = comb.array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    methodMissing = comb.methodMissing,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Generator = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.SchemaGenerator.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __primaryKey:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * An internal class that the user is not expected to instantiate directly.</code></li>
<li class='green'><span class=''> </span><code>         * Instances are created by {@link patio.Database#createTable}.</code></li>
<li class='green'><span class=''> </span><code>         * It is used to specify table creation parameters.  It takes a Database</code></li>
<li class='green'><span class=''> </span><code>         * object and a block of column/index/constraint specifications, and</code></li>
<li class='green'><span class=''> </span><code>         * gives the Database a table description, which the database uses to</code></li>
<li class='green'><span class=''> </span><code>         * create a table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.SchemaGenerator} has some methods but also includes method_missing,</code></li>
<li class='green'><span class=''> </span><code>         * allowing users to specify column type as a method instead of using</code></li>
<li class='green'><span class=''> </span><code>         * the column method, which makes for a cleaner code.</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *comb.executeInOrder(DB, function(DB){</code></li>
<li class='green'><span class=''> </span><code>         *       DB.createTable("airplane_type", function () {</code></li>
<li class='green'><span class=''> </span><code>         *          this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *          this.name(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>         *          this.max_seats(Number, {size:3, allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>         *          this.company(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>         *       });</code></li>
<li class='green'><span class=''> </span><code>         *      DB.createTable("airplane", function () {</code></li>
<li class='green'><span class=''> </span><code>         *          this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *          this.total_no_of_seats(Number, {size:3, allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>         *          this.foreignKey("typeId", "airplane_type", {key:"id"});</code></li>
<li class='green'><span class=''> </span><code>         *      });</code></li>
<li class='green'><span class=''> </span><code>         *      DB.createTable("flight_leg", function () {</code></li>
<li class='green'><span class=''> </span><code>         *          this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *          this.scheduled_departure_time("time");</code></li>
<li class='green'><span class=''> </span><code>         *          this.scheduled_arrival_time("time");</code></li>
<li class='green'><span class=''> </span><code>         *          this.foreignKey("departure_code", "airport", {key:"airport_code", type : String, size : 4});</code></li>
<li class='green'><span class=''> </span><code>         *          this.foreignKey("arrival_code", "airport", {key:"airport_code", type : String, size : 4});</code></li>
<li class='green'><span class=''> </span><code>         *          this.foreignKey("flight_id", "flight", {key:"id"});</code></li>
<li class='green'><span class=''> </span><code>         *      });</code></li>
<li class='green'><span class=''> </span><code>         *      DB.createTable("leg_instance", function () {</code></li>
<li class='green'><span class=''> </span><code>         *          this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *          this.date("date");</code></li>
<li class='green'><span class=''> </span><code>         *          this.arr_time("datetime");</code></li>
<li class='green'><span class=''> </span><code>         *          this.dep_time("datetime");</code></li>
<li class='green'><span class=''> </span><code>         *          this.foreignKey("airplane_id", "airplane", {key:"id"});</code></li>
<li class='green'><span class=''> </span><code>         *          this.foreignKey("flight_leg_id", "flight_leg", {key:"id"});</code></li>
<li class='green'><span class=''> </span><code>         *      });</code></li>
<li class='green'><span class=''> </span><code>         *});</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Database} the database this generator is for</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (db) {</code></li>
<li class='green'><span class='hits'>218</span><code>            this.db = db;</code></li>
<li class='green'><span class='hits'>218</span><code>            this.columns = [];</code></li>
<li class='green'><span class='hits'>218</span><code>            this.indexes = [];</code></li>
<li class='green'><span class='hits'>218</span><code>            this.constraints = [];</code></li>
<li class='green'><span class='hits'>218</span><code>            this.__primaryKey = null;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add an unnamed constraint to the DDL, specified by the given block</code></li>
<li class='green'><span class=''> </span><code>         * or args:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * db.createTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.check({num : {between : [1,5]}})</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; CHECK num &gt;= 1 AND num &lt;= 5</code></li>
<li class='green'><span class=''> </span><code>         *   this.check(function(){return this.num.gt(5);});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; CHECK num &gt; 5</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        check:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.constraint.apply(this, [null].concat(argsToArray(arguments)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a column with the given name, type, and opts to the DDL.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  DB.createTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      this.column("num", "integer");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; num INTEGER</code></li>
<li class='green'><span class=''> </span><code>         *      this.column('name", String, {allowNull : false, "default" : "a");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; name varchar(255) NOT NULL DEFAULT 'a'</code></li>
<li class='green'><span class=''> </span><code>         *      this.column("ip", "inet");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; ip inet</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * You can also create columns via method missing, so the following are</code></li>
<li class='green'><span class=''> </span><code>         * equivalent:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         * DB.createTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.column("number", "integer");</code></li>
<li class='green'><span class=''> </span><code>         *   this.number("integer");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the column</code></li>
<li class='green'><span class=''> </span><code>         * @param type the datatype of the column.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] additional options</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param [opts.default] The default value for the column.</code></li>
<li class='green'><span class=''> </span><code>         * @param [opts.deferrable] This ensure Referential Integrity will work even if</code></li>
<li class='green'><span class=''> </span><code>         *                reference table will use for its foreign key a value that does not</code></li>
<li class='green'><span class=''> </span><code>         *                exists(yet) on referenced table. Basically it adds</code></li>
<li class='green'><span class=''> </span><code>         *                DEFERRABLE INITIALLY DEFERRED on key creation.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.index]  Create an index on this column.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [key] For foreign key columns, the column in the associated table</code></li>
<li class='green'><span class=''> </span><code>         *         that this column references.  Unnecessary if this column references the primary key of the</code></li>
<li class='green'><span class=''> </span><code>         *         associated table.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.allowNull]  Mark the column as allowing NULL values (if true),</code></li>
<li class='green'><span class=''> </span><code>         *          or not allowing NULL values (if false).  If unspecified, will default</code></li>
<li class='green'><span class=''> </span><code>         *          to whatever the database default is.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.onDelete] Specify the behavior of this column when being deleted</code></li>
<li class='green'><span class=''> </span><code>         *               ("restrict", "cascade", "setNull", "setDefault", "noAction").</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.onUpdate] Specify the behavior of this column when being updated</code></li>
<li class='green'><span class=''> </span><code>         *               Valid options ("restrict", "cascade", "setNull", "setDefault", "noAction").</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.primaryKey] Make the column as a single primary key column.  This should only</code></li>
<li class='green'><span class=''> </span><code>         *                 be used if you have a single, non-autoincrementing primary key column.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number} [opts.size] The size of the column, generally used with string</code></li>
<li class='green'><span class=''> </span><code>         *          columns to specify the maximum number of characters the column will hold.</code></li>
<li class='green'><span class=''> </span><code>         *          An array of two integers can be provided to set the size and the</code></li>
<li class='green'><span class=''> </span><code>         *          precision, respectively, of decimal columns.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.unique] Mark the column as unique, generally has the same effect as</code></li>
<li class='green'><span class=''> </span><code>         *            creating a unique index on the column.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.unsigned] Make the column type unsigned, only useful for integer</code></li>
<li class='green'><span class=''> </span><code>         *              columns.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Array} [opts.elements] Available items used for set and enum columns.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        column:function (name, type, opts) {</code></li>
<li class='green'><span class='hits'>549</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>549</span><code>            this.columns.push(merge({name:name, type:type}, opts));</code></li>
<li class='green'><span class='hits'>549</span><code>            if (opts.index) {</code></li>
<li class='green'><span class='hits'>1</span><code>                this.index(name);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds a named constraint (or unnamed if name is nil) to the DDL,</code></li>
<li class='green'><span class=''> </span><code>         * with the given block or args.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.createTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      this.constraint("blah", {num : {between : [1,5])</code></li>
<li class='green'><span class=''> </span><code>         *              //=&gt; CONSTRAINT blah CHECK num &gt;= 1 AND num &lt;= 5</code></li>
<li class='green'><span class=''> </span><code>         *      this.check("foo", function(){</code></li>
<li class='green'><span class=''> </span><code>         *          return this.num.gt(5);</code></li>
<li class='green'><span class=''> </span><code>         *      }); # CONSTRAINT foo CHECK num &gt; 5</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the constraint</code></li>
<li class='green'><span class=''> </span><code>         * @param {...} args variable number of arguments to create the constraint filter.</code></li>
<li class='green'><span class=''> </span><code>         *              See {@link patio.Dataset#filter} for valid filter arguments.</code></li>
<li class='green'><span class=''> </span><code>         *   */</code></li>
<li class='green'><span class=''> </span><code>        constraint:function (name, args) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            args = argsToArray(arguments).slice(1);</code></li>
<li class='red'><span class='nohits'>0</span><code>            var block = isFunction(args[args.length - 1]) ? args.pop : null;</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.constraints.push({name:name, type:"check", check:block || args});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Add a foreign key in the table that references another table to the DDL. See {@link patio.SchemaGenerator#column{</code></li>
<li class='green'><span class=''> </span><code>         * for options.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.createTable("flight_leg", function () {</code></li>
<li class='green'><span class=''> </span><code>         *      this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *      this.scheduled_departure_time("time");</code></li>
<li class='green'><span class=''> </span><code>         *      this.scheduled_arrival_time("time");</code></li>
<li class='green'><span class=''> </span><code>         *      this.foreignKey("departure_code", "airport", {key:"airport_code", type : String, size : 4});</code></li>
<li class='green'><span class=''> </span><code>         *      this.foreignKey("arrival_code", "airport", {key:"airport_code", type : String, size : 4});</code></li>
<li class='green'><span class=''> </span><code>         *      this.foreignKey("flight_id", "flight", {key:"id"});</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        foreignKey:function (name, table, opts) {</code></li>
<li class='green'><span class='hits'>37</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>37</span><code>            opts = isHash(table) ? merge({}, table, opts) : isString(table) ? merge({table:table}, opts) : opts;</code></li>
<li class='green'><span class='hits'>37</span><code>            if (isArray(name)) {</code></li>
<li class='green'><span class='hits'>5</span><code>                return this.__compositeForeignKey(name, opts);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>32</span><code>                return this.column(name, "integer", opts);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Add a full text index on the given columns to the DDL.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.createTable("posts", function () {</code></li>
<li class='green'><span class=''> </span><code>         *      this.title("text");</code></li>
<li class='green'><span class=''> </span><code>         *      this.body("text");</code></li>
<li class='green'><span class=''> </span><code>         *      this.fullTextIndex("title");</code></li>
<li class='green'><span class=''> </span><code>         *      this.fullTextIndex(["title", "body"]);</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fullTextIndex:function (columns, opts) {</code></li>
<li class='green'><span class='hits'>4</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.index(columns, merge({type:"fullText"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Check if the DDL includes the creation of a column with the given name.</code></li>
<li class='green'><span class=''> </span><code>         * @return {Boolean} true if the DDL includes the creation of a column with the given name.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        hasColumn:function (name) {</code></li>
<li class='green'><span class='hits'>70</span><code>            return this.columns.some(function (c) {</code></li>
<li class='green'><span class='hits'>310</span><code>                return c.name == name</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add an index on the given column(s) with the given options to the DDL.</code></li>
<li class='green'><span class=''> </span><code>         * The available options are:</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.createTable("test", function(table) {</code></li>
<li class='green'><span class=''> </span><code>         *       table.primaryKey("id", "integer", {null : false});</code></li>
<li class='green'><span class=''> </span><code>         *       table.column("name", "text");</code></li>
<li class='green'><span class=''> </span><code>         *       table.index("name", {unique : true});</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param columns the column/n to create the index from.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object}  [opts] Additional options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String}  [opts.type] The type of index to use (only supported by some databases)</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.unique] :: Make the index unique, so duplicate values are not allowed.</code></li>
<li class='green'><span class=''> </span><code>         * @param [opts.where] :: Create a partial index (only supported by some databases)</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        index:function (columns, opts) {</code></li>
<li class='green'><span class='hits'>17</span><code>            this.indexes.push(merge({columns:toArray(columns)}, opts || {}));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds an auto-incrementing primary key column or a primary key constraint to the DDL.</code></li>
<li class='green'><span class=''> </span><code>         * To create a constraint, the first argument should be an array of columns</code></li>
<li class='green'><span class=''> </span><code>         * specifying the primary key columns. To create an auto-incrementing primary key</code></li>
<li class='green'><span class=''> </span><code>         * column, a single column can be used. In both cases, an options hash can be used</code></li>
<li class='green'><span class=''> </span><code>         * as the second argument.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If you want to create a primary key column that is not auto-incrementing, you</code></li>
<li class='green'><span class=''> </span><code>         * should not use this method.  Instead, you should use the regular {@link patio.SchemaGenerator#column}</code></li>
<li class='green'><span class=''> </span><code>         * method with a {primaryKey : true} option.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * db.createTable("airplane_type", function () {</code></li>
<li class='green'><span class=''> </span><code>         *      this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; id integer NOT NULL PRIMARY KEY AUTOINCREMENT</code></li>
<li class='green'><span class=''> </span><code>         *      this.name(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>         *      this.max_seats(Number, {size:3, allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>         *      this.company(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        primaryKey:function (name) {</code></li>
<li class='green'><span class='hits'>70</span><code>            if (isArray(name)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__compositePrimaryKey.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>70</span><code>                var args = argsToArray(arguments, 1), type;</code></li>
<li class='green'><span class='hits'>70</span><code>                var opts = args.pop();</code></li>
<li class='green'><span class='hits'>70</span><code>                this.__primaryKey = merge({}, this.db.serialPrimaryKeyOptions, {name:name}, opts);</code></li>
<li class='green'><span class='hits'>70</span><code>                if (isDefined((type = args.pop()))) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    merge(opts, {type:type});</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>70</span><code>                merge(this.__primaryKey, opts);</code></li>
<li class='green'><span class='hits'>70</span><code>                return this.__primaryKey;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a spatial index on the given columns to the DDL.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        spatialIndex:function (columns, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.index(columns, merge({type:"spatial"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a unique constraint on the given columns to the DDL. See {@link patio.SchemaGenerator#constraint}</code></li>
<li class='green'><span class=''> </span><code>         * for argument types.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.createTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.unique("name");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; UNIQUE (name)</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *   */</code></li>
<li class='green'><span class=''> </span><code>        unique:function (columns, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            opts = opts || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.constraints.push(merge({type:"unique", columns:toArray(columns)}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Add a composite primary key constraint</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __compositePrimaryKey:function (columns) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var args = argsToArray(arguments, 1);</code></li>
<li class='red'><span class='nohits'>0</span><code>            var opts = args.pop() || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.constraints.push(merge({type:"primaryKey", columns:columns}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Add a composite foreign key constraint</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __compositeForeignKey:function (columns, opts) {</code></li>
<li class='green'><span class='hits'>5</span><code>            this.constraints.push(merge({type:"foreignKey", columns:columns}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            // The name of the primary key for this generator, if it has a primary key.</code></li>
<li class='green'><span class=''> </span><code>            primaryKeyName:function () {</code></li>
<li class='green'><span class='hits'>70</span><code>                return this.__primaryKey ? this.__primaryKey.name : null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>exports.SchemaGenerator = function (db, block) {</code></li>
<li class='green'><span class='hits'>218</span><code>    var gen = new Generator(db);</code></li>
<li class='green'><span class='hits'>218</span><code>    var prox = methodMissing(gen, function (name) {</code></li>
<li class='green'><span class='hits'>431</span><code>        return function (type, opts) {</code></li>
<li class='green'><span class='hits'>431</span><code>            name = name || null;</code></li>
<li class='green'><span class='hits'>431</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>431</span><code>            if (name) {</code></li>
<li class='green'><span class='hits'>431</span><code>                return this.column(name, type, opts);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new TypeError();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }, Generator);</code></li>
<li class='green'><span class='hits'>218</span><code>    block.apply(prox, [prox]);</code></li>
<li class='green'><span class='hits'>218</span><code>    gen.columns = prox.columns;</code></li>
<li class='green'><span class='hits'>218</span><code>    if (gen.__primaryKey &amp;&amp; !gen.hasColumn(gen.primaryKeyName)) {</code></li>
<li class='green'><span class='hits'>70</span><code>        gen.columns.unshift(gen.__primaryKey);</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>218</span><code>    return gen;</code></li>
<li class='green'><span class=''> </span><code>}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var AlterTableGenerator = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.AlterTableGenerator.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * An internal class that the user is not expected to instantiate directly.</code></li>
<li class='green'><span class=''> </span><code>         * Instances are created by {@link patio.Database#alterTable}.</code></li>
<li class='green'><span class=''> </span><code>         * It is used to specify table alteration parameters.  It takes a Database</code></li>
<li class='green'><span class=''> </span><code>         * object and a function which is called in the scope of the {@link patio.AlterTableGenerator}</code></li>
<li class='green'><span class=''> </span><code>         * to perform on the table, and gives the Database an array of table altering operations,</code></li>
<li class='green'><span class=''> </span><code>         * which the database uses to alter a table's description.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("xyz", function() {</code></li>
<li class='green'><span class=''> </span><code>         *      this.addColumn("aaa", "text", {null : false, unique : true});</code></li>
<li class='green'><span class=''> </span><code>         *      this.dropColumn("bbb");</code></li>
<li class='green'><span class=''> </span><code>         *      this.renameColumn("ccc", "ddd");</code></li>
<li class='green'><span class=''> </span><code>         *      this.setColumnType("eee", "integer");</code></li>
<li class='green'><span class=''> </span><code>         *      this.setColumnDefault("hhh", 'abcd');</code></li>
<li class='green'><span class=''> </span><code>         *      this.addIndex("fff", {unique : true});</code></li>
<li class='green'><span class=''> </span><code>         *      this.dropIndex("ggg");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //or using the passed in generator</code></li>
<li class='green'><span class=''> </span><code>         *  DB.alterTable("xyz", function(table) {</code></li>
<li class='green'><span class=''> </span><code>         *      table.addColumn("aaa", "text", {null : false, unique : true});</code></li>
<li class='green'><span class=''> </span><code>         *      table.dropColumn("bbb");</code></li>
<li class='green'><span class=''> </span><code>         *      table.renameColumn("ccc", "ddd");</code></li>
<li class='green'><span class=''> </span><code>         *      table.setColumnType("eee", "integer");</code></li>
<li class='green'><span class=''> </span><code>         *      table.setColumnDefault("hhh", 'abcd');</code></li>
<li class='green'><span class=''> </span><code>         *      table.addIndex("fff", {unique : true});</code></li>
<li class='green'><span class=''> </span><code>         *      table.dropIndex("ggg");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Database} db the database object which is performing the alter table operation.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} block a block which performs the operations. The block is called in the scope</code></li>
<li class='green'><span class=''> </span><code>         * of the {@link patio.AlterTableGenerator} and is passed an instance of {@link patio.AlterTableGenerator}</code></li>
<li class='green'><span class=''> </span><code>         * as the first argument.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (db, block) {</code></li>
<li class='green'><span class='hits'>80</span><code>            this.db = db;</code></li>
<li class='green'><span class='hits'>80</span><code>            this.operations = [];</code></li>
<li class='green'><span class='hits'>80</span><code>            block.apply(this, [this]);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a column with the given name, type, and opts to the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.SchemaGenerator#column} for the available options.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.addColumn("name", String);</code></li>
<li class='green'><span class=''> </span><code>         *     //=&gt; ADD COLUMN name varchar(255)</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        addColumn:function (name, type, opts) {</code></li>
<li class='green'><span class='hits'>13</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>13</span><code>            this.operations.push(merge({op:"addColumn", name:name, type:type}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a constraint with the given name and args to the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.SchemaGenerator#constraint}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var sql = patio.sql;</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      this.addConstraint("valid_name", sql.name.like('A%'));</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;ADD CONSTRAINT valid_name CHECK (name LIKE 'A%')</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *   */</code></li>
<li class='green'><span class=''> </span><code>        addConstraint:function (name) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var args = argsToArray(arguments);</code></li>
<li class='red'><span class='nohits'>0</span><code>            var block = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.operations.push({op:"addConstraint", name:name, type:"check", check:block || args});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a unique constraint to the given column(s).</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.SchemaGenerator#constraint}.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.addUniqueConstraint("name");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ADD UNIQUE (name)</code></li>
<li class='green'><span class=''> </span><code>         *   this.addUniqueConstraint("name", {name : "uniqueName});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ADD CONSTRAINT uniqueName UNIQUE (name)</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        addUniqueConstraint:function (columns, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            opts = opts || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.operations.push(merge({op:"addConstraint", type:"unique", columns:toArray(columns)}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a foreign key with the given name and referencing the given table</code></li>
<li class='green'><span class=''> </span><code>         * to the DDL for the table.  See {@link patio.SchemaGenerator#column}</code></li>
<li class='green'><span class=''> </span><code>         * for the available options.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * You can also pass an array of column names for creating composite foreign</code></li>
<li class='green'><span class=''> </span><code>         * keys. In this case, it will assume the columns exists and will only add</code></li>
<li class='green'><span class=''> </span><code>         * the constraint.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * NOTE: If you need to add a foreign key constraint to a single existing column</code></li>
<li class='green'><span class=''> </span><code>         * use the composite key syntax even if it is only one column.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("albums", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.addForeignKey("artist_id", "table");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;ADD COLUMN artist_id integer REFERENCES table</code></li>
<li class='green'><span class=''> </span><code>         *   this.addForeignKey(["name"], "table")</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;ADD FOREIGN KEY (name) REFERENCES table</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        addForeignKey:function (name, table, opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            opts = opts;</code></li>
<li class='green'><span class='hits'>3</span><code>            if (isArray(name)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.__addCompositeForeignKey(name, table, opts);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                return this.addColumn(name, "integer", merge({table:table}, opts));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a full text index on the given columns to the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         * See @{link patio.SchemaGenerator#index} for available options.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        addFullTextIndex:function (columns, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            opts = opts || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.addIndex(columns, merge({type:"fullText"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add an index on the given columns to the DDL for the table.  See</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.SchemaGenerator#index} for available options.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("table", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.addIndex("artist_id");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; CREATE INDEX table_artist_id_index ON table (artist_id)</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        addIndex:function (columns, opts) {</code></li>
<li class='green'><span class='hits'>5</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>5</span><code>            this.operations.push(merge({op:"addIndex", columns:toArray(columns)}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a primary key to the DDL for the table.  See {@link patio.SchemaGenerator#column}</code></li>
<li class='green'><span class=''> </span><code>         * for the available options.  Like {@link patio.ALterTableGenerator#addForeignKey}, if you specify</code></li>
<li class='green'><span class=''> </span><code>         * the column name as an array, it just creates a constraint:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("albums", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      this.addPrimaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *           //=&gt; ADD COLUMN id serial PRIMARY KEY</code></li>
<li class='green'><span class=''> </span><code>         *      this.addPrimaryKey(["artist_id", "name"])</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;ADD PRIMARY KEY (artist_id, name)</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        addPrimaryKey:function (name, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            opts = opts || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (isArray(name)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__addCompositePrimaryKey(name, opts);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                opts = merge({}, this.db.serialPrimaryKeyOptions, opts);</code></li>
<li class='red'><span class='nohits'>0</span><code>                delete opts.type;</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.addColumn(name, "integer", opts);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a spatial index on the given columns to the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.SchemaGenerator#index} for available options.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        addSpatialIndex:function (columns, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            opts = opts || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.addIndex(columns, merge({}, {type:"spatial"}, opts))</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Remove a column from the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("albums", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.dropColumn("artist_id");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;DROP COLUMN artist_id</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the column to drop.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        dropColumn:function (name) {</code></li>
<li class='green'><span class='hits'>4</span><code>            this.operations.push({op:"dropColumn", name:name});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Remove a constraint from the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("test", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      this.dropConstraint("constraint_name");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;DROP CONSTRAINT constraint_name</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the constraint to drop.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        dropConstraint:function (name) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.operations.push({op:"dropConstraint", name:name});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Remove an index from the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("albums", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.dropIndex("artist_id")</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;DROP INDEX table_artist_id_index</code></li>
<li class='green'><span class=''> </span><code>         *   this.dropIndex(["a", "b"])</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;DROP INDEX table_a_b_index</code></li>
<li class='green'><span class=''> </span><code>         *   this.dropIndex(["a", "b"], {name : "foo"})</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;DROP INDEX foo</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        dropIndex:function (columns, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>2</span><code>            this.operations.push(merge({op:"dropIndex", columns:toArray(columns)}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Modify a column's name in the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("artist", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      this.renameColumn("name", "artistName");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; RENAME COLUMN name TO artist_name</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        renameColumn:function (name, newName, opts) {</code></li>
<li class='green'><span class='hits'>51</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>51</span><code>            this.operations.push(merge({op:"renameColumn", name:name, newName:newName}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Modify a column's default value in the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("artist", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;this.setColumnDefault("artist_name", "a");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; ALTER COLUMN artist_name SET DEFAULT 'a'</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *   */</code></li>
<li class='green'><span class=''> </span><code>        setColumnDefault:function (name, def) {</code></li>
<li class='green'><span class='hits'>5</span><code>            this.operations.push({op:"setColumnDefault", name:name, "default":def});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Modify a column's type in the DDL for the table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("artist", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.setColumnType("artist_name", 'char(10)');</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ALTER COLUMN artist_name TYPE char(10)</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        setColumnType:function (name, type, opts) {</code></li>
<li class='green'><span class='hits'>7</span><code>            opts = opts || {}</code></li>
<li class='green'><span class='hits'>7</span><code>            this.operations.push(merge({op:"setColumnType", name:name, type:type}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Modify a column's NOT NULL constraint.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.alterTable("artist", function(){</code></li>
<li class='green'><span class=''> </span><code>         *   this.setColumnAllowNull("artist_name", false);</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ALTER COLUMN artist_name SET NOT NULL</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        setAllowNull:function (name, allowNull) {</code></li>
<li class='green'><span class='hits'>1</span><code>            this.operations.push({op:"setColumnNull", name:name, "null":allowNull});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Add a composite primary key constraint</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        __addCompositePrimaryKey:function (columns, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.operations.push(merge({op:"addConstraint", type:"primaryKey", columns:columns}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Add a composite foreign key constraint</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __addCompositeForeignKey:function (columns, table, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            this.operations.push(merge({op:"addConstraint", type:"foreignKey", columns:columns, table:table}, opts));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "AlterTableGenerator");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-low" id="index.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>index.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>71.74</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>1081</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>92</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>26</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="index.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @projectName patio</code></li>
<li class='green'><span class=''> </span><code> * @github https://github.com/C2FO/patio</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Connecting] ../docs-md/connecting.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Models] ../docs-md/models.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Associations] ../docs-md/associations.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Model Inheritance] ../docs-md/model-inheritance.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Model Validation] ../docs-md/validation.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Model Plugins] ../docs-md/plugins.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Querying] ../docs-md/querying.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [DDL] ../docs-md/DDL.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Migrations] ../docs-md/migrations.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Logging] ../docs-md/logging.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Change Log] ../History.md</code></li>
<li class='green'><span class=''> </span><code> * @includeDoc [Test Coverage] [../docs-md/coverage.html]</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @header</code></li>
<li class='green'><span class=''> </span><code> * [![Build Status](https://secure.travis-ci.org/C2FO/patio.png)](http://travis-ci.org/C2FO/patio)</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Patio is a &lt;a href="http://sequel.rubyforge.org/" target="patioapi"&gt;Sequel&lt;/a&gt; inspired query engine.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;h3&gt;Why Use Patio?&lt;/h3&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code> * Patio is different because it allows the developers to choose the level of abtraction they are comfortable with.</code></li>
<li class='green'><span class=''> </span><code> * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code> * If you want to use &lt;a href="./models.html"&gt;ORM&lt;/a&gt; functionality you can. If you dont you can just use the</code></li>
<li class='green'><span class=''> </span><code> * &lt;a href="./DDL.html"&gt;Database&lt;/a&gt; and &lt;a href="./querying.html"&gt;Datasets&lt;/a&gt; as a querying API, and if you need to</code></li>
<li class='green'><span class=''> </span><code> * you can &lt;a href="./patio_Database.html#run"&gt;write plain SQL&lt;/a&gt;.</code></li>
<li class='green'><span class=''> </span><code> * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * ###Getting Started</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * To install patio run</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * `npm install comb patio`</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * If you want to use the patio executable for migrations</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * `npm install -g patio`</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Create some tables.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> * var patio = require("patio"),</code></li>
<li class='green'><span class=''> </span><code> * comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code> * when = comb.when,</code></li>
<li class='green'><span class=''> </span><code> * serial = comb.serial;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //set all db name to camelize</code></li>
<li class='green'><span class=''> </span><code> * patio.camelize = true;</code></li>
<li class='green'><span class=''> </span><code> * patio.configureLogging();</code></li>
<li class='green'><span class=''> </span><code> * //connect to the db</code></li>
<li class='green'><span class=''> </span><code> * var DB = patio.connect(&lt;CONNECTION_URI&gt;);</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * function errorHandler(error) {</code></li>
<li class='green'><span class=''> </span><code> *      console.log(error);</code></li>
<li class='green'><span class=''> </span><code> *      patio.disconnect();</code></li>
<li class='green'><span class=''> </span><code> * };</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * function createTables() {</code></li>
<li class='green'><span class=''> </span><code> *      return comb.serial([</code></li>
<li class='green'><span class=''> </span><code> *           function () {</code></li>
<li class='green'><span class=''> </span><code> *                return DB.forceDropTable(["capital", "state"]);</code></li>
<li class='green'><span class=''> </span><code> *           },</code></li>
<li class='green'><span class=''> </span><code> *           function () {</code></li>
<li class='green'><span class=''> </span><code> *                return DB.createTable("state", function () {</code></li>
<li class='green'><span class=''> </span><code> *                     this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code> *                     this.name(String)</code></li>
<li class='green'><span class=''> </span><code> *                     this.population("integer");</code></li>
<li class='green'><span class=''> </span><code> *                     this.founded(Date);</code></li>
<li class='green'><span class=''> </span><code> *                     this.climate(String);</code></li>
<li class='green'><span class=''> </span><code> *                     this.description("text");</code></li>
<li class='green'><span class=''> </span><code> *                });</code></li>
<li class='green'><span class=''> </span><code> *           },</code></li>
<li class='green'><span class=''> </span><code> *           function () {</code></li>
<li class='green'><span class=''> </span><code> *                return DB.createTable("capital", function () {</code></li>
<li class='green'><span class=''> </span><code> *                     this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code> *                     this.population("integer");</code></li>
<li class='green'><span class=''> </span><code> *                     this.name(String);</code></li>
<li class='green'><span class=''> </span><code> *                     this.founded(Date);</code></li>
<li class='green'><span class=''> </span><code> *                     this.foreignKey("stateId", "state", {key:"id"});</code></li>
<li class='green'><span class=''> </span><code> *                });</code></li>
<li class='green'><span class=''> </span><code> *           }</code></li>
<li class='green'><span class=''> </span><code> *      ]);</code></li>
<li class='green'><span class=''> </span><code> * };</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * createTables().then(function () {</code></li>
<li class='green'><span class=''> </span><code> *      patio.disconnect();</code></li>
<li class='green'><span class=''> </span><code> * }, errorHandler);</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Next lets create some models for the tables created.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> * var State = patio.addModel("state").oneToOne("capital");</code></li>
<li class='green'><span class=''> </span><code> * var Capital = patio.addModel("capital").manyToOne("state");</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Next you'll need to sync your models. **Note**: The sync operation returns a promise.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> * patio.syncModels();</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Save some data to query.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> * //comb.when waits for the save operation to complete</code></li>
<li class='green'><span class=''> </span><code> * return comb.when(</code></li>
<li class='green'><span class=''> </span><code> *      State.save({</code></li>
<li class='green'><span class=''> </span><code> *           name:"Nebraska",</code></li>
<li class='green'><span class=''> </span><code> *           population:1796619,</code></li>
<li class='green'><span class=''> </span><code> *           founded:new Date(1867, 2, 4),</code></li>
<li class='green'><span class=''> </span><code> *           climate:"continental",</code></li>
<li class='green'><span class=''> </span><code> *           capital:{</code></li>
<li class='green'><span class=''> </span><code> *                name:"Lincoln",</code></li>
<li class='green'><span class=''> </span><code> *                founded:new Date(1856, 0, 1),</code></li>
<li class='green'><span class=''> </span><code> *                population:258379</code></li>
<li class='green'><span class=''> </span><code> *          }</code></li>
<li class='green'><span class=''> </span><code> *      }),</code></li>
<li class='green'><span class=''> </span><code> *      Capital.save({</code></li>
<li class='green'><span class=''> </span><code> *           name:"Austin",</code></li>
<li class='green'><span class=''> </span><code> *           founded:new Date(1835, 0, 1),</code></li>
<li class='green'><span class=''> </span><code> *           population:790390,</code></li>
<li class='green'><span class=''> </span><code> *           state:{</code></li>
<li class='green'><span class=''> </span><code> *                name:"Texas",</code></li>
<li class='green'><span class=''> </span><code> *                population:25674681,</code></li>
<li class='green'><span class=''> </span><code> *                founded:new Date(1845, 11, 29)</code></li>
<li class='green'><span class=''> </span><code> *           }</code></li>
<li class='green'><span class=''> </span><code> *      })</code></li>
<li class='green'><span class=''> </span><code> * );</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Now we can query the states and capitals we created.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> * State.order("name").forEach(function (state) {</code></li>
<li class='green'><span class=''> </span><code> *      //if you return a promise here it will prevent the foreach from</code></li>
<li class='green'><span class=''> </span><code> *      //resolving until all inner processing has finished.</code></li>
<li class='green'><span class=''> </span><code> *      return state.capital.then(function (capital) {</code></li>
<li class='green'><span class=''> </span><code> *          console.log("%s's capital is %s.", state.name, capital.name);</code></li>
<li class='green'><span class=''> </span><code> *      });</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> * Capital.order("name").forEach(function (capital) {</code></li>
<li class='green'><span class=''> </span><code> *      //if you return a promise here it will prevent the foreach from</code></li>
<li class='green'><span class=''> </span><code> *      //resolving until all inner processing has finished.</code></li>
<li class='green'><span class=''> </span><code> *      return capital.state.then(function (state) {</code></li>
<li class='green'><span class=''> </span><code> *          console.log(comb.string.format("%s is the capital of %s.", capital.name, state.name));</code></li>
<li class='green'><span class=''> </span><code> *      });</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> * ```</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Dataset = require("./dataset"),</code></li>
<li class='green'><span class=''> </span><code>    Database = require("./database"),</code></li>
<li class='green'><span class=''> </span><code>    adapters = require("./adapters"),</code></li>
<li class='green'><span class=''> </span><code>    EventEmitter = require("events").EventEmitter,</code></li>
<li class='green'><span class=''> </span><code>    PatioError = require("./errors").PatioError,</code></li>
<li class='green'><span class=''> </span><code>    migrate = require("./migration"),</code></li>
<li class='green'><span class=''> </span><code>    model = require("./model"),</code></li>
<li class='green'><span class=''> </span><code>    Model = model.Model,</code></li>
<li class='green'><span class=''> </span><code>    plugins = require("./plugins"),</code></li>
<li class='green'><span class=''> </span><code>    comb = require("comb-proxy"),</code></li>
<li class='green'><span class=''> </span><code>    Time = require("./time"),</code></li>
<li class='green'><span class=''> </span><code>    date = comb.date,</code></li>
<li class='green'><span class=''> </span><code>    SQL = require("./sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    singleton = comb.singleton,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    executeInOrder = comb.executeInOrder,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var LOGGER = comb.logger("patio");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Patio = singleton([EventEmitter, Time], {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @lends patio.prototype</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __camelize:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __underscore:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __inImportOfModels:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * A singleton class that acts as the entry point for all actions performed in patio.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var patio = require("patio");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.createConnection(....);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.camelize = true;</code></li>
<li class='green'><span class=''> </span><code>         * patio.quoteIdentifiers=false;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.createModel("my_table");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  //CHANGING IDENTIFIER INPUT METHOD</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  //use whatever is passed in</code></li>
<li class='green'><span class=''> </span><code>         *   patio.identifierInputMethod = null;</code></li>
<li class='green'><span class=''> </span><code>         *  //convert to uppercase</code></li>
<li class='green'><span class=''> </span><code>         *  patio.identifierInputMethod = "toUpperCase";</code></li>
<li class='green'><span class=''> </span><code>         *  //convert to camelCase</code></li>
<li class='green'><span class=''> </span><code>         *  patio.identifierInputMethod = "camelize";</code></li>
<li class='green'><span class=''> </span><code>         *  //convert to underscore</code></li>
<li class='green'><span class=''> </span><code>         *  patio.identifierInputMethod = "underscore";</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  //CHANGING IDENTIFIER OUTPUT METHOD</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  //use whatever the db returns</code></li>
<li class='green'><span class=''> </span><code>         *   patio.identifierOutputMethod = null;</code></li>
<li class='green'><span class=''> </span><code>         *  //convert to uppercase</code></li>
<li class='green'><span class=''> </span><code>         *  patio.identifierOutputMethod = "toUpperCase";</code></li>
<li class='green'><span class=''> </span><code>         *  //convert to camelCase</code></li>
<li class='green'><span class=''> </span><code>         *  patio.identifierOutputMethod = "camelize";</code></li>
<li class='green'><span class=''> </span><code>         *  //convert to underscore</code></li>
<li class='green'><span class=''> </span><code>         *  patio.identifierOutputMethod = "underscore";</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  //TURN QUOTING OFF</code></li>
<li class='green'><span class=''> </span><code>         *   patio.quoteIdentifiers = false</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.Time</code></li>
<li class='green'><span class=''> </span><code>         * @param options</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>1</span><code>            var constants = SQL.Constants;</code></li>
<li class='green'><span class='hits'>1</span><code>            for (var i in constants) {</code></li>
<li class='green'><span class='hits'>9</span><code>                this[i] = constants[i];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a {@link patio.Database} object that can be used to for querying.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;This method is the entry point for all interactions with a database including getting</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.Dataset}s for creating queries(see {@link patio.Database#from}).</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;The {@link patio.Database} returned can also be used to create({@link patio.Database#createTable}),</code></li>
<li class='green'><span class=''> </span><code>         * alter(@link patio.Database#alterTable}), rename({@link patio.Database#renameTable}), and</code></li>
<li class='green'><span class=''> </span><code>         * drop({@link patio.Database#dropTable}) as well as many other {@link patio.Database} actions.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //connect using an object</code></li>
<li class='green'><span class=''> </span><code>         * var DB = patio.createConnection({</code></li>
<li class='green'><span class=''> </span><code>         *              host : "127.0.0.1",</code></li>
<li class='green'><span class=''> </span><code>         *              port : 3306,</code></li>
<li class='green'><span class=''> </span><code>         *              type : "mysql",</code></li>
<li class='green'><span class=''> </span><code>         *              maxConnections : 1,</code></li>
<li class='green'><span class=''> </span><code>         *              minConnections : 1,</code></li>
<li class='green'><span class=''> </span><code>         *              user : "test",</code></li>
<li class='green'><span class=''> </span><code>         *              password : "testpass",</code></li>
<li class='green'><span class=''> </span><code>         *              database : 'test'</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * //connect using a connection string</code></li>
<li class='green'><span class=''> </span><code>         * var CONNECT_STRING = "mysql://test:testpass@localhost:3306/test?maxConnections=1&amp;minConnections=1";</code></li>
<li class='green'><span class=''> </span><code>         * var DB = patio.createConnection(CONNECT_STRING);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //...do something</code></li>
<li class='green'><span class=''> </span><code>         * DB.createTable("myTable", function(){</code></li>
<li class='green'><span class=''> </span><code>         *    this.name("text");</code></li>
<li class='green'><span class=''> </span><code>         *    this.value("integer");</code></li>
<li class='green'><span class=''> </span><code>         * }).then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //tables created!!!</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|Object} options the options used to initialize the database connection.</code></li>
<li class='green'><span class=''> </span><code>         *                        This may be a database connetion string or object.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number} [options.maxConnections = 10] the number of connections to pool.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number} [options.minConnections = 3] the number of connections to pool.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [options.type = "mysql"] the type of database to communicate with.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} options.user the user to authenticate as.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} options.password the password of the user.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} options.database the name of the database to use, the database</code></li>
<li class='green'><span class=''> </span><code>         *                                   specified here is the default database for all connections.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        createConnection:function (options) {</code></li>
<li class='green'><span class='hits'>41</span><code>            var ret = Database.connect(options);</code></li>
<li class='green'><span class='hits'>41</span><code>            this.emit("connect", ret);</code></li>
<li class='green'><span class='hits'>41</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  @see patio#createConnection</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        connect:function () {</code></li>
<li class='green'><span class='hits'>13</span><code>            return this.createConnection.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This method allows one to connect to a database and immediately execute code.</code></li>
<li class='green'><span class=''> </span><code>         * For connection options @see patio#createConnection</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var DB;</code></li>
<li class='green'><span class=''> </span><code>         * var CONNECT_STRING = "dummyDB://test:testpass@localhost/dummySchema";</code></li>
<li class='green'><span class=''> </span><code>         * var connectPromise = patio.connectAndExecute(CONNECT_STRING, function (db) {</code></li>
<li class='green'><span class=''> </span><code>         *      db.dropTable("test");</code></li>
<li class='green'><span class=''> </span><code>         *      db.createTable("test", function () {</code></li>
<li class='green'><span class=''> </span><code>         *          this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *          this.name(String);</code></li>
<li class='green'><span class=''> </span><code>         *          this.age(Number);</code></li>
<li class='green'><span class=''> </span><code>         *      });</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * connectPromise.then(function (db) {</code></li>
<li class='green'><span class=''> </span><code>         *      DB = db;</code></li>
<li class='green'><span class=''> </span><code>         *      //do more stuff!</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|Object} options @see patio#createConnection</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} cb the function to callback once connected.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @returns {comb.Promise} a promise that is resolved once the database execution has finished.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        connectAndExecute:function (options, cb) {</code></li>
<li class='green'><span class='hits'>27</span><code>            if (!isFunction(cb)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new PatioError("callback must be a function");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>27</span><code>            var db = this.createConnection.apply(this, arguments);</code></li>
<li class='green'><span class='hits'>27</span><code>            return executeInOrder(db, patio, function (db, patio) {</code></li>
<li class='green'><span class='hits'>27</span><code>                cb(db, patio);</code></li>
<li class='green'><span class='hits'>27</span><code>                return db;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Disconnects all databases in use.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb=null] a callback to call when disconnect has completed</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved once all databases have disconnected.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        disconnect:function (cb) {</code></li>
<li class='green'><span class='hits'>41</span><code>            var ret = Database.disconnect(cb);</code></li>
<li class='green'><span class='hits'>41</span><code>            ret.classic(hitch(this, function (err) {</code></li>
<li class='green'><span class='hits'>41</span><code>                if (err) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    this.emit("error", err);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>41</span><code>                    this.emit("disconnect");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class='hits'>41</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Allows for the importing of multiple models so you do not have to worry about the promise that is returned from create model,</code></li>
<li class='green'><span class=''> </span><code>         * or a directory if an index.js file is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     To import a group of model files you can do the following:</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * patio.import(__dirname + "/models/Flight.js",</code></li>
<li class='green'><span class=''> </span><code>         *              __dirname + "/models/Airport.js",</code></li>
<li class='green'><span class=''> </span><code>         *              __dirname + "/models/Airplane.js").then(function(Flight, Airport, Airplane){</code></li>
<li class='green'><span class=''> </span><code>         *                  //...</code></li>
<li class='green'><span class=''> </span><code>         *              });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.import(__dirname + "/models/Flight.js",</code></li>
<li class='green'><span class=''> </span><code>         *              __dirname + "/models/Airport.js",</code></li>
<li class='green'><span class=''> </span><code>         *              __dirname + "/models/Airplane.js").then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *                  var Flight = patio.getModel("flight"),</code></li>
<li class='green'><span class=''> </span><code>         *                      Airport = patio.getModel("airport"),</code></li>
<li class='green'><span class=''> </span><code>         *                      Airplane = patio.getModel("airplane");</code></li>
<li class='green'><span class=''> </span><code>         *              });</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     Another approach is to create an index.js file inside of a directory that requires all of the models needed.</code></li>
<li class='green'><span class=''> </span><code>         *     then use {@link patio#import} on that file.</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         * patio.import(__dirname + "/models").then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      var Flight = patio.getModel("flight"),</code></li>
<li class='green'><span class=''> </span><code>         *          Airport = patio.getModel("airport"),</code></li>
<li class='green'><span class=''> </span><code>         *          Airplane = patio.getModel("airplane");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param files a single or list of files to import.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] an optional callback to call when importing is complete</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} returns a promise that will be resolved when all models in the imported files</code></li>
<li class='green'><span class=''> </span><code>         * have been loaded.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        "import":function (files, cb) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            files = argsToArray(arguments);</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (isFunction(files[files.length])) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                cb = files.pop();</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                cb = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            files.map(function (file) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                require(file);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='red'><span class='nohits'>0</span><code>            return model.syncModels(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This method is used to create a {@link patio.Model} object.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var Flight = patio.addModel("flight", {</code></li>
<li class='green'><span class=''> </span><code>         *      instance:{</code></li>
<li class='green'><span class=''> </span><code>         *              toObject:function () {</code></li>
<li class='green'><span class=''> </span><code>         *                  var obj = this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>         *                  obj.weekdays = this.weekdaysArray;</code></li>
<li class='green'><span class=''> </span><code>         *                  obj.legs = this.legs.map(function (l) {</code></li>
<li class='green'><span class=''> </span><code>         *                      return l.toObject();</code></li>
<li class='green'><span class=''> </span><code>         *                  });</code></li>
<li class='green'><span class=''> </span><code>         *                  return obj;</code></li>
<li class='green'><span class=''> </span><code>         *              },</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *              _setWeekdays:function (weekdays) {</code></li>
<li class='green'><span class=''> </span><code>         *                  this.weekdaysArray = weekdays.split(",");</code></li>
<li class='green'><span class=''> </span><code>         *                  return weekdays;</code></li>
<li class='green'><span class=''> </span><code>         *              }</code></li>
<li class='green'><span class=''> </span><code>         *      },</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      static:{</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          init:function () {</code></li>
<li class='green'><span class=''> </span><code>         *              this.oneToMany("legs", {</code></li>
<li class='green'><span class=''> </span><code>         *                  model:"flightLeg",</code></li>
<li class='green'><span class=''> </span><code>         *                  orderBy:"scheduledDepartureTime",</code></li>
<li class='green'><span class=''> </span><code>         *                  fetchType:this.fetchType.EAGER</code></li>
<li class='green'><span class=''> </span><code>         *              });</code></li>
<li class='green'><span class=''> </span><code>         *          },</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          byAirline:function (airline) {</code></li>
<li class='green'><span class=''> </span><code>         *              return this.filter({airline:airline}).all();</code></li>
<li class='green'><span class=''> </span><code>         *          },</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          arrivesAt:function (airportCode) {</code></li>
<li class='green'><span class=''> </span><code>         *              return this.join(this.flightLeg.select("flightId").filter({arrivalCode:airportCode}).distinct(), {flightId:"id"}).all();</code></li>
<li class='green'><span class=''> </span><code>         *          },</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          departsFrom:function (airportCode) {</code></li>
<li class='green'><span class=''> </span><code>         *              return this.join(this.flightLeg.select("flightId").filter({departureCode:airportCode}).distinct(), {flightId:"id"}).all();</code></li>
<li class='green'><span class=''> </span><code>         *          },</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          getters:{</code></li>
<li class='green'><span class=''> </span><code>         *              flightLeg:function () {</code></li>
<li class='green'><span class=''> </span><code>         *                  if (!this.__flightLeg) {</code></li>
<li class='green'><span class=''> </span><code>         *                      this.__flightLeg = this.patio.getModel("flightLeg");</code></li>
<li class='green'><span class=''> </span><code>         *                  }</code></li>
<li class='green'><span class=''> </span><code>         *                  return this.__flightLeg;</code></li>
<li class='green'><span class=''> </span><code>         *              }</code></li>
<li class='green'><span class=''> </span><code>         *          }</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.Dataset} table the table to use as the base for the model.</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Model|patio.Model[]} Parent models of this model.</code></li>
<li class='green'><span class=''> </span><code>         *                  See {@link patio.plugins.ClassTableInheritancePlugin}.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [proto] an object to be used as the prototype for the model. See</code></li>
<li class='green'><span class=''> </span><code>         * &lt;a href="http://c2fo.github.com/comb/symbols/comb.html#.define"&gt;comb.define&lt;/a&gt;.</code></li>
<li class='green'><span class=''> </span><code>         * @param [Object[]] [proto.plugins] this can be used to specify additional plugins to use such as.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;{@link patio.plugins.TimeStampPlugin&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;{@link patio.plugins.CachePlugin&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        addModel:function (table, supers, proto) {</code></li>
<li class='green'><span class='hits'>93</span><code>            return model.create.apply(model, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a model from the name of the table for which the model was created.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * var TestModel = patio.addModel("test_model").sync(function(err){</code></li>
<li class='green'><span class=''> </span><code>         *      if(err){</code></li>
<li class='green'><span class=''> </span><code>         *         console.log(err.stack);</code></li>
<li class='green'><span class=''> </span><code>         *      }else{</code></li>
<li class='green'><span class=''> </span><code>         *            var TestModel = patio.getModel("test_model");</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If you have two tables with the same name in different databases then you can use the db parameter also.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var DB1 = patio.createConnection("mysql://test:testpass@localhost:3306/test_1");</code></li>
<li class='green'><span class=''> </span><code>         * var DB2 = patio.createConnection("mysql://test:testpass@localhost:3306/test_2");</code></li>
<li class='green'><span class=''> </span><code>         * var Test1 = patio.addModel(DB1.from("test");</code></li>
<li class='green'><span class=''> </span><code>         * var Test2 = patio.addModel(DB2.from("test");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //sync the models</code></li>
<li class='green'><span class=''> </span><code>         * patio.syncModels().then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      //now you can use them</code></li>
<li class='green'><span class=''> </span><code>         *      var test1Model = new Test1();</code></li>
<li class='green'><span class=''> </span><code>         *      var test2Model = new Test2();</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} name the name of the table that the model represents.</code></li>
<li class='green'><span class=''> </span><code>         * @param {@patio.Database} [db] optional database in case you have two models with the same table names in</code></li>
<li class='green'><span class=''> </span><code>         *                               different databases.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        getModel:function (name, db) {</code></li>
<li class='green'><span class='hits'>83</span><code>            return model.getModel(name, db);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Helper method to sync all models at once.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var User = patio.addModel("user");</code></li>
<li class='green'><span class=''> </span><code>         * var Blog = patio.addModel("blog");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //using promise api</code></li>
<li class='green'><span class=''> </span><code>         * patio.syncModels().then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     var user = new User();</code></li>
<li class='green'><span class=''> </span><code>         * }, function(error){</code></li>
<li class='green'><span class=''> </span><code>         *    console.log(err);</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //using a callback</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  patio.syncModels(function(err){</code></li>
<li class='green'><span class=''> </span><code>         *      if(err){</code></li>
<li class='green'><span class=''> </span><code>         *          console.log(err);</code></li>
<li class='green'><span class=''> </span><code>         *      }else{</code></li>
<li class='green'><span class=''> </span><code>         *          var user = new User();</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] an optional callback to be invoked when all models have been synced</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that will be resolved when the models have been synced.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        syncModels:function (cb) {</code></li>
<li class='green'><span class='hits'>35</span><code>            return model.syncModels(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        resetIdentifierMethods:function () {</code></li>
<li class='green'><span class='hits'>51</span><code>            this.quoteIdentifiers = true;</code></li>
<li class='green'><span class='hits'>51</span><code>            this.identifierOutputMethod = null;</code></li>
<li class='green'><span class='hits'>51</span><code>            this.identifierInputMethod = null;</code></li>
<li class='green'><span class='hits'>51</span><code>            Model.identifierOutputMethod = null;</code></li>
<li class='green'><span class='hits'>51</span><code>            Model.identifierInputMethod = null;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Migrates the database using migration files found in the supplied directory.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;br/&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;br/&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;div&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;h3&gt;Integer Migrations&lt;/h3&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      Integer migrations are the simpler of the two migrations but are less flexible than timestamp based migrations.</code></li>
<li class='green'><span class=''> </span><code>         *      In order for patio to determine which versions to use the file names must end in &lt;versionNumber&gt;.js where</code></li>
<li class='green'><span class=''> </span><code>         *      versionNumber is a integer value representing the version number. &lt;b&gt;NOTE:&lt;/b&gt;With integer migrations</code></li>
<li class='green'><span class=''> </span><code>         *      missing versions are not allowed.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;br/&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;br/&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      An example directory structure might look like the following:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         * -migrations</code></li>
<li class='green'><span class=''> </span><code>         *      - createFirstTables.0.js</code></li>
<li class='green'><span class=''> </span><code>         *      - shortDescription.1.js</code></li>
<li class='green'><span class=''> </span><code>         *      - another.2.js</code></li>
<li class='green'><span class=''> </span><code>         *      .</code></li>
<li class='green'><span class=''> </span><code>         *      .</code></li>
<li class='green'><span class=''> </span><code>         *      .</code></li>
<li class='green'><span class=''> </span><code>         *      -lastMigration.n.js</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      In order to easily identify where certain schema alterations have taken place it is a good idea to provide a brief</code></li>
<li class='green'><span class=''> </span><code>         *      but meaningful migration name.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          createEmployee.0.js</code></li>
<li class='green'><span class=''> </span><code>         *          alterEmployeeNameColumn.1.js</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *&lt;/div&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;div&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;h3&gt;Timestamp Migrations&lt;/h3&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      Timestamp migrations are the more complex of the two migrations but offer greater flexibility especially</code></li>
<li class='green'><span class=''> </span><code>         *      with development teams. This is because Timestamp migrations do not require consecutive version numbers,</code></li>
<li class='green'><span class=''> </span><code>         *      ,allow for duplicate version numbers(but this should be avoided), keeps track of all currently applied migrations,</code></li>
<li class='green'><span class=''> </span><code>         *      and it will merge missing migrations. In order for patio to determine the order of the migration files</code></li>
<li class='green'><span class=''> </span><code>         *      the file names must end in &lt;timestamp&gt;.js where the timestamp can be any form of a time stamp.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         * //yyyyMMdd</code></li>
<li class='green'><span class=''> </span><code>         * 20110131</code></li>
<li class='green'><span class=''> </span><code>         * //yyyyMMddHHmmss</code></li>
<li class='green'><span class=''> </span><code>         * 20110131123940</code></li>
<li class='green'><span class=''> </span><code>         * //unix epoch timestamp</code></li>
<li class='green'><span class=''> </span><code>         * 1328035161</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      as long as it is greater than 20000101 other wise it will be assumed to be part of an integer migration.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;br/&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;br/&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      An example directory structure might look like the following:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         * -migrations</code></li>
<li class='green'><span class=''> </span><code>         *      - createFirstTables.1328035161.js</code></li>
<li class='green'><span class=''> </span><code>         *      - shortDescription.1328035360.js</code></li>
<li class='green'><span class=''> </span><code>         *      - another.1328035376.js</code></li>
<li class='green'><span class=''> </span><code>         *      .</code></li>
<li class='green'><span class=''> </span><code>         *      .</code></li>
<li class='green'><span class=''> </span><code>         *      .</code></li>
<li class='green'><span class=''> </span><code>         *      -lastMigration.n.js</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      In order to easily identify where certain schema alterations have taken place it is a good idea to provide a brief</code></li>
<li class='green'><span class=''> </span><code>         *      but meaningful migration name.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          createEmployee.1328035161.js</code></li>
<li class='green'><span class=''> </span><code>         *          alterEmployeeNameColumn.1328035360.js</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *&lt;/div&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;NOTE:&lt;/b&gt;If you start with IntegerBased migrations and decide to transition to Timestamp migrations the</code></li>
<li class='green'><span class=''> </span><code>         * patio will attempt the migrate the current schema to the timestamp based migration schema.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;div&gt;</code></li>
<li class='green'><span class=''> </span><code>         * In order to run a migraton all one has to do is call patio.migrate(DB, directory, options);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  var DB = patio.connect("my://connection/string");</code></li>
<li class='green'><span class=''> </span><code>         *  patio.migrate(DB, __dirname + "/migrations").then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      console.log("migrations finished");</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;Example migration file&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //Up function used to migrate up a version</code></li>
<li class='green'><span class=''> </span><code>         * exports.up = function(db) {</code></li>
<li class='green'><span class=''> </span><code>         *   //create a new table</code></li>
<li class='green'><span class=''> </span><code>         *   db.createTable("company", function() {</code></li>
<li class='green'><span class=''> </span><code>         *       this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *       this.companyName(String, {size : 20, allowNull : false});</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *   db.createTable("employee", function(table) {</code></li>
<li class='green'><span class=''> </span><code>         *       this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *       this.firstName(String);</code></li>
<li class='green'><span class=''> </span><code>         *       this.lastName(String);</code></li>
<li class='green'><span class=''> </span><code>         *       this.middleInitial("char", {size : 1});</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *};</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //Down function used to migrate down version</code></li>
<li class='green'><span class=''> </span><code>         *exports.down = function(db) {</code></li>
<li class='green'><span class=''> </span><code>         *    db.dropTable("employee", "company");</code></li>
<li class='green'><span class=''> </span><code>         *};</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *&lt;/div&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.Database} db the database or connection string to a database to migrate.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} directory directory that the migration files reside in</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts={}] optional parameters.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.column] the column in the table that version information should be stored.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.table] the table that version information should be stored.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number} [opts.target] the target migration(i.e the migration to migrate up/down to).</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.current] the version that the database is currently at if the current version</code></li>
<li class='green'><span class=''> </span><code>         * is not provided it is retrieved from the database.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the migration is complete.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        migrate:function (db) {</code></li>
<li class='green'><span class='hits'>31</span><code>            db = isString(db) ? this.connect(db) : db;</code></li>
<li class='green'><span class='hits'>31</span><code>            var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>31</span><code>            args.splice(0, 1);</code></li>
<li class='green'><span class='hits'>31</span><code>            return migrate.run.apply(migrate, [db].concat(args));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This can be used to configure logging. If a options</code></li>
<li class='green'><span class=''> </span><code>         * hash is passed in then it will passed to the comb.logging.PropertyConfigurator.</code></li>
<li class='green'><span class=''> </span><code>         * If the options are omitted then a ConsoleAppender will be added and the level will</code></li>
<li class='green'><span class=''> </span><code>         * be set to info.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var config = {</code></li>
<li class='green'><span class=''> </span><code>         *     "patio" : {</code></li>
<li class='green'><span class=''> </span><code>         *         level : "INFO",</code></li>
<li class='green'><span class=''> </span><code>         *         appenders : [</code></li>
<li class='green'><span class=''> </span><code>         *             {</code></li>
<li class='green'><span class=''> </span><code>         *                 type : "RollingFileAppender",</code></li>
<li class='green'><span class=''> </span><code>         *                 file : "/var/log/patio.log",</code></li>
<li class='green'><span class=''> </span><code>         *             },</code></li>
<li class='green'><span class=''> </span><code>         *             {</code></li>
<li class='green'><span class=''> </span><code>         *                 type : "RollingFileAppender",</code></li>
<li class='green'><span class=''> </span><code>         *                 file : "/var/log/patio-error.log",</code></li>
<li class='green'><span class=''> </span><code>         *                 name : "errorFileAppender",</code></li>
<li class='green'><span class=''> </span><code>         *                 level : "ERROR"</code></li>
<li class='green'><span class=''> </span><code>         *             }</code></li>
<li class='green'><span class=''> </span><code>         *         ]</code></li>
<li class='green'><span class=''> </span><code>         * };</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.configureLogging(config);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param opts</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        configureLogging:function (opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            comb.logger.configure(opts);</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (!opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                LOGGER.level = "info";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs an INFO level message to the "patio" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logInfo:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (LOGGER.isInfo) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                LOGGER.info.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a DEBUG level message to the "patio" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logDebug:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (LOGGER.isDebug) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                LOGGER.debug.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs an ERROR level message to the "patio" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logError:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (LOGGER.isError) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                LOGGER.error.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a WARN level message to the "patio" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logWarn:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (LOGGER.isWarn) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                LOGGER.warn.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a TRACE level message to the "patio" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logTrace:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (LOGGER.isTrace) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                LOGGER.trace.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a FATAL level message to the "patio" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logFatal:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (LOGGER.isFatal) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                LOGGER.fatal.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.prototype*/</code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * An array of databases that are currently connected.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type patio.Database[]</code></li>
<li class='green'><span class=''> </span><code>             * @default []</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            DATABASES:function () {</code></li>
<li class='green'><span class='hits'>733</span><code>                return Database.DATABASES;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Returns the default database. This is the first database created using {@link patio#connect}.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type patio.Database</code></li>
<li class='green'><span class=''> </span><code>             * @default null</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            defaultDatabase:function () {</code></li>
<li class='green'><span class='hits'>392</span><code>                return this.DATABASES.length ? this.DATABASES[0] : null;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            Database:function () {</code></li>
<li class='green'><span class='hits'>9</span><code>                return Database;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            Dataset:function () {</code></li>
<li class='green'><span class='hits'>57</span><code>                return Dataset;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            SQL:function () {</code></li>
<li class='green'><span class='hits'>25</span><code>                return SQL;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            sql:function () {</code></li>
<li class='green'><span class='hits'>8</span><code>                return SQL;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            plugins:function () {</code></li>
<li class='green'><span class='hits'>7</span><code>                return plugins;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            migrations:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return migrate;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Returns the root comb logger using this logger you</code></li>
<li class='green'><span class=''> </span><code>             * can set the levels add appenders etc.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @type Logger</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @default comb.logger("patio")</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            LOGGER:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return LOGGER;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Returns the default method used to transform identifiers sent to the database.</code></li>
<li class='green'><span class=''> </span><code>             * See (@link patio.Database.identifierInputMethod}</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             * @default Database.identifierInputMethod</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                return Database.identifierInputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Returns the default method used to transform identifiers returned from the database.</code></li>
<li class='green'><span class=''> </span><code>             * See (@link patio.Database.identifierOutputMethod}</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                return Database.identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             * Returns whether or not identifiers are quoted before being sent to the database.</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function (value) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return Database.quoteIdentifiers;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            camelize:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.__camelize;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            underscore:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.__underscore;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.prototype*/</code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Set the method to call on identifiers going into the database.  This affects</code></li>
<li class='green'><span class=''> </span><code>             * how identifiers are sent to the database. So if you use camelCased and the db identifiers are all underscored</code></li>
<li class='green'><span class=''> </span><code>             * use camelize. The method can include</code></li>
<li class='green'><span class=''> </span><code>             * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;toUpperCase&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;toLowerCase&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;camelize&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;underscore&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;Other String instance method names.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * patio uses toUpperCase identifiers in all SQL strings for most databases.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @example</code></li>
<li class='green'><span class=''> </span><code>             *  //use whatever is passed in</code></li>
<li class='green'><span class=''> </span><code>             *   patio.identifierInputMethod = null;</code></li>
<li class='green'><span class=''> </span><code>             *  //convert to uppercase</code></li>
<li class='green'><span class=''> </span><code>             *  patio.identifierInputMethod = "toUpperCase";</code></li>
<li class='green'><span class=''> </span><code>             *  //convert to camelCase</code></li>
<li class='green'><span class=''> </span><code>             *  patio.identifierInputMethod = "camelize";</code></li>
<li class='green'><span class=''> </span><code>             *  //convert to underscore</code></li>
<li class='green'><span class=''> </span><code>             *  patio.identifierInputMethod = "underscore";</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function (value) {</code></li>
<li class='green'><span class='hits'>79</span><code>                Database.identifierInputMethod = value;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Set the method to call on identifiers coming out of the database.  This affects</code></li>
<li class='green'><span class=''> </span><code>             * the how identifiers are represented by calling the method on them.</code></li>
<li class='green'><span class=''> </span><code>             * The method can include</code></li>
<li class='green'><span class=''> </span><code>             * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;toUpperCase&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;toLowerCase&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;camelize&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;underscore&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     &lt;li&gt;Other String instance method names.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>             * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>             * most database implementations in patio use toLowerCase</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             * @example</code></li>
<li class='green'><span class=''> </span><code>             *  //use whatever the db returns</code></li>
<li class='green'><span class=''> </span><code>             *   patio.identifierOutputMethod = null;</code></li>
<li class='green'><span class=''> </span><code>             *  //convert to uppercase</code></li>
<li class='green'><span class=''> </span><code>             *  patio.identifierOutputMethod = "toUpperCase";</code></li>
<li class='green'><span class=''> </span><code>             *  //convert to camelCase</code></li>
<li class='green'><span class=''> </span><code>             *  patio.identifierOutputMethod = "camelize";</code></li>
<li class='green'><span class=''> </span><code>             *  //convert to underscore</code></li>
<li class='green'><span class=''> </span><code>             *  patio.identifierOutputMethod = "underscore";</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function (value) {</code></li>
<li class='green'><span class='hits'>79</span><code>                Database.identifierOutputMethod = value;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Set whether to quote identifiers for all databases by default. By default,</code></li>
<li class='green'><span class=''> </span><code>             * patio quotes identifiers in all SQL strings.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @example</code></li>
<li class='green'><span class=''> </span><code>             *   //Turn quoting off</code></li>
<li class='green'><span class=''> </span><code>             *   patio.quoteIdentifiers = false</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function (value) {</code></li>
<li class='green'><span class='hits'>81</span><code>                Database.quoteIdentifiers = value;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Sets the whether or not to camelize identifiers coming from the database and to underscore</code></li>
<li class='green'><span class=''> </span><code>             * identifiers when sending identifiers to the database. Setting this property to true has the same effect</code></li>
<li class='green'><span class=''> </span><code>             * as:</code></li>
<li class='green'><span class=''> </span><code>             * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     patio.identifierOutputMethod = "camelize";</code></li>
<li class='green'><span class=''> </span><code>             *     patio.identifierInputMethod = "underscore";</code></li>
<li class='green'><span class=''> </span><code>             * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @example</code></li>
<li class='green'><span class=''> </span><code>             * patio.camelize = true;</code></li>
<li class='green'><span class=''> </span><code>             * patio.connectAndExecute("mysql://test:testpass@localhost:3306/airports", function (db) {</code></li>
<li class='green'><span class=''> </span><code>             *      db.createTable("airport", function () {</code></li>
<li class='green'><span class=''> </span><code>             *          this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>             *          this.airportCode(String, {size:4, allowNull:false, unique:true});</code></li>
<li class='green'><span class=''> </span><code>             *          this.name(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>             *          this.city(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>             *          this.state(String, {size:2, allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>             *      });</code></li>
<li class='green'><span class=''> </span><code>             *      //=&gt; CREATE TABLE `airport`(</code></li>
<li class='green'><span class=''> </span><code>             *      //    id integer PRIMARY KEY AUTO_INCREMENT,</code></li>
<li class='green'><span class=''> </span><code>             *      //    airport_code varchar(4) UNIQUE NOT NULL,</code></li>
<li class='green'><span class=''> </span><code>             *      //    name varchar(255) NOT NULL,</code></li>
<li class='green'><span class=''> </span><code>             *      //    city varchar(255) NOT NULL,</code></li>
<li class='green'><span class=''> </span><code>             *      //    state varchar(2) NOT NULL</code></li>
<li class='green'><span class=''> </span><code>             *      //);</code></li>
<li class='green'><span class=''> </span><code>             *  }):</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @param {Boolean} camelize set to true to camelize all identifiers coming from the database and to</code></li>
<li class='green'><span class=''> </span><code>             *                  underscore all identifiers sent to the database.</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            camelize:function (camelize) {</code></li>
<li class='green'><span class='hits'>21</span><code>                camelize = camelize === true;</code></li>
<li class='green'><span class='hits'>21</span><code>                Model.camelize = camelize;</code></li>
<li class='green'><span class='hits'>21</span><code>                this.identifierOutputMethod = camelize ? "camelize" : "underscore";</code></li>
<li class='green'><span class='hits'>21</span><code>                this.identifierInputMethod = camelize ? "underscore" : "camelize";</code></li>
<li class='green'><span class='hits'>21</span><code>                this.__underscore = !camelize;</code></li>
<li class='green'><span class='hits'>21</span><code>                this.__camelize = camelize;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Sets the whether or not to underscore identifiers coming from the database and to camelize</code></li>
<li class='green'><span class=''> </span><code>             * identifiers when sending identifiers to the database. Setting this property to true has the same effect</code></li>
<li class='green'><span class=''> </span><code>             * as:</code></li>
<li class='green'><span class=''> </span><code>             * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>             *     patio.identifierOutputMethod = "underscore";</code></li>
<li class='green'><span class=''> </span><code>             *     patio.identifierInputMethod = "camelize";</code></li>
<li class='green'><span class=''> </span><code>             * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @example</code></li>
<li class='green'><span class=''> </span><code>             * patio.camelize = true;</code></li>
<li class='green'><span class=''> </span><code>             * patio.connectAndExecute("mysql://test:testpass@localhost:3306/airports", function (db) {</code></li>
<li class='green'><span class=''> </span><code>             *      db.createTable("airport", function () {</code></li>
<li class='green'><span class=''> </span><code>             *          this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>             *          this.airport_code(String, {size:4, allowNull:false, unique:true});</code></li>
<li class='green'><span class=''> </span><code>             *          this.name(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>             *          this.city(String, {allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>             *          this.state(String, {size:2, allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>             *      });</code></li>
<li class='green'><span class=''> </span><code>             *      //=&gt; CREATE TABLE `airport`(</code></li>
<li class='green'><span class=''> </span><code>             *      //    id integer PRIMARY KEY AUTO_INCREMENT,</code></li>
<li class='green'><span class=''> </span><code>             *      //    airportCode varchar(4) UNIQUE NOT NULL,</code></li>
<li class='green'><span class=''> </span><code>             *      //    name varchar(255) NOT NULL,</code></li>
<li class='green'><span class=''> </span><code>             *      //    city varchar(255) NOT NULL,</code></li>
<li class='green'><span class=''> </span><code>             *      //    state varchar(2) NOT NULL</code></li>
<li class='green'><span class=''> </span><code>             *      //);</code></li>
<li class='green'><span class=''> </span><code>             *  }):</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @param {Boolean} camelize set to true to underscore all identifiers coming from the database and to</code></li>
<li class='green'><span class=''> </span><code>             *                  camelize all identifiers sent to the database.</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            underscore:function (underscore) {</code></li>
<li class='green'><span class='hits'>1</span><code>                underscore = underscore === true;</code></li>
<li class='green'><span class='hits'>1</span><code>                Model.underscore = underscore;</code></li>
<li class='green'><span class='hits'>1</span><code>                this.identifierOutputMethod = underscore ? "underscore" : "camelize";</code></li>
<li class='green'><span class='hits'>1</span><code>                this.identifierInputMethod = underscore ? "camelize" : "underscore";</code></li>
<li class='green'><span class='hits'>1</span><code>                this.__camelize = !underscore;</code></li>
<li class='green'><span class='hits'>1</span><code>                this.__underscore = underscore;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var patio = exports;</code></li>
<li class='green'><span class='hits'>1</span><code>module.exports = patio = new Patio();</code></li>
<li class='green'><span class='hits'>1</span><code>patio.__Patio = Patio;</code></li>
<li class='green'><span class='hits'>1</span><code>var adapters = Database.ADAPTERS;</code></li>
<li class='green'><span class='hits'>1</span><code>for (var i in adapters) {</code></li>
<li class='green'><span class='hits'>3</span><code>    patio[i] = adapters[i];</code></li>
<li class='green'><span class=''> </span><code>}</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-low" id="adapters/postgres.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>adapters/postgres.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>73.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>824</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>300</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>81</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="adapters/postgres.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var pg = require("pg"),</code></li>
<li class='green'><span class=''> </span><code>    PgTypes = require("pg/lib/types"),</code></li>
<li class='green'><span class=''> </span><code>    StringDecoder = require("string_decoder").StringDecoder,</code></li>
<li class='green'><span class=''> </span><code>    comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    asyncArray = comb.async.array,</code></li>
<li class='green'><span class=''> </span><code>    string = comb.string,</code></li>
<li class='green'><span class=''> </span><code>    pad = string.pad,</code></li>
<li class='green'><span class=''> </span><code>    format = string.format,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    toArray = array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    zip = array.zip,</code></li>
<li class='green'><span class=''> </span><code>    flatten = array.flatten,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isObject = comb.isObject,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    isDefined = comb.isDefined,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    QueryError = require("../errors").QueryError,</code></li>
<li class='green'><span class=''> </span><code>    Dataset = require("../dataset"),</code></li>
<li class='green'><span class=''> </span><code>    Database = require("../database"),</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    stringToIdentifier = sql.stringToIdentifier,</code></li>
<li class='green'><span class=''> </span><code>    DateTime = sql.DateTime,</code></li>
<li class='green'><span class=''> </span><code>    Time = sql.Time,</code></li>
<li class='green'><span class=''> </span><code>    Year = sql.Year,</code></li>
<li class='green'><span class=''> </span><code>    literal = sql.literal,</code></li>
<li class='green'><span class=''> </span><code>    StringExpression = sql.StringExpression,</code></li>
<li class='green'><span class=''> </span><code>    Double = sql.Double,</code></li>
<li class='green'><span class=''> </span><code>    identifier = sql.identifier,</code></li>
<li class='green'><span class=''> </span><code>    BooleanExpression = sql.BooleanExpression,</code></li>
<li class='green'><span class=''> </span><code>    LiteralString = sql.LiteralString,</code></li>
<li class='green'><span class=''> </span><code>    Subscript = sql.Subscript,</code></li>
<li class='green'><span class=''> </span><code>    patio;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var getPatio = function () {</code></li>
<li class='green'><span class='hits'>42</span><code>    return patio || (patio = require("../index.js"));</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var isBlank = function (obj) {</code></li>
<li class='green'><span class='hits'>374</span><code>    var ret = false;</code></li>
<li class='green'><span class='hits'>374</span><code>    if (isUndefinedOrNull(obj)) {</code></li>
<li class='green'><span class='hits'>313</span><code>        ret = true;</code></li>
<li class='green'><span class='hits'>61</span><code>    } else if (isString(obj) || isArray(obj)) {</code></li>
<li class='green'><span class='hits'>61</span><code>        ret = obj.length === 0;</code></li>
<li class='red'><span class='nohits'>0</span><code>    } else if (isBoolean(obj) &amp;&amp; !obj) {</code></li>
<li class='red'><span class='nohits'>0</span><code>        ret = true;</code></li>
<li class='red'><span class='nohits'>0</span><code>    } else if (isObject(obj) &amp;&amp; isEmpty(obj)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>        ret = true;</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>374</span><code>    return ret;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var byteaParser = function (val) {</code></li>
<li class='green'><span class='hits'>12</span><code>    if (val.toString().indexOf("\\x") === 0) {</code></li>
<li class='green'><span class='hits'>12</span><code>        val = val.toString().replace(/^\\x/, "");</code></li>
<li class='green'><span class='hits'>12</span><code>        return new Buffer(val, "hex");</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>        val = val.toString().replace(/\\([0-7]{3})/g,function (full_match, code) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return String.fromCharCode(parseInt(code, 8));</code></li>
<li class='green'><span class=''> </span><code>        }).replace(/\\\\/g, "\\");</code></li>
<li class='red'><span class='nohits'>0</span><code>        return new Buffer(val, "binary");</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>PgTypes.setTypeParser(17, "text", byteaParser);</code></li>
<li class='green'><span class='hits'>1</span><code>var timestampOrig = PgTypes.getTypeParser(1114, "text");</code></li>
<li class='green'><span class=''> </span><code>//PgTypes.setTypeParser(25, "text", byteaParser);</code></li>
<li class='green'><span class='hits'>1</span><code>PgTypes.setTypeParser(1114, "text", function (val) {</code></li>
<li class='green'><span class='hits'>38</span><code>    val = String(val);</code></li>
<li class='green'><span class='hits'>38</span><code>    if (!val.match(/\.(\d{0,3})/)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>        val += ".000";</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='green'><span class='hits'>38</span><code>        val = val.replace(/\.(\d{0,3})$/, function (m, m1) {</code></li>
<li class='green'><span class='hits'>38</span><code>            return "." + pad(m1, 3, "0", true);</code></li>
<li class='green'><span class=''> </span><code>        });</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>38</span><code>    return getPatio().stringToTimeStamp(val.toString(), DS.TIMESTAMP_FORMAT).date;</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class='hits'>1</span><code>PgTypes.setTypeParser(1184, "text", function (val) {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return getPatio().stringToDate(val.toString());</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>PgTypes.setTypeParser(1082, "text", function (val) {</code></li>
<li class='green'><span class='hits'>4</span><code>    return getPatio().stringToDate(val.toString());</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>PgTypes.setTypeParser(1083, "text", function (val) {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return getPatio().stringToTime(val.toString(), DS.TIME_FORMAT);</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Connection = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        connection:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function (conn) {</code></li>
<li class='green'><span class='hits'>64</span><code>            this.connection = conn;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        closeConnection:function () {</code></li>
<li class='green'><span class='hits'>64</span><code>            this.connection.end();</code></li>
<li class='green'><span class='hits'>64</span><code>            return new Promise().callback().promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        query:function (query) {</code></li>
<li class='green'><span class='hits'>7547</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>7547</span><code>            try {</code></li>
<li class='green'><span class='hits'>7547</span><code>                this.connection.setMaxListeners(0);</code></li>
<li class='green'><span class='hits'>7547</span><code>                var fields = [];</code></li>
<li class='green'><span class='hits'>7547</span><code>                var q = this.connection.query(query, hitch(this, function (err, results) {</code></li>
<li class='green'><span class='hits'>7547</span><code>                    q.handleRowDescription = orig;</code></li>
<li class='green'><span class='hits'>7547</span><code>                    if (err) {</code></li>
<li class='green'><span class='hits'>71</span><code>                        return ret.errback(err);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>7476</span><code>                        return ret.callback(results.rows, fields);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class='hits'>7547</span><code>                var orig = q.handleRowDescription;</code></li>
<li class='green'><span class='hits'>7547</span><code>                q.handleRowDescription = function (msg) {</code></li>
<li class='green'><span class='hits'>4352</span><code>                    fields = msg.fields;</code></li>
<li class='green'><span class='hits'>4352</span><code>                    return orig.apply(q, arguments);</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code>            } catch (e) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                patio.logError(e);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>7547</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var DS = define(Dataset, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        complexExpressionSql:function (op, args) {</code></li>
<li class='green'><span class='hits'>5961</span><code>            var ret = "";</code></li>
<li class='green'><span class='hits'>5961</span><code>            if (op === "^") {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var j = this._static.XOR_OP, c = false;</code></li>
<li class='red'><span class='nohits'>0</span><code>                args.forEach(function (a) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (c) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret += j;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret += this.literal(a);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    c = true;</code></li>
<li class='green'><span class=''> </span><code>                }, true);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>5961</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        forShare:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.lockStyle("share");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        fullTextSearch:function (cols, terms, opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>3</span><code>            var lang = opts.language || 'simple';</code></li>
<li class='green'><span class='hits'>3</span><code>            if (Array.isArray(terms)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                terms = terms.join(' | ');</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.filter("to_tsvector(?, ?) @@ to_tsquery(?, ?)", lang, this.__fullTextStringJoin(toArray(cols).map(function (c) {</code></li>
<li class='green'><span class='hits'>4</span><code>                return stringToIdentifier(c);</code></li>
<li class='green'><span class=''> </span><code>            })), lang, terms);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Lock all tables in the datasets from clause (but not in JOINs), in the specified mode. If</code></li>
<li class='green'><span class=''> </span><code>         * a function is passed in as the last argument</code></li>
<li class='green'><span class=''> </span><code>         * @para {String} mode the lock mode (e.g. 'EXCLUSIVE').</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] see {@link patio.Database#transaction} for options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] of provided then a new {@link patio.Database} transaction is started.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        lock:function (mode, opts, cb) {</code></li>
<li class='green'><span class='hits'>3</span><code>            if (isFunction(opts)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                cb = opts;</code></li>
<li class='green'><span class='hits'>1</span><code>                opts = null;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                opts = opts || {};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3</span><code>            if (isFunction(cb)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.db.transaction(opts, function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                    return serial([</code></li>
<li class='green'><span class=''> </span><code>                        this.lock.bind(this, mode, opts),</code></li>
<li class='green'><span class=''> </span><code>                        cb.bind(this)</code></li>
<li class='green'><span class=''> </span><code>                    ]);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                return this.db.execute(format(this._static.LOCK, [this._sourceList(this.__opts.from), mode]), opts);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        multiInsertSql:function (columns, values) {</code></li>
<li class='green'><span class='hits'>1</span><code>            var ret = literal('VALUES ');</code></li>
<li class='green'><span class='hits'>1</span><code>            ret += this.__expressionList(values.map(function (r) {</code></li>
<li class='green'><span class='hits'>2</span><code>                return toArray(r);</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class='hits'>1</span><code>            return [this.insertSql(columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>2</span><code>                return stringToIdentifier(c);</code></li>
<li class='green'><span class=''> </span><code>            }), literal(ret))];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _deleteFromSql:function () {</code></li>
<li class='green'><span class='hits'>927</span><code>            var self = this._static, space = self.SPACE;</code></li>
<li class='green'><span class='hits'>927</span><code>            return [space, self.FROM, space, this._sourceList(this.__opts.from[0])].join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _deleteUsingSql:function () {</code></li>
<li class='green'><span class='hits'>927</span><code>            return this._joinFromSql("USING");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _joinFromSql:function (type) {</code></li>
<li class='green'><span class='hits'>1133</span><code>            var from = this.__opts.from.slice(1), join = this.__opts.join, ret = "";</code></li>
<li class='green'><span class='hits'>1133</span><code>            if (!from.length) {</code></li>
<li class='green'><span class='hits'>1133</span><code>                if (!isEmpty(join)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new QueryError("Need multiple FROM tables if updating/deleteing a dataset with joins");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var space = this._static.SPACE;</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = [space, type.toString(), space, this._sourceList(from), this._selectJoinSql()].join("");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1133</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _selectLockSql:function () {</code></li>
<li class='green'><span class='hits'>3061</span><code>            if (this.__opts.lock === "share") {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this._static.FOR_SHARE;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3061</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _selectWithSql:function () {</code></li>
<li class='green'><span class='hits'>5512</span><code>            var optsWith = this.__opts["with"];</code></li>
<li class='green'><span class='hits'>5512</span><code>            if (!isEmpty(optsWith) &amp;&amp; optsWith.some(function (w) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return w.recursive;</code></li>
<li class='green'><span class=''> </span><code>            })) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this._static.SQL_WITH_RECURSIVE;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>5512</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _updateFromSql:function () {</code></li>
<li class='green'><span class='hits'>206</span><code>            return this._joinFromSql("FROM");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _updateTableSql:function () {</code></li>
<li class='green'><span class='hits'>206</span><code>            return [this._static.SPACE, this._sourceList(this.__opts.from.slice(0, 1))].join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _quotedIdentifier:function (c) {</code></li>
<li class='green'><span class='hits'>25409</span><code>            return format('"%s"', c);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __fullTextStringJoin:function (cols) {</code></li>
<li class='green'><span class='hits'>5</span><code>            var EMPTY_STRING = this._static.EMPTY_STRING;</code></li>
<li class='green'><span class='hits'>5</span><code>            cols = toArray(cols).map(function (x) {</code></li>
<li class='green'><span class='hits'>7</span><code>                return  sql.COALESCE(x, EMPTY_STRING);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>5</span><code>            cols = flatten(zip(cols, array.multiply([this._static.SPACE], cols.length)));</code></li>
<li class='green'><span class='hits'>5</span><code>            cols.pop();</code></li>
<li class='green'><span class='hits'>5</span><code>            return StringExpression.fromArgs(['||'].concat(cols));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        insert:function () {</code></li>
<li class='green'><span class='hits'>2622</span><code>            var args = arguments;</code></li>
<li class='green'><span class='hits'>2622</span><code>            if (this.__opts.returning) {</code></li>
<li class='green'><span class='hits'>1311</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1311</span><code>                var ret = new Promise();</code></li>
<li class='green'><span class='hits'>1311</span><code>                this.primaryKey(this.__opts.from).then(function (res) {</code></li>
<li class='green'><span class='hits'>1311</span><code>                    var pks = res.map(function (r) {</code></li>
<li class='green'><span class='hits'>1145</span><code>                        return r.name;</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class='hits'>1311</span><code>                    var ds = this.returning.apply(this, pks);</code></li>
<li class='green'><span class='hits'>1311</span><code>                    var dsPromise = ds.insert.apply(ds, args), l = res.length;</code></li>
<li class='green'><span class='hits'>1311</span><code>                    if (l) {</code></li>
<li class='green'><span class='hits'>1145</span><code>                        dsPromise.then(function (insertRes) {</code></li>
<li class='green'><span class='hits'>1145</span><code>                            if (l === 1) {</code></li>
<li class='green'><span class='hits'>1145</span><code>                                ret.callback(insertRes.map(function (i) {</code></li>
<li class='green'><span class='hits'>1145</span><code>                                    return i[pks[0]];</code></li>
<li class='green'><span class=''> </span><code>                                }).pop());</code></li>
<li class='green'><span class=''> </span><code>                            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                                ret.callback(insertRes.pop());</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                        }, ret);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>166</span><code>                        dsPromise.then(ret);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }.bind(this), ret);</code></li>
<li class='green'><span class='hits'>1311</span><code>                return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        primaryKey:function () {</code></li>
<li class='green'><span class='hits'>1311</span><code>            return this.db.primaryKey(this.__opts.from[0]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        fetchRows:function (sql) {</code></li>
<li class='green'><span class='hits'>3041</span><code>            var oi = this.outputIdentifier.bind(this);</code></li>
<li class='green'><span class='hits'>3041</span><code>            return asyncArray(this.execute(sql).chain(function (rows, fields) {</code></li>
<li class='green'><span class='hits'>3041</span><code>                var cols = [];</code></li>
<li class='green'><span class='hits'>3041</span><code>                if (rows &amp;&amp; rows.length) {</code></li>
<li class='green'><span class='hits'>2548</span><code>                    cols = this.__columns = fields &amp;&amp; fields.length ? fields.map(function (f) {</code></li>
<li class='green'><span class='hits'>19133</span><code>                        return f.name;</code></li>
<li class='green'><span class=''> </span><code>                    }) : Object.keys(rows[0]);</code></li>
<li class='green'><span class=''> </span><code>                    //the pg driver does auto type coercion</code></li>
<li class='green'><span class='hits'>2548</span><code>                    cols = cols.map(function (c) {</code></li>
<li class='green'><span class='hits'>19133</span><code>                        return [oi(c), function (o) {</code></li>
<li class='green'><span class='hits'>28631</span><code>                            return o;</code></li>
<li class='green'><span class=''> </span><code>                        }, c];</code></li>
<li class='green'><span class=''> </span><code>                    }, this);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>3041</span><code>                return this.__processRows(rows, cols);</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __processRows:function (rows, cols) {</code></li>
<li class='green'><span class=''> </span><code>            //dp this so the callbacks are called in appropriate order also.</code></li>
<li class='green'><span class='hits'>3041</span><code>            return comb(rows).map(function (row, i) {</code></li>
<li class='green'><span class='hits'>3659</span><code>                var h = {};</code></li>
<li class='green'><span class='hits'>3659</span><code>                cols.forEach(function (col) {</code></li>
<li class='green'><span class='hits'>28631</span><code>                    h[col[0]] = col[1](row[col[2]]);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>3659</span><code>                return h;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _literalTimestamp:function (v) {</code></li>
<li class='green'><span class='hits'>28</span><code>            return this.literal(literal("TIMESTAMP " + this._super(arguments) + ""));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _literalBuffer:function (b) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return this.literal(literal("decode('" + b.toString("hex") + "', 'hex')"));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            columns:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>                var ret = new Promise();</code></li>
<li class='green'><span class='hits'>6</span><code>                if (this.__columns) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret.callback(this.__columns);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>6</span><code>                    this.db.schema(this.firstSourceTable).then(function (schema) {</code></li>
<li class='green'><span class='hits'>6</span><code>                        this.__columns = schema ? Object.keys(schema) : [];</code></li>
<li class='green'><span class='hits'>6</span><code>                        ret.callback(this.__columns);</code></li>
<li class='green'><span class=''> </span><code>                    }, ret);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>6</span><code>                return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsCteInSubqueries:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return true;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsDistinctOn:function () {</code></li>
<li class='green'><span class='hits'>12646</span><code>                return true;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsModifyingJoins:function () {</code></li>
<li class='green'><span class='hits'>15122</span><code>                return true;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsTimestampTimezones:function () {</code></li>
<li class='green'><span class='hits'>12644</span><code>                return true;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        ACCESS_SHARE:'ACCESS SHARE',</code></li>
<li class='green'><span class=''> </span><code>        ACCESS_EXCLUSIVE:'ACCESS EXCLUSIVE',</code></li>
<li class='green'><span class=''> </span><code>        BOOL_FALSE:'false',</code></li>
<li class='green'><span class=''> </span><code>        BOOL_TRUE:'true',</code></li>
<li class='green'><span class=''> </span><code>        COMMA_SEPARATOR:', ',</code></li>
<li class='green'><span class=''> </span><code>        DELETE_CLAUSE_METHODS:Dataset.clauseMethods("delete", 'qualify with from using where returning'),</code></li>
<li class='green'><span class=''> </span><code>        EXCLUSIVE:'EXCLUSIVE',</code></li>
<li class='green'><span class=''> </span><code>        EXPLAIN:'EXPLAIN ',</code></li>
<li class='green'><span class=''> </span><code>        EXPLAIN_ANALYZE:'EXPLAIN ANALYZE ',</code></li>
<li class='green'><span class=''> </span><code>        FOR_SHARE:' FOR SHARE',</code></li>
<li class='green'><span class=''> </span><code>        INSERT_CLAUSE_METHODS:Dataset.clauseMethods("insert", 'with into columns values returning'),</code></li>
<li class='green'><span class=''> </span><code>        LOCK:'LOCK TABLE %s IN %s MODE',</code></li>
<li class='green'><span class=''> </span><code>        NULL:literal('NULL'),</code></li>
<li class='green'><span class=''> </span><code>        QUERY_PLAN:'QUERY PLAN',</code></li>
<li class='green'><span class=''> </span><code>        ROW_EXCLUSIVE:'ROW EXCLUSIVE',</code></li>
<li class='green'><span class=''> </span><code>        ROW_SHARE:'ROW SHARE',</code></li>
<li class='green'><span class=''> </span><code>        SELECT_CLAUSE_METHODS:Dataset.clauseMethods("select", '' +</code></li>
<li class='green'><span class=''> </span><code>            'qualify with distinct columns from join where group having compounds order limit lock'),</code></li>
<li class='green'><span class=''> </span><code>        SHARE:'SHARE',</code></li>
<li class='green'><span class=''> </span><code>        SHARE_ROW_EXCLUSIVE:'SHARE ROW EXCLUSIVE',</code></li>
<li class='green'><span class=''> </span><code>        SHARE_UPDATE_EXCLUSIVE:'SHARE UPDATE EXCLUSIVE',</code></li>
<li class='green'><span class=''> </span><code>        SQL_WITH_RECURSIVE:"WITH RECURSIVE ",</code></li>
<li class='green'><span class=''> </span><code>        TIMESTAMP_FORMAT:"yyyy-MM-dd HH:mm:ss.SSS",</code></li>
<li class='green'><span class=''> </span><code>        TIME_FORMAT:"HH:mm:ss.SSS",</code></li>
<li class='green'><span class=''> </span><code>        UPDATE_CLAUSE_METHODS:Dataset.clauseMethods("update", 'with table set from where returning'),</code></li>
<li class='green'><span class=''> </span><code>        XOR_OP:' # ',</code></li>
<li class='green'><span class=''> </span><code>        CRLF:"\r\n",</code></li>
<li class='green'><span class=''> </span><code>        BLOB_RE:/[\000-\037\047\134\177-\377]/,</code></li>
<li class='green'><span class=''> </span><code>        WINDOW:" WINDOW ",</code></li>
<li class='green'><span class=''> </span><code>        EMPTY_STRING:literal("''")</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var DB = define(Database, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        EXCLUDE_SCHEMAS:/pg_*|information_schema/i,</code></li>
<li class='green'><span class=''> </span><code>        PREsPARED_ARG_PLACEHOLDER:new LiteralString('$'),</code></li>
<li class='green'><span class=''> </span><code>        RE_CURRVAL_ERROR:/currval of sequence "(.*)" is not yet defined in this session|relation "(.*)" does not exist/,</code></li>
<li class='green'><span class=''> </span><code>        SYSTEM_TABLE_REGEXP:/^pg|sql/,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        type:"postgres",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>34</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>34</span><code>            this.__primaryKeys = {};</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        createConnection:function (opts) {</code></li>
<li class='green'><span class='hits'>64</span><code>            delete opts.query;</code></li>
<li class='green'><span class='hits'>64</span><code>            var conn = new pg.Client(merge({}, opts, {typeCast:false}));</code></li>
<li class='green'><span class='hits'>64</span><code>            conn.connect();</code></li>
<li class='green'><span class=''> </span><code>            //conn.useDatabase(opts.database)</code></li>
<li class='green'><span class='hits'>64</span><code>            return new Connection(conn);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        closeConnection:function (conn) {</code></li>
<li class='green'><span class='hits'>64</span><code>            return conn.closeConnection();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        validate:function (conn) {</code></li>
<li class='green'><span class='hits'>2175</span><code>            return new Promise().callback(true).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        execute:function (sql, opts, conn) {</code></li>
<li class='green'><span class='hits'>5759</span><code>            return when(conn || this._getConnection())</code></li>
<li class='green'><span class=''> </span><code>                .chain(function (conn) {</code></li>
<li class='green'><span class='hits'>5759</span><code>                return this.__execute(conn, sql, opts);</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __execute:function (conn, sql, opts, cb) {</code></li>
<li class='green'><span class='hits'>5759</span><code>            return this.__logAndExecute(sql, comb("query").bindIgnore(conn, sql))</code></li>
<li class='green'><span class=''> </span><code>                .both(comb("_returnConnection").bindIgnore(this, conn));</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Use the pg_* system tables to determine indexes on a table</code></li>
<li class='green'><span class=''> </span><code>        indexes:function (table, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            opts = opts || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            var m = this.outputIdentifierFunc;</code></li>
<li class='red'><span class='nohits'>0</span><code>            var im = this.inputIdentifierFunc;</code></li>
<li class='red'><span class='nohits'>0</span><code>            var parts = this.__schemaAndTable(table), schema = parts[0];</code></li>
<li class='red'><span class='nohits'>0</span><code>            table = parts[1];</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ret = new Promise();</code></li>
<li class='red'><span class='nohits'>0</span><code>            when(this.serverVersion()).then(function (version) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var attNums;</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (version &gt;= 80100) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    attNums = sql.ANY("ind__indkey");</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    attNums = [];</code></li>
<li class='red'><span class='nohits'>0</span><code>                    for (var i = 0; i &lt; 32; i++) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        attNums.push(Subscript("ind__indkey", [i]));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>                var orderRange = [];</code></li>
<li class='red'><span class='nohits'>0</span><code>                for (var j = 0; j &lt; 32; j++) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    orderRange.push(new Subscript("ind__indkey", [j]));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>                orderRange = sql["case"](orderRange, 32, "att__attnum");</code></li>
<li class='red'><span class='nohits'>0</span><code>                var ds = this.metadataDataset.from("pg_class___tab")</code></li>
<li class='green'><span class=''> </span><code>                    .join("pg_index___ind", [</code></li>
<li class='green'><span class=''> </span><code>                    [identifier("indrelid"), identifier("oid")],</code></li>
<li class='green'><span class=''> </span><code>                    [im(table), "relname"]</code></li>
<li class='green'><span class=''> </span><code>                ])</code></li>
<li class='green'><span class=''> </span><code>                    .join("pg_class___indc", [</code></li>
<li class='green'><span class=''> </span><code>                    [identifier("oid"), identifier("indexrelid")]</code></li>
<li class='green'><span class=''> </span><code>                ])</code></li>
<li class='green'><span class=''> </span><code>                    .join("pg_attribute___att", [</code></li>
<li class='green'><span class=''> </span><code>                    [identifier("attrelid"), identifier("tab__oid")],</code></li>
<li class='green'><span class=''> </span><code>                    [identifier("attnum"), attNums]</code></li>
<li class='green'><span class=''> </span><code>                ])</code></li>
<li class='green'><span class=''> </span><code>                    .filter({indc__relkind:'i', ind__indisprimary:false, indexprs:null, indpred:null})</code></li>
<li class='green'><span class=''> </span><code>                    .order("indc__relname", orderRange)</code></li>
<li class='green'><span class=''> </span><code>                    .select("indc__relname___name", "ind__indisunique___unique", "att__attname___column");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='red'><span class='nohits'>0</span><code>                if (schema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ds = ds.join("pg_namespace___nsp", {oid:identifier("tab__relnamespace"), nspname:schema.toString()});</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (version &gt;= 80200) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ds = ds.filter({indisvalid:true});</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (version &gt;= 80300) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ds = ds.filter({indisready:true, indcheckxmin:false});</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>                var indexes = {};</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds.forEach(function (r) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var ident = m(r.name), i = indexes[ident];</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (!i) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        i = indexes[ident] = {columns:[], unique:r.unique};</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='red'><span class='nohits'>0</span><code>                    i.columns.push(r.column);</code></li>
<li class='green'><span class=''> </span><code>                }).then(function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret.callback(indexes);</code></li>
<li class='green'><span class=''> </span><code>                    }, ret);</code></li>
<li class='green'><span class=''> </span><code>            }, ret);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        locks:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.dataset.from("pg_class").join("pg_locks", {relation:identifier("relfilenode")}).select("pg_class__relname", identifier("pg_locks").all());</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Get version of postgres server, used for determined capabilities.</code></li>
<li class='green'><span class=''> </span><code>        serverVersion:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>1</span><code>            if (!this.__serverVersion) {</code></li>
<li class='green'><span class='hits'>1</span><code>                this.get(identifier("version").sqlFunction).then(hitch(this, function (version) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    var m = version.match(/PostgreSQL (\d+)\.(\d+)(?:(?:rc\d+)|\.(\d+))?/);</code></li>
<li class='green'><span class='hits'>1</span><code>                    this._serverVersion = (parseInt(m[1], 10) * 10000) + (parseInt(m[2], 10) * 100) + parseInt(m[3], 10);</code></li>
<li class='green'><span class='hits'>1</span><code>                    ret.callback(this._serverVersion);</code></li>
<li class='green'><span class=''> </span><code>                }), ret);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.callback(this._serverVersion);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return an array of table names in the current database.</code></li>
<li class='green'><span class=''> </span><code>         * The dataset used is passed to the block if one is provided,</code></li>
<li class='green'><span class=''> </span><code>         * otherwise, an a promise resolved with an array of table names.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Options:</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts = {}] options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [opts.schema] The schema to search (default_schema by default)</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb = null] an optional callback that is invoked with the dataset to retrieve tables.</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise resolved with the table names or the result of the cb if one is provided.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        tables:function (opts, cb) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.__pgClassRelname('r', opts, cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return an array of view names in the current database.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Options:</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts = {}] options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [opts.schema] The schema to search (default_schema by default)</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise resolved with the view names.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        views:function (opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.__pgClassRelname('v', opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        primaryKey:function (table, opts) {</code></li>
<li class='green'><span class='hits'>1311</span><code>            var ret, quotedTable = this.__quoteSchemaTable(table).toString(), pks = this.__primaryKeys;</code></li>
<li class='green'><span class='hits'>1311</span><code>            if (pks.hasOwnProperty(quotedTable.toString())) {</code></li>
<li class='green'><span class='hits'>1241</span><code>                ret = pks[quotedTable];</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>70</span><code>                ret = (pks[quotedTable] = this.__primarykey(table));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1311</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __primarykey:function (table) {</code></li>
<li class='green'><span class='hits'>70</span><code>            var parts = this.__schemaAndTable(table);</code></li>
<li class='green'><span class='hits'>70</span><code>            var m2 = this.inputIdentifierFunc;</code></li>
<li class='green'><span class='hits'>70</span><code>            var schema = parts[0];</code></li>
<li class='green'><span class='hits'>70</span><code>            table = parts[1];</code></li>
<li class='green'><span class='hits'>70</span><code>            var ds = this.from(table)</code></li>
<li class='green'><span class=''> </span><code>                .select("pg_attribute__attname___name")</code></li>
<li class='green'><span class=''> </span><code>                .from("pg_index", "pg_class", "pg_attribute", "pg_namespace")</code></li>
<li class='green'><span class=''> </span><code>                .where([</code></li>
<li class='green'><span class=''> </span><code>                [identifier("pg_class__oid"), identifier("pg_attribute__attrelid")],</code></li>
<li class='green'><span class=''> </span><code>                [identifier("pg_class__relnamespace"), identifier("pg_namespace__oid")],</code></li>
<li class='green'><span class=''> </span><code>                [identifier("pg_class__oid"), identifier("pg_index__indrelid")],</code></li>
<li class='green'><span class=''> </span><code>                [identifier("pg_index__indkey").sqlSubscript(0), identifier("pg_attribute__attnum")],</code></li>
<li class='green'><span class=''> </span><code>                [identifier("indisprimary"), true],</code></li>
<li class='green'><span class=''> </span><code>                [identifier("pg_class__relname"), m2(table.toString())]</code></li>
<li class='green'><span class=''> </span><code>            ]);</code></li>
<li class='green'><span class='hits'>70</span><code>            if (schema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds.filter({pg_namespace__nspname:m2(schema)});</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>70</span><code>            return ds.all();</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        schemaParseTable:function (tableName, opts) {</code></li>
<li class='green'><span class='hits'>65</span><code>            var m = this.outputIdentifierFunc,</code></li>
<li class='green'><span class=''> </span><code>                m2 = this.inputIdentifierFunc;</code></li>
<li class='green'><span class='hits'>65</span><code>            var ds = this.metadataDataset</code></li>
<li class='green'><span class=''> </span><code>                .select(</code></li>
<li class='green'><span class=''> </span><code>                "pg_attribute__attname___name",</code></li>
<li class='green'><span class=''> </span><code>                sql.format_type("pg_type__oid", "pg_attribute__atttypmod").as(literal('"dbType"')),</code></li>
<li class='green'><span class=''> </span><code>                sql.pg_get_expr("pg_attrdef__adbin", "pg_class__oid").as(literal('"default"')),</code></li>
<li class='green'><span class=''> </span><code>                sql.NOT("pg_attribute__attnotnull").as(literal('"allowNull"')),</code></li>
<li class='green'><span class=''> </span><code>                sql.COALESCE(BooleanExpression.fromValuePairs({pg_attribute__attnum:sql.ANY("pg_index__indkey")}), false).as(literal('"primaryKey"')),</code></li>
<li class='green'><span class=''> </span><code>                "pg_namespace__nspname"</code></li>
<li class='green'><span class=''> </span><code>            ).from("pg_class")</code></li>
<li class='green'><span class=''> </span><code>                .join("pg_attribute", {attrelid:identifier("oid")})</code></li>
<li class='green'><span class=''> </span><code>                .join("pg_type", {oid:identifier("atttypid")})</code></li>
<li class='green'><span class=''> </span><code>                .join("pg_namespace", {oid:identifier("pg_class__relnamespace")})</code></li>
<li class='green'><span class=''> </span><code>                .leftOuterJoin("pg_attrdef", {adrelid:identifier("pg_class__oid"), adnum:identifier("pg_attribute__attnum")})</code></li>
<li class='green'><span class=''> </span><code>                .leftOuterJoin("pg_index", {indrelid:identifier("pg_class__oid"), indisprimary:true})</code></li>
<li class='green'><span class=''> </span><code>                .filter({pg_attribute__attisdropped:false})</code></li>
<li class='green'><span class=''> </span><code>                .filter({pg_attribute__attnum:{gt:0}})</code></li>
<li class='green'><span class=''> </span><code>                .filter({pg_class__relname:m2(tableName)})</code></li>
<li class='green'><span class=''> </span><code>                .order("pg_attribute__attnum");</code></li>
<li class='green'><span class='hits'>65</span><code>            ds = this.__filterSchema(ds, opts);</code></li>
<li class='green'><span class='hits'>65</span><code>            var currentSchema = null;</code></li>
<li class='green'><span class='hits'>65</span><code>            return ds.map(function (row) {</code></li>
<li class='green'><span class='hits'>374</span><code>                var sch = row.nspname;</code></li>
<li class='green'><span class='hits'>374</span><code>                delete row.nspname;</code></li>
<li class='green'><span class='hits'>374</span><code>                if (currentSchema) {</code></li>
<li class='green'><span class='hits'>309</span><code>                    if (sch !== currentSchema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        var error = new Error("columns from two tables were returned please specify a schema");</code></li>
<li class='red'><span class='nohits'>0</span><code>                        this.logError(error);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>65</span><code>                    currentSchema = sch;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>374</span><code>                if (isBlank(row["default"])) {</code></li>
<li class='green'><span class='hits'>313</span><code>                    row["default"] = null;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>374</span><code>                row.type = this.schemaColumnType(row.dbType);</code></li>
<li class='green'><span class='hits'>374</span><code>                var fieldName = m(row.name);</code></li>
<li class='green'><span class='hits'>374</span><code>                delete row.name;</code></li>
<li class='green'><span class='hits'>374</span><code>                return [fieldName, row];</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __commitTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>850</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>850</span><code>            var s = opts.prepare;</code></li>
<li class='green'><span class='hits'>850</span><code>            if (s &amp;&amp; this.__transactionDepth &lt;= 1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__logConnectionExecute(conn, ["PREPARE TRANSACTION ", this.literal(s)].join(""));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>850</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Backbone of the tables and views support.</code></li>
<li class='green'><span class=''> </span><code>        __pgClassRelname:function (type, opts, cb) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ret = new Promise();</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ds = this.metadataDataset.from("pg_class")</code></li>
<li class='green'><span class=''> </span><code>                .filter({relkind:type}).select("relname")</code></li>
<li class='green'><span class=''> </span><code>                .exclude({relname:{like:this.SYSTEM_TABLE_REGEXP}})</code></li>
<li class='green'><span class=''> </span><code>                .join("pg_namespace", {oid:identifier("relnamespace")});</code></li>
<li class='red'><span class='nohits'>0</span><code>            ds = this.__filterSchema(ds, opts);</code></li>
<li class='red'><span class='nohits'>0</span><code>            var m = this.outputIdentifierFunc;</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (cb) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                when(cb(ds)).then(ret);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds.map(function (r) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return m(r.relname);</code></li>
<li class='green'><span class=''> </span><code>                }).then(ret);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //If opts includes a :schema option, or a default schema is used, restrict the dataset to</code></li>
<li class='green'><span class=''> </span><code>        // that schema.  Otherwise, just exclude the default PostgreSQL schemas except for public.</code></li>
<li class='green'><span class=''> </span><code>        __filterSchema:function (ds, opts) {</code></li>
<li class='green'><span class='hits'>65</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>65</span><code>            var schema = opts.schema, ret = ds;</code></li>
<li class='green'><span class='hits'>65</span><code>            if (schema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.filter({pg_namespace__nspname:schema});</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>65</span><code>                ds = ds.exclude({pg_namespace__nspname:this.EXCLUDE_SCHEMAS});</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>65</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __indexDefinitionSql:function (tableName, index) {</code></li>
<li class='green'><span class='hits'>9</span><code>            tableName = stringToIdentifier(tableName);</code></li>
<li class='green'><span class='hits'>9</span><code>            var cols = index.columns.map(function (col) {</code></li>
<li class='green'><span class='hits'>10</span><code>                    return stringToIdentifier(col);</code></li>
<li class='green'><span class=''> </span><code>                }),</code></li>
<li class='green'><span class=''> </span><code>                indexName = index.name || this.__defaultIndexName(tableName, cols),</code></li>
<li class='green'><span class=''> </span><code>                o = index.opclass,</code></li>
<li class='green'><span class=''> </span><code>                indexType = index.type,</code></li>
<li class='green'><span class=''> </span><code>                unique = index.unique ? "UNIQUE" : "",</code></li>
<li class='green'><span class=''> </span><code>                filter = index.where || index.filter,</code></li>
<li class='green'><span class=''> </span><code>                expr;</code></li>
<li class='green'><span class='hits'>9</span><code>            filter = filter ? ["WHERE ", this.__filterExpr(filter)].join("") : "";</code></li>
<li class='green'><span class='hits'>9</span><code>            if (isDefined(o)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                expr = ["(", cols.map(function (c) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    return [this.literal(c), o].join(" ");</code></li>
<li class='green'><span class=''> </span><code>                }, this).join(", "), ")"].join("");</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>8</span><code>                expr = this.literal(toArray(cols));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>9</span><code>            switch (indexType) {</code></li>
<li class='green'><span class=''> </span><code>                case "fullText":</code></li>
<li class='green'><span class='hits'>2</span><code>                    expr = ["(to_tsvector(", this.literal(index.language || "simple"), ", ", this.literal(this.dataset.__fullTextStringJoin(cols)), "))"].join("");</code></li>
<li class='green'><span class='hits'>2</span><code>                    indexType = "gin";</code></li>
<li class='green'><span class='hits'>2</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "spatial" :</code></li>
<li class='green'><span class='hits'>1</span><code>                    indexType = "gist";</code></li>
<li class='green'><span class='hits'>1</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>9</span><code>            return ["CREATE", unique, "INDEX", this.__quoteIdentifier(indexName), "ON", this.__quoteSchemaTable(tableName), indexType ? "USING " + indexType : "", expr, filter ].join(" ");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        /*</code></li>
<li class='green'><span class=''> </span><code>         todo might need this?</code></li>
<li class='green'><span class=''> </span><code>         __insertResult:function (conn, table, values) {</code></li>
<li class='green'><span class=''> </span><code>         },</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __renameTableSql:function (name, newName) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return ["ALTER TABLE ", this.__quoteSchemaTable(name), " RENAME TO ", this.__quoteIdentifier(this.__schemaAndTable(newName).pop())].join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __schemaAutoincrementingPrimaryKey:function (schema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this._super(arguments) &amp;&amp; schema.dbType.match(/^(?:integer|bigint)$/i) &amp;&amp; schema["default"].match(/^nextval/i);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericNumeric:function (column) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return column.size ? format("numeric(%s)", array.toArray(column.size).join(', ')) : column.isInt ? "integer" : column.isDouble ? "double precision" : "numeric";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericDateTime:function (column) {</code></li>
<li class='green'><span class='hits'>6</span><code>            return "timestamp";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //handle bigserial</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericBigint:function (column) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return column.serial ? "bigserial" : this.__typeLiteralSpecific(column);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericBlob:function (column) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return "bytea";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //handle serial type</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericInteger:function (column) {</code></li>
<li class='green'><span class='hits'>133</span><code>            return column.serial ? "serial" : this.__typeLiteralSpecific(column);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // PostgreSQL prefers the text datatype.  If a fixed size is requested,</code></li>
<li class='green'><span class=''> </span><code>        // the char type is used.  If the text type is specifically</code></li>
<li class='green'><span class=''> </span><code>        // disallowed or there is a size specified, use the varchar type.</code></li>
<li class='green'><span class=''> </span><code>        // Otherwise use the type type.</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericString:function (column) {</code></li>
<li class='green'><span class='hits'>157</span><code>            if (column.fixed) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return ["char(", column.size || 255, ")"].join("");</code></li>
<li class='green'><span class='hits'>157</span><code>            } else if (column.text === false || column.size) {</code></li>
<li class='green'><span class='hits'>139</span><code>                return ["varchar(", column.size || 255, ")"].join("");</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>18</span><code>                return 'text';</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            connectionExecuteMethod:function () {</code></li>
<li class='green'><span class='hits'>1788</span><code>                return "query";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            dataset:function () {</code></li>
<li class='green'><span class='hits'>948</span><code>                return new DS(this);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            serialPrimaryKeyOptions:function () {</code></li>
<li class='green'><span class='hits'>62</span><code>                return {primaryKey:true, serial:true, type:"integer"};</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsSavepoints:function () {</code></li>
<li class='green'><span class='hits'>10091</span><code>                return true;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsTransactionIsolationLevels:function () {</code></li>
<li class='green'><span class='hits'>894</span><code>                return true;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethodDefault:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethodDefault:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        init:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            this.setAdapterType("pg");</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).</code></li>
<li class='green'><span class=''> </span><code>    as(exports, "PostgresDatabase");</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-low" id="ConnectionPool.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>ConnectionPool.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>73.33</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>190</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>60</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>16</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="ConnectionPool.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    Queue = comb.collections.Queue,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    Pool = comb.collections.Pool;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(Pool, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.ConnectionPool.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * ConnectionPool object used internall by the {@link patio.Database} class;</code></li>
<li class='green'><span class=''> </span><code>         * @constructs;</code></li>
<li class='green'><span class=''> </span><code>         * @param options</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (options) {</code></li>
<li class='green'><span class='hits'>122</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>122</span><code>            if (!options.createConnection || !isFunction(options.createConnection)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw "patio.adapters.clients.ConnectionPool : create connection CB required.";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>122</span><code>            if (!options.closeConnection || !isFunction(options.closeConnection)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw "patio.adapters.clients.ConnectionPool : close connection CB required.";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>122</span><code>            options.minObjects = parseInt(options.minConnections || 0, 10);</code></li>
<li class='green'><span class='hits'>122</span><code>            options.maxObjects = parseInt(options.maxConnections || 10, 10);</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__deferredQueue = new Queue();</code></li>
<li class='green'><span class='hits'>122</span><code>            this._options = options;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__createConnectionCB = options.createConnection;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__closeConnectionCB = options.closeConnection;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__validateConnectionCB = options.validateConnection;</code></li>
<li class='green'><span class='hits'>122</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Checks all deferred connection requests.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __checkQueries:function () {</code></li>
<li class='green'><span class='hits'>2587</span><code>            var fc = this.freeCount, def, defQueue = this.__deferredQueue;</code></li>
<li class='green'><span class='hits'>2587</span><code>            while (fc-- &gt;= 0 &amp;&amp; defQueue.count) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                def = defQueue.dequeue();</code></li>
<li class='red'><span class='nohits'>0</span><code>                var conn = this.getObject();</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (conn) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    def.callback(conn);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class=''> </span><code>                    //we didnt get a conneciton so assume we're out.</code></li>
<li class='red'><span class='nohits'>0</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>                fc--;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Performs a query on one of the connection in this Pool.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} A promise to called back with a connection.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        getConnection:function () {</code></li>
<li class='green'><span class='hits'>2591</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class=''> </span><code>            //todo override getObject to make async so creating a connetion can execute setup sql</code></li>
<li class='green'><span class='hits'>2591</span><code>            var conn = this.getObject();</code></li>
<li class='green'><span class='hits'>2591</span><code>            if (!conn) {</code></li>
<li class='green'><span class=''> </span><code>                //we need to deffer it</code></li>
<li class='red'><span class='nohits'>0</span><code>                this.__deferredQueue.enqueue(ret);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2591</span><code>                ret.callback(conn);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2591</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Override comb.collections.Pool to allow async validation to allow</code></li>
<li class='green'><span class=''> </span><code>         * pools to do any calls to reset a connection if it needs to be done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} connection the connection to return.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        returnObject:function (obj) {</code></li>
<li class='green'><span class='hits'>2587</span><code>            if (this.count &lt;= this.__maxObjects) {</code></li>
<li class='green'><span class='hits'>2587</span><code>                this.validate(obj).then(function (valid) {</code></li>
<li class='green'><span class='hits'>2587</span><code>                    if (valid) {</code></li>
<li class='green'><span class='hits'>2587</span><code>                        this.__freeObjects.enqueue(obj);</code></li>
<li class='green'><span class='hits'>2587</span><code>                        var index;</code></li>
<li class='green'><span class='hits'>2587</span><code>                        if ((index = this.__inUseObjects.indexOf(obj)) &gt; -1) {</code></li>
<li class='green'><span class='hits'>2587</span><code>                            this.__inUseObjects.splice(index, 1);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>2587</span><code>                        this.__checkQueries();</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        this.removeObject(obj);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                this.removeObject(obj);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Removes a connection from the pool.</code></li>
<li class='green'><span class=''> </span><code>         * @param conn</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        removeConnection:function (conn) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.closeConnection(conn);</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.removeObject(conn);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return a connection to the pool.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} connection the connection to return.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {*} an adapter specific connection.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        returnConnection:function (connection) {</code></li>
<li class='green'><span class='hits'>2587</span><code>            this.returnObject(connection);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        createObject:function () {</code></li>
<li class='green'><span class='hits'>80</span><code>            return this.createConnection();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Override to implement the closing of all connections.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called when all connections are closed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        endAll:function () {</code></li>
<li class='green'><span class='hits'>41</span><code>            this.__ending = true;</code></li>
<li class='green'><span class='hits'>41</span><code>            var conn, fQueue = this.__freeObjects, count = this.count, ps = [];</code></li>
<li class='green'><span class='hits'>41</span><code>            while ((conn = this.__freeObjects.dequeue()) != undefined) {</code></li>
<li class='green'><span class='hits'>67</span><code>                ps.push(this.closeConnection(conn));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>41</span><code>            var inUse = this.__inUseObjects;</code></li>
<li class='green'><span class='hits'>41</span><code>            for (var i = inUse.length - 1; i &gt;= 0; i--) {</code></li>
<li class='green'><span class='hits'>4</span><code>                ps.push(this.closeConnection(inUse[i]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>41</span><code>            this.__inUseObjects.length = 0;</code></li>
<li class='green'><span class='hits'>41</span><code>            return new PromiseList(ps).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Override to provide any additional validation. By default the promise is called back with true.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} connection the conneciton to validate.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called back with a valid or invalid state.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        validate:function (conn) {</code></li>
<li class='green'><span class='hits'>2587</span><code>            if (!this.__validateConnectionCB) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var ret = new Promise();</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.callback(true);</code></li>
<li class='red'><span class='nohits'>0</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2587</span><code>                return this.__validateConnectionCB();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Override to create connections to insert into this ConnectionPool.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        createConnection:function () {</code></li>
<li class='green'><span class='hits'>80</span><code>            return  this.__createConnectionCB(this._options);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Override to implement close connection functionality;</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} conn the connection to close;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called back when the connection is closed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        closeConnection:function (conn) {</code></li>
<li class='green'><span class='hits'>71</span><code>            return this.__closeConnectionCB(conn);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.ConnectionPool*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getPool:function (opts, createConnection, closeConnection, validateConnection) {</code></li>
<li class='green'><span class='hits'>122</span><code>            return new this(merge(opts, {</code></li>
<li class='green'><span class=''> </span><code>                createConnection:createConnection,</code></li>
<li class='green'><span class=''> </span><code>                closeConnection:closeConnection,</code></li>
<li class='green'><span class=''> </span><code>                validateConnection:validateConnection</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="associations/manyToOne.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>associations/manyToOne.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>77.78</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>91</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>27</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>6</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="associations/manyToOne.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    _Association = require("./_Association");</code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Class to define a many to one association.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;b&gt;NOT to be instantiated directly&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code> * Its just documented for reference.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name ManyToOne</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.associations.Association</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.associations</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * */</code></li>
<li class='green'><span class='hits'>1</span><code>module.exports = exports = define(_Association, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.associations.ManyToOne.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _fetchMethod:"one",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        type:"manyToOne",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isOwner:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __checkAndSetAssociation:function (next, model) {</code></li>
<li class='green'><span class='hits'>327</span><code>            var assoc;</code></li>
<li class='green'><span class='hits'>327</span><code>            if (this.associationLoaded(model) &amp;&amp; !isUndefinedOrNull((assoc = this.getAssociation(model)))) {</code></li>
<li class='green'><span class='hits'>280</span><code>                if (assoc.isNew) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    assoc.save().both(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>8</span><code>                        var recip = this.model._findAssociation(this);</code></li>
<li class='green'><span class='hits'>8</span><code>                        if (recip) {</code></li>
<li class='green'><span class=''> </span><code>                            //set up our association</code></li>
<li class='green'><span class='hits'>8</span><code>                            recip[1]._setAssociationKeys(assoc, model);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    })).classic(next);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>272</span><code>                    next();</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>47</span><code>                this._clearAssociations(model);</code></li>
<li class='green'><span class='hits'>47</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _preSave:function (next, model) {</code></li>
<li class='green'><span class='hits'>198</span><code>            this.__checkAndSetAssociation(next, model);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _preUpdate:function (next, model) {</code></li>
<li class='green'><span class='hits'>129</span><code>            this.__checkAndSetAssociation(next, model);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //override</code></li>
<li class='green'><span class=''> </span><code>        //@see _Association</code></li>
<li class='green'><span class=''> </span><code>        _postLoad:function (next, model) {</code></li>
<li class='green'><span class='hits'>714</span><code>            if (this.isEager() &amp;&amp; !this.associationLoaded(model)) {</code></li>
<li class='green'><span class='hits'>91</span><code>                this.fetch(model).classic(next);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>623</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //override</code></li>
<li class='green'><span class=''> </span><code>        //@see _Association</code></li>
<li class='green'><span class=''> </span><code>        _setter:function (val, model) {</code></li>
<li class='green'><span class='hits'>8</span><code>            if (!isUndefinedOrNull(val)) {</code></li>
<li class='green'><span class='hits'>8</span><code>                val = this._toModel(val);</code></li>
<li class='green'><span class='hits'>8</span><code>                this.__setValue(model, val);</code></li>
<li class='green'><span class='hits'>8</span><code>                if (!val.isNew) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var recip = this.model._findAssociation(this);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (recip) {</code></li>
<li class='green'><span class=''> </span><code>                        //set up our association</code></li>
<li class='red'><span class='nohits'>0</span><code>                        recip[1]._setAssociationKeys(val, model);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (!model.isNew &amp;&amp; isNull(val)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var keys = this._getAssociationKey(model)[0].forEach(function (k) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    model[k] = null;</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="associations/oneToMany.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>associations/oneToMany.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>78.40</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>352</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>162</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>35</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="associations/oneToMany.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb-proxy"),</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    hitchIgnore = comb.hitchIgnore,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    singularize = comb.singularize,</code></li>
<li class='green'><span class=''> </span><code>    _Association = require("./_Association");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Class to define a one to many association.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;b&gt;NOT to be instantiated directly&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code> * Its just documented for reference.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Adds the following methods to each model.</code></li>
<li class='green'><span class=''> </span><code> * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code> *  &lt;li&gt;add{ModelName} - add an association&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *  &lt;li&gt;add{comb.pluralize(ModelName)} - add multiple associations&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *  &lt;li&gt;remove{ModelName} - remove an association&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *  &lt;li&gt;remove{comb.pluralize(ModelName)} - remove multiple association&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *  &lt;li&gt;removeAll - removes all associations of this type&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *  &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name OneToMany</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.associations.Association</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.associations</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * */</code></li>
<li class='green'><span class='hits'>1</span><code>module.exports = define(_Association, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.associations.OneToMany.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        type:"oneToMany",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        createSetter:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _postSave:function (next, model) {</code></li>
<li class='green'><span class='hits'>324</span><code>            var loaded = this.associationLoaded(model), vals;</code></li>
<li class='green'><span class='hits'>324</span><code>            if (loaded &amp;&amp; (vals = this.getAssociation(model))) {</code></li>
<li class='green'><span class='hits'>78</span><code>                if (isArray(vals) &amp;&amp; vals.length) {</code></li>
<li class='green'><span class='hits'>78</span><code>                    this._clearAssociations(model);</code></li>
<li class='green'><span class='hits'>78</span><code>                    var pl = this.addAssociations(vals, model);</code></li>
<li class='green'><span class='hits'>78</span><code>                    if (this.isEager()) {</code></li>
<li class='green'><span class='hits'>24</span><code>                        pl = pl.chain(hitch(this, "fetch", model), next);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>78</span><code>                    pl.classic(next);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    next();</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>246</span><code>            } else if (this.isEager() &amp;&amp; !loaded) {</code></li>
<li class='green'><span class='hits'>89</span><code>                this.fetch(model).classic(next);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>157</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _postUpdate:function (next, model) {</code></li>
<li class='green'><span class='hits'>2</span><code>            var removeAssociationFlagName = this.removeAssociationFlagName;</code></li>
<li class='green'><span class='hits'>2</span><code>            if (model[removeAssociationFlagName]) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var oldVals = this._getCachedOldVals(model);</code></li>
<li class='red'><span class='nohits'>0</span><code>                this._clearCachedOldVals(model);</code></li>
<li class='red'><span class='nohits'>0</span><code>                var pl = oldVals.length ? this.removeItems(oldVals, model, false) : null;</code></li>
<li class='red'><span class='nohits'>0</span><code>                when(pl).chain(function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    this.addAssociations(this.getAssociation(model), model).classic(next);</code></li>
<li class='green'><span class=''> </span><code>                }.bind(this)).classic(next);</code></li>
<li class='red'><span class='nohits'>0</span><code>                model[removeAssociationFlagName] = false;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        _postLoad:function (next, model) {</code></li>
<li class='green'><span class='hits'>862</span><code>            if (this.isEager() &amp;&amp; !this.associationLoaded(model)) {</code></li>
<li class='green'><span class='hits'>191</span><code>                this.fetch(model).classic(next);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>671</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called before a model is removed.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being acted up.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _preRemove:function (next, model) {</code></li>
<li class='green'><span class='hits'>89</span><code>            this.removeAllItems(model).classic(next);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getCachedOldVals:function (model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return model[this.oldAssocationCacheName] || [];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _clearCachedOldVals:function (model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            model[this.oldAssocationCacheName] = [];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _cacheOldVals:function (model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var oldVals = model[this.oldAssocationCacheName] || [];</code></li>
<li class='red'><span class='nohits'>0</span><code>            oldVals = oldVals.concat(this.getAssociation(model));</code></li>
<li class='red'><span class='nohits'>0</span><code>            model[this.oldAssocationCacheName] = oldVals;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setter:function (vals, model) {</code></li>
<li class='green'><span class='hits'>78</span><code>            if (!isUndefined(vals)) {</code></li>
<li class='green'><span class='hits'>78</span><code>                if (model.isNew) {</code></li>
<li class='green'><span class='hits'>78</span><code>                    if (!isNull(vals)) {</code></li>
<li class='green'><span class='hits'>78</span><code>                        this.addAssociations(vals, model);</code></li>
<li class='green'><span class=''> </span><code>                        //this.__setValue(model, vals);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        this.__setValue(model, []);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    model.__isChanged = true;</code></li>
<li class='red'><span class='nohits'>0</span><code>                    model[this.removeAssociationFlagName] = true;</code></li>
<li class='red'><span class='nohits'>0</span><code>                    this._cacheOldVals(model);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (!isNull(vals)) {</code></li>
<li class='green'><span class=''> </span><code>                        //ensure its an array!</code></li>
<li class='red'><span class='nohits'>0</span><code>                        vals = (isArray(vals) ? vals : [vals]).map(function (m) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            return this._toModel(m);</code></li>
<li class='green'><span class=''> </span><code>                        }, this);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        vals = [];</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='red'><span class='nohits'>0</span><code>                    this.__setValue(model, vals);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        addAssociation:function (item, model, reload) {</code></li>
<li class='green'><span class='hits'>262</span><code>            reload = isBoolean(reload) ? reload : false;</code></li>
<li class='green'><span class='hits'>262</span><code>            var ret = new Promise().callback(model);</code></li>
<li class='green'><span class='hits'>262</span><code>            if (!isUndefinedOrNull(item)) {</code></li>
<li class='green'><span class='hits'>262</span><code>                if (!model.isNew) {</code></li>
<li class='green'><span class='hits'>150</span><code>                    item = this._toModel(item);</code></li>
<li class='green'><span class='hits'>150</span><code>                    var loaded = this.associationLoaded(model);</code></li>
<li class='green'><span class='hits'>150</span><code>                    this._setAssociationKeys(model, item);</code></li>
<li class='green'><span class='hits'>150</span><code>                    var recip = this.model._findAssociation(this);</code></li>
<li class='green'><span class='hits'>150</span><code>                    if (recip) {</code></li>
<li class='green'><span class='hits'>149</span><code>                        recip[1].__setValue(item, model);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>150</span><code>                    ret = model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>150</span><code>                        var ret = new Promise();</code></li>
<li class='green'><span class='hits'>150</span><code>                        serial([</code></li>
<li class='green'><span class=''> </span><code>                            item.save.bind(item),</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>150</span><code>                                if (loaded &amp;&amp; reload) {</code></li>
<li class='green'><span class='hits'>3</span><code>                                    return this.parent._reloadAssociationsForType(this.type, this.model, model);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this)</code></li>
<li class='green'><span class=''> </span><code>                        ]).then(hitchIgnore(ret, "callback", model), ret);</code></li>
<li class='green'><span class='hits'>150</span><code>                        return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>112</span><code>                    item = this._toModel(item);</code></li>
<li class='green'><span class='hits'>112</span><code>                    var items = this.getAssociation(model);</code></li>
<li class='green'><span class='hits'>112</span><code>                    if (isUndefinedOrNull(items)) {</code></li>
<li class='green'><span class='hits'>39</span><code>                        this.__setValue(model, [item]);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>73</span><code>                        items.push(item);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>262</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        addAssociations:function (items, model) {</code></li>
<li class='green'><span class='hits'>174</span><code>            var ret = new Promise(), pl;</code></li>
<li class='green'><span class='hits'>174</span><code>            if (model.isNew) {</code></li>
<li class='green'><span class='hits'>78</span><code>                (isArray(items) ? items : [items]).map(function (item) {</code></li>
<li class='green'><span class='hits'>224</span><code>                    return this.addAssociation(item, model, false);</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class='hits'>78</span><code>                ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>96</span><code>                pl = model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>96</span><code>                    return new PromiseList((isArray(items) ? items : [items]).map(function (item) {</code></li>
<li class='green'><span class='hits'>278</span><code>                        return this.addAssociation(item, model, false);</code></li>
<li class='green'><span class=''> </span><code>                    }, this));</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class='hits'>96</span><code>                pl.then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>96</span><code>                    if (!model.isNew &amp;&amp; this.associationLoaded(model)) {</code></li>
<li class='green'><span class='hits'>6</span><code>                        this.parent._reloadAssociationsForType(this.type, this.model, model).then(hitchIgnore(ret, "callback", model), ret);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>90</span><code>                        ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }), ret);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>174</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        removeItem:function (item, model, remove, reload) {</code></li>
<li class='green'><span class='hits'>56</span><code>            reload = isBoolean(reload) ? reload : false;</code></li>
<li class='green'><span class='hits'>56</span><code>            remove = isBoolean(remove) ? remove : false;</code></li>
<li class='green'><span class='hits'>56</span><code>            var ret = new Promise().callback(model);</code></li>
<li class='green'><span class='hits'>56</span><code>            if (!isUndefinedOrNull(item)) {</code></li>
<li class='green'><span class='hits'>56</span><code>                if (!model.isNew) {</code></li>
<li class='green'><span class='hits'>56</span><code>                    if (isInstanceOf(item, this.model) &amp;&amp; !item.isNew) {</code></li>
<li class='green'><span class='hits'>56</span><code>                        if (!remove) {</code></li>
<li class='green'><span class='hits'>28</span><code>                            this._setAssociationKeys(model, item, null);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>56</span><code>                        var loaded = this.associationLoaded(model);</code></li>
<li class='green'><span class='hits'>56</span><code>                        return model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>56</span><code>                            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>56</span><code>                            serial([</code></li>
<li class='green'><span class=''> </span><code>                                item[remove ? "remove" : "save"].bind(item),</code></li>
<li class='green'><span class=''> </span><code>                                function () {</code></li>
<li class='green'><span class='hits'>56</span><code>                                    if (loaded &amp;&amp; reload) {</code></li>
<li class='green'><span class='hits'>18</span><code>                                        return this.parent._reloadAssociationsForType(this.type, this.model, model);</code></li>
<li class='green'><span class=''> </span><code>                                    }</code></li>
<li class='green'><span class=''> </span><code>                                }.bind(this)</code></li>
<li class='green'><span class=''> </span><code>                            ]).then(hitchIgnore(ret, "callback", model), ret);</code></li>
<li class='green'><span class='hits'>56</span><code>                            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>                        }));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    item = this._toModel(item);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var items = this.getAssociation(model), index;</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (!isUndefinedOrNull(items) &amp;&amp; (index = items.indexOf(item)) !== -1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        items.splice(index, 1);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        removeItems:function (items, model, remove) {</code></li>
<li class='green'><span class=''> </span><code>            //todo make this more efficient!!!!</code></li>
<li class='green'><span class='hits'>36</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>36</span><code>            if (model.isNew) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                (isArray(items) ? items : [items]).map(function (item) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this.removeItem(item, model, remove, false);</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>36</span><code>                var pl = model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>36</span><code>                    return new PromiseList((isArray(items) ? items : [items]).map(function (item) {</code></li>
<li class='green'><span class='hits'>76</span><code>                        return this.removeItem(item, model, remove, false);</code></li>
<li class='green'><span class=''> </span><code>                    }, this));</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class='hits'>36</span><code>                pl.then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>36</span><code>                    if (this.associationLoaded(model)) {</code></li>
<li class='green'><span class='hits'>36</span><code>                        this.parent._reloadAssociationsForType(this.type, this.model, model).then(hitchIgnore(ret, "callback", model), ret);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }), ret);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>36</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        removeAllItems:function (model, remove) {</code></li>
<li class='green'><span class='hits'>93</span><code>            remove = isBoolean(remove) ? remove : false;</code></li>
<li class='green'><span class='hits'>93</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>93</span><code>            if (!model.isNew) {</code></li>
<li class='green'><span class='hits'>93</span><code>                var q = {}, removeQ = {};</code></li>
<li class='green'><span class='hits'>93</span><code>                this._setAssociationKeys(model, q);</code></li>
<li class='green'><span class='hits'>93</span><code>                this._setAssociationKeys(model, removeQ, null);</code></li>
<li class='green'><span class='hits'>93</span><code>                var loaded = this.associationLoaded(model);</code></li>
<li class='green'><span class='hits'>93</span><code>                return model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>93</span><code>                    var ds = model[this.associatedDatasetName], ret = new Promise();</code></li>
<li class='green'><span class='hits'>93</span><code>                    this._filter(model).forEach(function (m) {</code></li>
<li class='green'><span class='hits'>99</span><code>                        return remove ? m.remove() : m.update(removeQ);</code></li>
<li class='green'><span class=''> </span><code>                    }).then(function () {</code></li>
<li class='green'><span class='hits'>93</span><code>                        if (loaded) {</code></li>
<li class='green'><span class='hits'>35</span><code>                            this.parent._reloadAssociationsForType(this.type, this.model, model)</code></li>
<li class='green'><span class=''> </span><code>                                .then(hitchIgnore(ret, "callback", model), ret);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>58</span><code>                            ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this), ret);</code></li>
<li class='green'><span class='hits'>93</span><code>                    return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class=''> </span><code>                //todo we may want to check if any of the items were previously saved items;</code></li>
<li class='red'><span class='nohits'>0</span><code>                this._clearAssociations(model);</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        inject:function (parent, name) {</code></li>
<li class='green'><span class='hits'>31</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>31</span><code>            var singular = singularize(name);</code></li>
<li class='green'><span class='hits'>31</span><code>            if (this._model === name) {</code></li>
<li class='green'><span class='hits'>23</span><code>                this._model = singular;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>31</span><code>            singular = singular.charAt(0).toUpperCase() + singular.slice(1);</code></li>
<li class='green'><span class='hits'>31</span><code>            if (!this.readOnly) {</code></li>
<li class='green'><span class='hits'>31</span><code>                this.removedKey = "__removed" + name + "";</code></li>
<li class='green'><span class='hits'>31</span><code>                this.addedKey = "__added_" + name + "";</code></li>
<li class='green'><span class='hits'>31</span><code>                parent.prototype[this.removedKey] = [];</code></li>
<li class='green'><span class='hits'>31</span><code>                parent.prototype[this.addedKey] = [];</code></li>
<li class='green'><span class='hits'>31</span><code>                var self = this;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>31</span><code>                name = name.charAt(0).toUpperCase() + name.slice(1);</code></li>
<li class='green'><span class='hits'>31</span><code>                var addName = "add" + singular;</code></li>
<li class='green'><span class='hits'>31</span><code>                var addNames = "add" + name;</code></li>
<li class='green'><span class='hits'>31</span><code>                var removeName = "remove" + singular;</code></li>
<li class='green'><span class='hits'>31</span><code>                var removeNames = "remove" + name;</code></li>
<li class='green'><span class='hits'>31</span><code>                var removeAllName = "removeAll" + name;</code></li>
<li class='green'><span class='hits'>31</span><code>                parent.prototype[addName] = function (item) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    return isArray(item) ? self.addAssociations(item, this) : self.addAssociation(item, this, true);</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>31</span><code>                parent.prototype[addNames] = function (items) {</code></li>
<li class='green'><span class='hits'>20</span><code>                    return isArray(items) ? self.addAssociations(items, this) : self.addAssociation(items, this);</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>31</span><code>                parent.prototype[removeName] = function (item, remove) {</code></li>
<li class='green'><span class='hits'>36</span><code>                    return isArray(item) ? self.removeItems(item, this, remove) : self.removeItem(item, this, remove, true);</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>31</span><code>                parent.prototype[removeNames] = function (item, remove) {</code></li>
<li class='green'><span class='hits'>36</span><code>                    return isArray(item) ? self.removeItems(item, this, remove) : self.removeItem(item, this, remove);</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>31</span><code>                parent.prototype[removeAllName] = function (remove) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    return self.removeAllItems(this, remove);</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            oldAssocationCacheName:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return "_" + this.name + "OldValues";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Returns our model</code></li>
<li class='green'><span class=''> </span><code>            model:function () {</code></li>
<li class='green'><span class='hits'>7684</span><code>                try {</code></li>
<li class='green'><span class='hits'>7684</span><code>                    return this.__model__ || (this.__model__ = this.patio.getModel(this._model, this.parent.db));</code></li>
<li class='green'><span class=''> </span><code>                } catch (e) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this.__model__ = this.patio.getModel(this.name, this.parent.db)</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="database/index.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/index.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>78.76</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>300</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>113</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>24</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/index.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isObject = comb.isObject,</code></li>
<li class='green'><span class=''> </span><code>    isDate = comb.isDate,</code></li>
<li class='green'><span class=''> </span><code>    isArray = Array.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    isNumber = comb.isNumber,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    DateTime = sql.DateTime,</code></li>
<li class='green'><span class=''> </span><code>    TimeStamp = sql.TimeStamp,</code></li>
<li class='green'><span class=''> </span><code>    Year = sql.Year,</code></li>
<li class='green'><span class=''> </span><code>    Time = sql.Time,</code></li>
<li class='green'><span class=''> </span><code>    ConnectionPool = require("../ConnectionPool"),</code></li>
<li class='green'><span class=''> </span><code>    DatabaseError = require("../errors").DatabaseError,</code></li>
<li class='green'><span class=''> </span><code>    ConnectDB = require("./connect"),</code></li>
<li class='green'><span class=''> </span><code>    DatasetDB = require("./dataset"),</code></li>
<li class='green'><span class=''> </span><code>    DefaultsDB = require("./defaults"),</code></li>
<li class='green'><span class=''> </span><code>    LoggingDB = require("./logging"),</code></li>
<li class='green'><span class=''> </span><code>    QueryDB = require("./query"),</code></li>
<li class='green'><span class=''> </span><code>    SchemaDB = require("./schema"), patio;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var DATABASES = [];</code></li>
<li class='green'><span class='hits'>1</span><code>var Database = define([ConnectDB, DatasetDB, DefaultsDB, LoggingDB, QueryDB, SchemaDB], {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * A Database object represents a virtual connection to a database.</code></li>
<li class='green'><span class=''> </span><code>         * The Database class is meant to be subclassed by database adapters in order</code></li>
<li class='green'><span class=''> </span><code>         * to provide the functionality needed for executing queries.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} opts options used to create the database</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} uri A database URI used to create the database connection. This property is</code></li>
<li class='green'><span class=''> </span><code>         * available even if an object was used to create the database connection.</code></li>
<li class='green'><span class=''> </span><code>         * @property {patio.Dataset} dataset returns an empty adapter specific {@link patio.Dataset} that can</code></li>
<li class='green'><span class=''> </span><code>         * be used to query the {@link patio.Database} with.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (opts) {</code></li>
<li class='green'><span class='hits'>122</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>122</span><code>            if (!patio) {</code></li>
<li class='green'><span class='hits'>1</span><code>                patio = require("../index");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>122</span><code>            this.patio = patio;</code></li>
<li class='green'><span class='hits'>122</span><code>            this._super(arguments, [opts]);</code></li>
<li class='green'><span class='hits'>122</span><code>            opts = merge(this.connectionPoolDefaultOptions, opts);</code></li>
<li class='green'><span class='hits'>122</span><code>            this.schemas = {};</code></li>
<li class='green'><span class='hits'>122</span><code>            this.type = opts.type;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.defaultSchema = opts.defaultSchema || this.defaultSchemaDefault;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.preparedStatements = {};</code></li>
<li class='green'><span class='hits'>122</span><code>            this.opts = opts;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.pool = ConnectionPool.getPool(opts, this.createConnection.bind(this), this.closeConnection.bind(this), this.validate.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Casts the given type to a SQL type.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.castTypeLiteral(Number) //=&gt; numeric</code></li>
<li class='green'><span class=''> </span><code>         *   DB.castTypeLiteral("foo") //=&gt; foo</code></li>
<li class='green'><span class=''> </span><code>         *   DB.castTypeLiteral(String) //=&gt; varchar(255)</code></li>
<li class='green'><span class=''> </span><code>         *   DB.castTypeLiteral(Boolean) //=&gt; boolean</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *@param type the javascript type to cast to a SQL type.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the SQL data type.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        castTypeLiteral:function (type) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.typeLiteral({type:type});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This function acts as a proxy to {@link patio.Dataset#literal}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Dataset#literal}.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        literal:function (v) {</code></li>
<li class='green'><span class='hits'>157</span><code>            return this.dataset.literal(v);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Typecast the value to the given columnType. Calls</code></li>
<li class='green'><span class=''> </span><code>         * typecastValue{ColumnType} if the method exists,</code></li>
<li class='green'><span class=''> </span><code>         * otherwise returns the value.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.typeCastValue("boolean", 0) //=&gt; false</code></li>
<li class='green'><span class=''> </span><code>         * DB.typeCastValue("boolean", 1) //=&gt; true</code></li>
<li class='green'><span class=''> </span><code>         * DB.typeCastValue("timestamp",  '2004-02-01 12:12:12')</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; new patio.sql.TimeStamp(2004, 1, 1, 12, 12, 12);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.DatabaseError} if there is an error converting the value to the column type.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} columnType the SQL datatype of the column</code></li>
<li class='green'><span class=''> </span><code>         * @param value the value to typecast.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return the typecasted value.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        typecastValue:function (columnType, value) {</code></li>
<li class='green'><span class='hits'>33039</span><code>            if (isNull(value) || isUndefined(value)) {</code></li>
<li class='green'><span class='hits'>5865</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>27174</span><code>            var meth = "__typecastValue" + columnType.charAt(0).toUpperCase() + columnType.substr(1).toLowerCase();</code></li>
<li class='green'><span class='hits'>27174</span><code>            try {</code></li>
<li class='green'><span class='hits'>27174</span><code>                if (isFunction(this[meth])) {</code></li>
<li class='green'><span class='hits'>27174</span><code>                    return this[meth](value);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return value;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } catch (e) {</code></li>
<li class='green'><span class='hits'>9</span><code>                throw e;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to true, false, or null</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueBoolean:function (value) {</code></li>
<li class='green'><span class='hits'>9</span><code>            if (isBoolean(value)) {</code></li>
<li class='green'><span class='hits'>7</span><code>                return value;</code></li>
<li class='green'><span class='hits'>2</span><code>            } else if (value === 0 || value === "0" || (isString(value) &amp;&amp; value.match(/^f(alse)?$/i) !== null)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return false;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                return (isObject(value) &amp;&amp; isEmpty(value)) || !value ? null : true;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to blob, false, or null</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueBlob:function (value) {</code></li>
<li class='green'><span class='hits'>28</span><code>            if (isInstanceOf(value, Buffer)) {</code></li>
<li class='green'><span class='hits'>12</span><code>                return value;</code></li>
<li class='green'><span class='hits'>16</span><code>            } else if (isArray(value) || isString(value)) {</code></li>
<li class='green'><span class='hits'>14</span><code>                return new Buffer(value);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                throw new Error("Invalid value for blob " + value);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to true, false, or null</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueText:function (value) {</code></li>
<li class='green'><span class='hits'>372</span><code>            return value.toString();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a Date</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueDate:function (value) {</code></li>
<li class='green'><span class='hits'>15</span><code>            if (isDate(value)) {</code></li>
<li class='green'><span class='hits'>12</span><code>                return value;</code></li>
<li class='green'><span class='hits'>3</span><code>            } else if (isString(value)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                var ret = patio.stringToDate(value);</code></li>
<li class='green'><span class='hits'>1</span><code>                if (!ret) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new DatabaseError(format("Invalid value for date %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1</span><code>                return ret;</code></li>
<li class='green'><span class='hits'>1</span><code>            } else if (isHash(value) &amp;&amp; !isEmpty(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return new Date(value.year, value.month, value.day);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new DatabaseError(format("Invalid value for date %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a patio.sql.DateTime.</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueDatetime:function (value) {</code></li>
<li class='green'><span class='hits'>62</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>62</span><code>            if (isInstanceOf(value, DateTime)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return value;</code></li>
<li class='green'><span class='hits'>62</span><code>            } else if (isDate(value)) {</code></li>
<li class='green'><span class='hits'>60</span><code>                ret = value;</code></li>
<li class='green'><span class='hits'>2</span><code>            } else if (isHash(value) &amp;&amp; !isEmpty(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = new Date(value.year, value.month, value.day, value.hour, value.minute, value.second);</code></li>
<li class='green'><span class='hits'>2</span><code>            } else if (isString(value)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = patio.stringToDateTime(value);</code></li>
<li class='green'><span class='hits'>1</span><code>                if (!ret) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new DatabaseError(format("Invalid value for datetime %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = ret.date;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new DatabaseError(format("Invalid value for datetime %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>61</span><code>            return new DateTime(ret);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a patio.sql.DateTime</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueTimestamp:function (value) {</code></li>
<li class='green'><span class='hits'>1</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>1</span><code>            if (isInstanceOf(value, TimeStamp)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return ret;</code></li>
<li class='green'><span class='hits'>1</span><code>            } else if (isDate(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = value;</code></li>
<li class='green'><span class='hits'>1</span><code>            } else if (isHash(value) &amp;&amp; !isEmpty(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = new Date(value.year, value.month, value.day, value.hour, value.minute, value.second);</code></li>
<li class='green'><span class='hits'>1</span><code>            } else if (isString(value)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = patio.stringToTimeStamp(value);</code></li>
<li class='green'><span class='hits'>1</span><code>                if (!ret) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new DatabaseError(format("Invalid value for timestamp %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = ret.date;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new DatabaseError(format("Invalid value for timestamp %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1</span><code>            return new TimeStamp(ret);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a patio.sql.Year</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueYear:function (value) {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (isInstanceOf(value, Year)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return value;</code></li>
<li class='green'><span class='hits'>1</span><code>            } else if (isNumber(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return new Year(value);</code></li>
<li class='green'><span class='hits'>1</span><code>            } else if (isString(value)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                var ret = patio.stringToYear(value);</code></li>
<li class='green'><span class='hits'>1</span><code>                if (!ret) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new DatabaseError(format("Invalid value for date %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1</span><code>                return ret;</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (isHash(value) &amp;&amp; !isEmpty(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return new Date(value.year, value.month, value.day);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new DatabaseError(format("Invalid value for date %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a patio.sql.Time</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueTime:function (value) {</code></li>
<li class='green'><span class='hits'>2</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>2</span><code>            if (isInstanceOf(value, Time)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return value;</code></li>
<li class='green'><span class='hits'>2</span><code>            } else if (isDate(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = value;</code></li>
<li class='green'><span class='hits'>2</span><code>            } else if (isString(value)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = patio.stringToTime(value);</code></li>
<li class='green'><span class='hits'>1</span><code>                if (!ret) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new DatabaseError(format("Invalid value for time %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = ret.date;</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (isHash(value) &amp;&amp; !isEmpty(value)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = new Date(0, 0, 0, value.hour, value.minute, value.second);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new DatabaseError(format("Invalid value for time %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1</span><code>            return new Time(ret);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a Number</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueDecimal:function (value) {</code></li>
<li class='green'><span class='hits'>36</span><code>            var ret = parseFloat(value);</code></li>
<li class='green'><span class='hits'>36</span><code>            if (isNaN(ret)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new DatabaseError(format("Invalid value for decimal %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>35</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a Number</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueFloat:function (value) {</code></li>
<li class='green'><span class='hits'>325</span><code>            var ret = parseFloat(value);</code></li>
<li class='green'><span class='hits'>325</span><code>            if (isNaN(ret)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new DatabaseError(format("Invalid value for float %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>324</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a Number</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueInteger:function (value) {</code></li>
<li class='green'><span class='hits'>6565</span><code>            var ret = parseInt(value, 10);</code></li>
<li class='green'><span class='hits'>6565</span><code>            if (isNaN(ret)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new DatabaseError(format("Invalid value for integer %j", [value]));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>6564</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Typecast the value to a String</code></li>
<li class='green'><span class=''> </span><code>        __typecastValueString:function (value) {</code></li>
<li class='green'><span class='hits'>19758</span><code>            return "" + value;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * A list of currently connected Databases.</code></li>
<li class='green'><span class=''> </span><code>         * @type patio.Database[]</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DATABASES:DATABASES</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="adapters/mysql.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>adapters/mysql.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>80.71</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>879</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>337</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>65</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="adapters/mysql.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var mysql = require("mysql"),</code></li>
<li class='green'><span class=''> </span><code>    comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    asyncArray = comb.async.array,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    string = comb.string,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    format = string.format,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    toArray = array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    QueryError = require("../errors").QueryError,</code></li>
<li class='green'><span class=''> </span><code>    Dataset = require("../dataset"),</code></li>
<li class='green'><span class=''> </span><code>    Database = require("../database"),</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    DateTime = sql.DateTime,</code></li>
<li class='green'><span class=''> </span><code>    Time = sql.Time,</code></li>
<li class='green'><span class=''> </span><code>    Year = sql.Year,</code></li>
<li class='green'><span class=''> </span><code>    Double = sql.Double,</code></li>
<li class='green'><span class=''> </span><code>    patio;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var convertDate = function (v, m, convertDateTime) {</code></li>
<li class='green'><span class='hits'>15</span><code>    try {</code></li>
<li class='green'><span class='hits'>15</span><code>        return patio[m](v);</code></li>
<li class='green'><span class=''> </span><code>    } catch (e) {</code></li>
<li class='green'><span class='hits'>15</span><code>        if (convertDateTime === null) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return null;</code></li>
<li class='green'><span class='hits'>12</span><code>        } else if (convertDateTime === String || (isString(convertDateTime) &amp;&amp; convertDateTime.match(/string/i))) {</code></li>
<li class='green'><span class='hits'>9</span><code>            return v;</code></li>
<li class='green'><span class=''> </span><code>        } else {</code></li>
<li class='green'><span class='hits'>3</span><code>            throw e;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Connection = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        connection:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function (conn) {</code></li>
<li class='green'><span class='hits'>3</span><code>            this.connection = conn;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        closeConnection:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>3</span><code>            this.connection.end(ret.resolve.bind(ret));</code></li>
<li class='green'><span class='hits'>3</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        query:function (query) {</code></li>
<li class='green'><span class='hits'>295</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>295</span><code>            try {</code></li>
<li class='green'><span class='hits'>295</span><code>                this.connection.setMaxListeners(0);</code></li>
<li class='green'><span class='hits'>295</span><code>                this.connection.query(query, ret.resolve.bind(ret));</code></li>
<li class='green'><span class=''> </span><code>            } catch (e) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                patio.logError(e);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>295</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var DS = define(Dataset, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __providesAccurateRowsMatched:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsDistinctOn:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsIntersectExcept:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsModifyingJoins:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsTimestampUsecs:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // MySQL specific syntax for LIKE/REGEXP searches, as well as</code></li>
<li class='green'><span class=''> </span><code>        // string concatenation.</code></li>
<li class='green'><span class=''> </span><code>        complexExpressionSql:function (op, args) {</code></li>
<li class='green'><span class='hits'>23</span><code>            var likeOps = ["~", "~*", "LIKE", "ILIKE"];</code></li>
<li class='green'><span class='hits'>23</span><code>            var notLikeOps = ["!~", "!~*", "NOT LIKE", "NOT ILIKE"];</code></li>
<li class='green'><span class='hits'>23</span><code>            var regExpOps = ["~", "!~", "~*", "!~*"];</code></li>
<li class='green'><span class='hits'>23</span><code>            var binaryOps = ["~", "!~", "LIKE", "NOT LIKE"];</code></li>
<li class='green'><span class='hits'>23</span><code>            if (likeOps.indexOf(op) !== -1 || notLikeOps.indexOf(op) !== -1) {</code></li>
<li class='green'><span class='hits'>10</span><code>                return format("(%s%s %s%s %s)", this.literal(args[0]), notLikeOps.indexOf(op) !== -1 ? " NOT" : "",</code></li>
<li class='green'><span class=''> </span><code>                    regExpOps.indexOf(op) !== -1 ? "REGEXP" : "LIKE", binaryOps.indexOf(op) !== -1 ? " BINARY" : "",</code></li>
<li class='green'><span class=''> </span><code>                    this.literal(args[1]));</code></li>
<li class='green'><span class='hits'>13</span><code>            } else if (op === "||") {</code></li>
<li class='green'><span class='hits'>5</span><code>                if (args.length &gt; 1) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    return format("CONCAT(%s)", args.map(this.literal, this).join(", "));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                    return this.literal(args[0]);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>8</span><code>            } else if (op === "B~") {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return format("CAST(~%s AS SIGNED INTEGER)", this.literal(args[0]));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>8</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Use GROUP BY instead of DISTINCT ON if arguments are provided.</code></li>
<li class='green'><span class=''> </span><code>        distinct:function (args) {</code></li>
<li class='green'><span class='hits'>2</span><code>            args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>2</span><code>            return !args.length ? this._super(arguments) : this.group.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Return a cloned dataset which will use LOCK IN SHARE MODE to lock returned rows.</code></li>
<li class='green'><span class=''> </span><code>        forShare:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.lockStyle("share");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Adds full text filter</code></li>
<li class='green'><span class=''> </span><code>        fullTextSearch:function (cols, terms, opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>3</span><code>            cols = toArray(cols).map(this.stringToIdentifier, this);</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.filter(sql.literal(this.fullTextSql(cols, terms, opts)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL specific full text search syntax.</code></li>
<li class='green'><span class=''> </span><code>        fullTextSql:function (cols, term, opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>3</span><code>            return format("MATCH %s AGAINST (%s%s)", this.literal(toArray(cols)),</code></li>
<li class='green'><span class=''> </span><code>                this.literal(toArray(term).join(" ")), opts.boolean ? " IN BOOLEAN MODE" : "");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL allows HAVING clause on ungrouped datasets.</code></li>
<li class='green'><span class=''> </span><code>        having:function (cond, cb) {</code></li>
<li class='green'><span class='hits'>3</span><code>            var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>3</span><code>            return this._filter.apply(this, ["having"].concat(args));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Transforms an CROSS JOIN to an INNER JOIN if the expr is not nil.</code></li>
<li class='green'><span class=''> </span><code>        //Raises an error on use of :full_outer type, since MySQL doesn't support it.</code></li>
<li class='green'><span class=''> </span><code>        joinTable:function (type, table, expr, tableAlias) {</code></li>
<li class='green'><span class='hits'>12</span><code>            tableAlias = tableAlias || {};</code></li>
<li class='green'><span class='hits'>12</span><code>            if (type === "cross" &amp;&amp; !isUndefinedOrNull(expr)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                type = "inner";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>12</span><code>            if (type === "fullOuter") {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("MySQL does not support FULL OUTER JOIN");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>11</span><code>            return this._super(arguments, [type, table, expr, tableAlias]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Transforms :natural_inner to NATURAL LEFT JOIN and straight to</code></li>
<li class='green'><span class=''> </span><code>        //STRAIGHT_JOIN.</code></li>
<li class='green'><span class=''> </span><code>        _joinTypeSql:function (joinType) {</code></li>
<li class='green'><span class='hits'>11</span><code>            if (joinType === "straight") {</code></li>
<li class='green'><span class='hits'>2</span><code>                return "STRAIGHT_JOIN";</code></li>
<li class='green'><span class='hits'>9</span><code>            } else if (joinType === "naturalInner") {</code></li>
<li class='green'><span class='hits'>1</span><code>                return "NATURAL LEFT JOIN";</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>8</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        insertIgnore:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.mergeOptions({insertIgnore:true});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        onDuplicateKeyUpdate:function (args) {</code></li>
<li class='green'><span class='hits'>3</span><code>            args = argsToArray(arguments).map(function (c) {</code></li>
<li class='green'><span class='hits'>5</span><code>                return isString(c) ? this.stringToIdentifier(c) : c;</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.mergeOptions({onDuplicateKeyUpdate:args});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // MySQL specific syntax for inserting multiple values at once.</code></li>
<li class='green'><span class=''> </span><code>        multiInsertSql:function (columns, values) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return [this.insertSql(columns, sql.literal('VALUES ' + values.map(</code></li>
<li class='green'><span class=''> </span><code>                function (r) {</code></li>
<li class='green'><span class='hits'>16</span><code>                    return this.literal(toArray(r));</code></li>
<li class='green'><span class=''> </span><code>                }, this).join(this._static.COMMA_SEPARATOR)))];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL uses the nonstandard ` (backtick) for quoting identifiers.</code></li>
<li class='green'><span class=''> </span><code>        _quotedIdentifier:function (c) {</code></li>
<li class='green'><span class='hits'>51</span><code>            return format("`%s`", c);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // MySQL specific syntax for REPLACE (aka UPSERT, or update if exists,</code></li>
<li class='green'><span class=''> </span><code>        //insert if it doesn't).</code></li>
<li class='green'><span class=''> </span><code>        replaceSql:function (values) {</code></li>
<li class='green'><span class='hits'>9</span><code>            var ds = this.mergeOptions({replace:true});</code></li>
<li class='green'><span class='hits'>9</span><code>            return ds.insertSql.apply(ds, argsToArray(arguments));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //If this is an replace instead of an insert, use replace instead</code></li>
<li class='green'><span class=''> </span><code>        _insertSql:function () {</code></li>
<li class='green'><span class='hits'>51</span><code>            return this.__opts.replace ? this._clauseSql("replace") : this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Consider the first table in the joined dataset is the table to delete</code></li>
<li class='green'><span class=''> </span><code>        //from, but include the others for the purposes of selecting rows.</code></li>
<li class='green'><span class=''> </span><code>        _deleteFromSql:function (sql) {</code></li>
<li class='green'><span class='hits'>10</span><code>            if (this._joinedDataset) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return format(" %s FROM %s%s", this._sourceList(this.__opts.from[0]), this._sourceList(this.__opts.from), this._selectJoinSql());</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>10</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //alias replace_clause_methods insert_clause_methods</code></li>
<li class='green'><span class=''> </span><code>        //MySQL doesn't use the standard DEFAULT VALUES for empty values.</code></li>
<li class='green'><span class=''> </span><code>        _insertColumnsSql:function (sql) {</code></li>
<li class='green'><span class='hits'>51</span><code>            var values = this.__opts.values;</code></li>
<li class='green'><span class='hits'>51</span><code>            if (isArray(values) &amp;&amp; !values.length) {</code></li>
<li class='green'><span class='hits'>9</span><code>                return " ()";</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>42</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL supports INSERT IGNORE INTO</code></li>
<li class='green'><span class=''> </span><code>        _insertIgnoreSql:function (sql) {</code></li>
<li class='green'><span class='hits'>51</span><code>            return this.__opts.insertIgnore ? " IGNORE" : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL supports INSERT ... ON DUPLICATE KEY UPDATE</code></li>
<li class='green'><span class=''> </span><code>        _insertOnDuplicateKeyUpdateSql:function (sql) {</code></li>
<li class='green'><span class='hits'>51</span><code>            return this.__opts.onDuplicateKeyUpdate ? this.onDuplicateKeyUpdateSql() : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL doesn't use the standard DEFAULT VALUES for empty values.</code></li>
<li class='green'><span class=''> </span><code>        _insertValuesSql:function (sql) {</code></li>
<li class='green'><span class='hits'>51</span><code>            var values = this.__opts.values;</code></li>
<li class='green'><span class='hits'>51</span><code>            if (isArray(values) &amp;&amp; !values.length) {</code></li>
<li class='green'><span class='hits'>9</span><code>                return " VALUES ()";</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>42</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL allows a LIMIT in DELETE and UPDATE statements.</code></li>
<li class='green'><span class=''> </span><code>        limitSql:function (sql) {</code></li>
<li class='green'><span class='hits'>12</span><code>            return this.__opts.limit ? format(" LIMIT %s", this.__opts.limit) : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _deleteLimitSql:function () {</code></li>
<li class='green'><span class='hits'>10</span><code>            return this.limitSql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _updateLimitSql:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.limitSql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL specific syntax for ON DUPLICATE KEY UPDATE</code></li>
<li class='green'><span class=''> </span><code>        onDuplicateKeyUpdateSql:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>            var ret = "";</code></li>
<li class='green'><span class='hits'>3</span><code>            var updateCols = this.__opts.onDuplicateKeyUpdate;</code></li>
<li class='green'><span class='hits'>3</span><code>            if (updateCols) {</code></li>
<li class='green'><span class='hits'>3</span><code>                var updateVals = null, l, last;</code></li>
<li class='green'><span class='hits'>3</span><code>                if ((l = updateCols.length) &gt; 0 &amp;&amp; isHash((last = updateCols[l - 1]))) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    updateVals = last;</code></li>
<li class='green'><span class='hits'>2</span><code>                    updateCols = l === 2 ? [updateCols[0]] : updateCols.slice(0, l - 2);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>3</span><code>                var updating = updateCols.map(function (c) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    var quoted = this.quoteIdentifier(c);</code></li>
<li class='green'><span class='hits'>3</span><code>                    return format("%s=VALUES(%s)", quoted, quoted);</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class='hits'>3</span><code>                for (var i in updateVals) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    if (i in updateVals) {</code></li>
<li class='green'><span class='hits'>2</span><code>                        updating.push(format("%s=%s", this.quoteIdentifier(i), this.literal(updateVals[i])));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>3</span><code>                if (updating || updateVals) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    ret =</code></li>
<li class='green'><span class=''> </span><code>                        format(" ON DUPLICATE KEY UPDATE %s", updating.join(this._static.COMMA_SEPARATOR));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Support FOR SHARE locking when using the :share lock style.</code></li>
<li class='green'><span class=''> </span><code>        _selectLockSql:function (sql) {</code></li>
<li class='green'><span class='hits'>86</span><code>            return this.__opts.lock === "share" ? this._static.FOR_SHARE : this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Delete rows matching this dataset</code></li>
<li class='green'><span class=''> </span><code>        remove:function () {</code></li>
<li class='green'><span class='hits'>10</span><code>            return  this.executeDui(this.deleteSql).chain(function (c, info) {</code></li>
<li class='green'><span class='hits'>10</span><code>                return c.affectedRows;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        fetchRows:function (sql) {</code></li>
<li class='green'><span class='hits'>87</span><code>            return asyncArray(this.execute(sql).chain(function (r, fields) {</code></li>
<li class='green'><span class='hits'>87</span><code>                var i = -1;</code></li>
<li class='green'><span class='hits'>87</span><code>                var cols;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>87</span><code>                cols = fields.map(function (col) {</code></li>
<li class='green'><span class='hits'>304</span><code>                    var fieldName = col.name;</code></li>
<li class='green'><span class='hits'>304</span><code>                    var type = col.type;</code></li>
<li class='green'><span class='hits'>304</span><code>                    var length = col.fieldLength;</code></li>
<li class='green'><span class='hits'>304</span><code>                    return [this.outputIdentifier(fieldName), DB.convertMysqlType(type === 1 &amp;&amp; length !== 1 ? 2 : type), fieldName];</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>87</span><code>                this.__columns = cols.map(function (c) {</code></li>
<li class='green'><span class='hits'>304</span><code>                    return c[0];</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>87</span><code>                return this.__processRows(r, cols);</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __processRows:function (rows, cols) {</code></li>
<li class='green'><span class=''> </span><code>            //dp this so the callbacks are called in appropriate order also.</code></li>
<li class='green'><span class='hits'>87</span><code>            return comb(rows).map(function (row) {</code></li>
<li class='green'><span class='hits'>118</span><code>                var h = {};</code></li>
<li class='green'><span class='hits'>118</span><code>                cols.forEach(function (col) {</code></li>
<li class='green'><span class='hits'>468</span><code>                    h[col[0]] = col[1](row[col[2]]);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>115</span><code>                return h;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Don't allow graphing a dataset that splits multiple statements</code></li>
<li class='green'><span class=''> </span><code>        graph:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (this.__opts.splitMultipleResultSels) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new QueryError("Can't graph a dataset that splits multiple result sets");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Insert a new value into this dataset</code></li>
<li class='green'><span class=''> </span><code>        insert:function () {</code></li>
<li class='green'><span class='hits'>32</span><code>            return  this.executeDui(this.insertSql.apply(this, arguments)).chain(function (c, info) {</code></li>
<li class='green'><span class='hits'>32</span><code>                return c.insertId;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Replace (update or insert) the matching row.</code></li>
<li class='green'><span class=''> </span><code>        replace:function () {</code></li>
<li class='green'><span class='hits'>9</span><code>            return this.executeDui(this.replaceSql.apply(this, arguments)).chain(function (c, info) {</code></li>
<li class='green'><span class='hits'>9</span><code>                return c.insertId;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        splitMultipleResultSets:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (this.__opts.graph) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new QueryError("Can't split multiple statements on a graphed dataset");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ds = this.mergeOptions({splitMultipleResultSets:true});</code></li>
<li class='red'><span class='nohits'>0</span><code>            var rowCb = this.rowCb;</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (rowCb) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds.rowCb = function (x) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return x.map(rowCb, this);</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Update the matching rows.</code></li>
<li class='green'><span class=''> </span><code>        update:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.executeDui(this.updateSql.apply(this, arguments)).chain(function (c, info) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return c.affectedRows;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Set the :type option to select if it hasn't been set.</code></li>
<li class='green'><span class=''> </span><code>        execute:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>87</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>87</span><code>            return this._super([sql, merge({type:"select"}, opts)]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Set the :type option to :select if it hasn't been set.</code></li>
<li class='green'><span class=''> </span><code>        executeDui:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>59</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>59</span><code>            return this._super([sql, merge({type:"dui"}, opts)]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _literalString:function (v) {</code></li>
<li class='green'><span class='hits'>51</span><code>            return "'" + v.replace(/[\0\n\r\t\\\'\"\x1a]/g, function (s) {</code></li>
<li class='green'><span class='hits'>1</span><code>                switch (s) {</code></li>
<li class='green'><span class=''> </span><code>                    case "0":</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return "\\0";</code></li>
<li class='green'><span class=''> </span><code>                    case "\n":</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return "\\n";</code></li>
<li class='green'><span class=''> </span><code>                    case "\r":</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return "\\r";</code></li>
<li class='green'><span class=''> </span><code>                    case "\b":</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return "\\b";</code></li>
<li class='green'><span class=''> </span><code>                    case "\t":</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return "\\t";</code></li>
<li class='green'><span class=''> </span><code>                    case "\x1a":</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return "\\Z";</code></li>
<li class='green'><span class=''> </span><code>                    default:</code></li>
<li class='green'><span class='hits'>1</span><code>                        return "\\" + s;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }) + "'";</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        BOOL_TRUE:'1',</code></li>
<li class='green'><span class=''> </span><code>        BOOL_FALSE:'0',</code></li>
<li class='green'><span class=''> </span><code>        COMMA_SEPARATOR:', ',</code></li>
<li class='green'><span class=''> </span><code>        FOR_SHARE:' LOCK IN SHARE MODE',</code></li>
<li class='green'><span class=''> </span><code>        DELETE_CLAUSE_METHODS:Dataset.clauseMethods("delete", "qualify from where order limit"),</code></li>
<li class='green'><span class=''> </span><code>        INSERT_CLAUSE_METHODS:Dataset.clauseMethods("insert", "ignore into columns values onDuplicateKeyUpdate"),</code></li>
<li class='green'><span class=''> </span><code>        REPLACE_CLAUSE_METHODS:Dataset.clauseMethods("insert", "ignore into columns values onDuplicateKeyUpdate"),</code></li>
<li class='green'><span class=''> </span><code>        SELECT_CLAUSE_METHODS:Dataset.clauseMethods("select", "qualify distinct columns from join where group having compounds order limit lock"),</code></li>
<li class='green'><span class=''> </span><code>        UPDATE_CLAUSE_METHODS:Dataset.clauseMethods("update", "table set where order limit")</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var DB = define(Database, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        PRIMARY:'PRIMARY',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        type:"mysql",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsSavePoints:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsTransactionIsolationLevels:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        createConnection:function (opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            delete opts.query;</code></li>
<li class='green'><span class='hits'>3</span><code>            var conn = mysql.createConnection(merge({}, opts, {typeCast:false}));</code></li>
<li class='green'><span class=''> </span><code>            //conn.useDatabase(opts.database)</code></li>
<li class='green'><span class='hits'>3</span><code>            return new Connection(conn);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        closeConnection:function (conn) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return conn.closeConnection();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        validate:function (conn) {</code></li>
<li class='green'><span class='hits'>277</span><code>            return new Promise().callback(true).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        execute:function (sql, opts, conn) {</code></li>
<li class='green'><span class='hits'>277</span><code>            return when(conn || this._getConnection()).chain(function (conn) {</code></li>
<li class='green'><span class='hits'>277</span><code>                return this.__execute(conn, sql, opts);</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __execute:function (conn, sql, opts, cb) {</code></li>
<li class='green'><span class='hits'>277</span><code>            return this.__logAndExecute(sql, comb("query").bindIgnore(conn, sql))</code></li>
<li class='green'><span class=''> </span><code>                .both(comb("_returnConnection").bindIgnore(this, conn));</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // MySQL's cast rules are restrictive in that you can't just cast to any possible</code></li>
<li class='green'><span class=''> </span><code>        // database type.</code></li>
<li class='green'><span class=''> </span><code>        castTypeLiteral:function (type) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ret = null, meth;</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (isString(type)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = this._static.CAST_TYPES[type] || this._super(arguments);</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (type === String) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                meth += "CHAR";</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (type === Number) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                meth += "DECIMAL";</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (type === DateTime) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                meth += "DATETIME";</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (type === Year) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                meth += "Year";</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (type === Time) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                meth += "DATETIME";</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (type === Double) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                meth += "DECIMAL";</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return  ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Use SHOW INDEX FROM to get the index information for the table.</code></li>
<li class='green'><span class=''> </span><code>        indexes:function (table, opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            var indexes = {};</code></li>
<li class='green'><span class='hits'>3</span><code>            var removeIndexes = [];</code></li>
<li class='green'><span class='hits'>3</span><code>            var m = this.outputIdentifierFunc;</code></li>
<li class='green'><span class='hits'>3</span><code>            var im = this.inputIdentifierFunc;</code></li>
<li class='green'><span class='hits'>3</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>3</span><code>            this.metadataDataset.withSql("SHOW INDEX FROM ?", isInstanceOf(table, sql.Identifier) ? table : sql.identifier(im(table)))</code></li>
<li class='green'><span class=''> </span><code>                .forEach(function (r) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    var name = r[m("Key_name")];</code></li>
<li class='green'><span class='hits'>2</span><code>                    if (name !== "PRIMARY") {</code></li>
<li class='green'><span class='hits'>2</span><code>                        name = m(name);</code></li>
<li class='green'><span class='hits'>2</span><code>                        if (r[m("Sub_part")]) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            removeIndexes.push(name);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>2</span><code>                        var i = indexes[name] || (indexes[name] = {columns:[], unique:r[m("Non_unique")] !== 1});</code></li>
<li class='green'><span class='hits'>2</span><code>                        i.columns.push(m(r[m("Column_name")]));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }).then(function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                    var r = {};</code></li>
<li class='green'><span class='hits'>3</span><code>                    for (var i in indexes) {</code></li>
<li class='green'><span class='hits'>2</span><code>                        if (removeIndexes.indexOf(i) === -1) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            r[i] = indexes[i];</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>3</span><code>                    ret.callback(r);</code></li>
<li class='green'><span class=''> </span><code>                }, ret);</code></li>
<li class='green'><span class='hits'>3</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Get version of MySQL server, used for determined capabilities.</code></li>
<li class='green'><span class=''> </span><code>        serverVersion:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>1</span><code>            if (!this.__serverVersion) {</code></li>
<li class='green'><span class='hits'>1</span><code>                this.get(sql.version().sqlFunction).then(hitch(this, function (version) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    var m = version.match(/(\d+)\.(\d+)\.(\d+)/);</code></li>
<li class='green'><span class='hits'>1</span><code>                    this._serverVersion = (parseInt(m[1], 10) * 10000) + (parseInt(m[2], 10) * 100) + parseInt(m[3], 10);</code></li>
<li class='green'><span class='hits'>1</span><code>                    ret.callback(this._serverVersion);</code></li>
<li class='green'><span class=''> </span><code>                }), ret);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.callback(this._serverVersion);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Return an array of strings specifying table names in the current database.</code></li>
<li class='green'><span class=''> </span><code>        tables:function (opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var m = this.outputIdentifierFunc;</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.metadataDataset.withSql('SHOW TABLES').map(function (r) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return  m(r[Object.keys(r)[0]]);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        use:function (dbName) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ret = new Promise();</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.disconnect().then(hitch(this, function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                this.run("USE " + dbName).then(hitch(this, function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    this.opts.database = dbName;</code></li>
<li class='red'><span class='nohits'>0</span><code>                    this.schemas = {};</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret.callback(this);</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            }), ret);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Use MySQL specific syntax for rename column, set column type, and</code></li>
<li class='green'><span class=''> </span><code>        // drop index cases.</code></li>
<li class='green'><span class=''> </span><code>        __alterTableSql:function (table, op) {</code></li>
<li class='green'><span class='hits'>21</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>21</span><code>            if (op.op === "addColumn") {</code></li>
<li class='green'><span class='hits'>7</span><code>                var related = op.table;</code></li>
<li class='green'><span class='hits'>7</span><code>                if (related) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    delete op.table;</code></li>
<li class='green'><span class='hits'>2</span><code>                    this._super(arguments).then(hitch(this, function (sql) {</code></li>
<li class='green'><span class='hits'>2</span><code>                        op.table = related;</code></li>
<li class='green'><span class='hits'>2</span><code>                        ret.callback([sql, format("ALTER TABLE %s ADD FOREIGN KEY (%s)%s",</code></li>
<li class='green'><span class=''> </span><code>                            this.__quoteSchemaTable(table), this.__quoteIdentifier(op.name),</code></li>
<li class='green'><span class=''> </span><code>                            this.__columnReferencesSql(op))]);</code></li>
<li class='green'><span class=''> </span><code>                    }), ret);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>5</span><code>                    ret = this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>14</span><code>            } else if (['renameColumn', "setColumnType", "setColumnNull", "setColumnDefault"].indexOf(op.op) !== -1) {</code></li>
<li class='green'><span class='hits'>11</span><code>                var o = op.op;</code></li>
<li class='green'><span class='hits'>11</span><code>                this.schema(table).then(hitch(this, function (schema) {</code></li>
<li class='green'><span class='hits'>11</span><code>                    var name = op.name;</code></li>
<li class='green'><span class='hits'>11</span><code>                    var opts = schema[Object.keys(schema).filter(function (i) {</code></li>
<li class='green'><span class='hits'>28</span><code>                        return i === name;</code></li>
<li class='green'><span class=''> </span><code>                    })[0]];</code></li>
<li class='green'><span class='hits'>11</span><code>                    opts = merge({}, opts || {});</code></li>
<li class='green'><span class='hits'>11</span><code>                    opts.name = op.newName || name;</code></li>
<li class='green'><span class='hits'>11</span><code>                    opts.type = op.type || opts.dbType;</code></li>
<li class='green'><span class='hits'>11</span><code>                    opts.allowNull = isUndefined(op["null"]) ? opts.allowNull : op["null"];</code></li>
<li class='green'><span class='hits'>11</span><code>                    opts["default"] = op["default"] || opts.jsDefault;</code></li>
<li class='green'><span class='hits'>11</span><code>                    if (isUndefinedOrNull(opts["default"])) {</code></li>
<li class='green'><span class='hits'>5</span><code>                        delete opts["default"];</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>11</span><code>                    ret.callback(format("ALTER TABLE %s CHANGE COLUMN %s %s", this.__quoteSchemaTable(table),</code></li>
<li class='green'><span class=''> </span><code>                        this.__quoteIdentifier(op.name), this.__columnDefinitionSql(merge(op, opts))));</code></li>
<li class='green'><span class=''> </span><code>                }), ret);</code></li>
<li class='green'><span class='hits'>3</span><code>            } else if (op.op === "dropIndex") {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.callback(format("%s ON %s", this.__dropIndexSql(table, op), this.__quoteSchemaTable(table)));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                ret = this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>21</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL needs to set transaction isolation before beginning a transaction</code></li>
<li class='green'><span class=''> </span><code>        __beginNewTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>9</span><code>            return this.__setTransactionIsolation(conn, opts)</code></li>
<li class='green'><span class=''> </span><code>                .chain(comb("__logConnectionExecute").bindIgnore(this, conn, this.beginTransactionSql));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Use XA START to start a new prepared transaction if the :prepare</code></li>
<li class='green'><span class=''> </span><code>        //option is given.</code></li>
<li class='green'><span class=''> </span><code>        __beginTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>9</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>9</span><code>            var s;</code></li>
<li class='green'><span class='hits'>9</span><code>            if ((s = opts.prepare)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__logConnectionExecute(conn, comb("XA START %s").format(this.literal(s)));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>9</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // MySQL doesn't allow default values on text columns, so ignore if it the</code></li>
<li class='green'><span class=''> </span><code>        // generic text type is used</code></li>
<li class='green'><span class=''> </span><code>        __columnDefinitionSql:function (column) {</code></li>
<li class='green'><span class='hits'>144</span><code>            if (isString(column.type) &amp;&amp; column.type.match(/string/i) &amp;&amp; column.text) {</code></li>
<li class='green'><span class='hits'>1</span><code>                delete column["default"];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>144</span><code>            return this._super(arguments, [column]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Prepare the XA transaction for a two-phase commit if the</code></li>
<li class='green'><span class=''> </span><code>        // prepare option is given.</code></li>
<li class='green'><span class=''> </span><code>        __commitTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>9</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>9</span><code>            var s = opts.prepare;</code></li>
<li class='green'><span class='hits'>9</span><code>            if (s) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__logConnectionExecute(conn, comb("XA END %s").format(this.literal(s)))</code></li>
<li class='green'><span class=''> </span><code>                    .chain(comb("__logConnectionExecute").bindIgnore(this, comb("XA PREPARE %s").format(this.literal(s))))</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>9</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Use MySQL specific syntax for engine type and character encoding</code></li>
<li class='green'><span class=''> </span><code>        __createTableSql:function (name, generator, options) {</code></li>
<li class='green'><span class='hits'>48</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>48</span><code>            var engine = options.engine, charset = options.charset, collate = options.collate;</code></li>
<li class='green'><span class='hits'>48</span><code>            if (isUndefined(engine)) {</code></li>
<li class='green'><span class='hits'>40</span><code>                engine = this._static.defaultEngine;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>48</span><code>            if (isUndefined(charset)) {</code></li>
<li class='green'><span class='hits'>43</span><code>                charset = this._static.defaultCharset;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>48</span><code>            if (isUndefined(collate)) {</code></li>
<li class='green'><span class='hits'>46</span><code>                collate = this._static.defaultCollate;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>48</span><code>            generator.columns.forEach(function (c) {</code></li>
<li class='green'><span class='hits'>126</span><code>                var t = c.table;</code></li>
<li class='green'><span class='hits'>126</span><code>                if (t) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    delete c.table;</code></li>
<li class='green'><span class='hits'>2</span><code>                    generator.foreignKey([c.name], t, merge({}, c, {name:null, type:"foreignKey"}));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>48</span><code>            return format(" %s%s%s%s", this._super(arguments), engine ? " ENGINE=" + engine : "",</code></li>
<li class='green'><span class=''> </span><code>                charset ? " DEFAULT CHARSET=" + charset : "", collate ? " DEFAULT COLLATE=" + collate : "");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Handle MySQL specific index SQL syntax</code></li>
<li class='green'><span class=''> </span><code>        __indexDefinitionSql:function (tableName, index) {</code></li>
<li class='green'><span class='hits'>7</span><code>            var indexName = this.__quoteIdentifier(index.name || this.__defaultIndexName(tableName,</code></li>
<li class='green'><span class=''> </span><code>                index.columns)), t = index.type, using = "";</code></li>
<li class='green'><span class='hits'>7</span><code>            var indexType = "";</code></li>
<li class='green'><span class='hits'>7</span><code>            if (t === "fullText") {</code></li>
<li class='green'><span class='hits'>2</span><code>                indexType = "FULLTEXT ";</code></li>
<li class='green'><span class='hits'>5</span><code>            } else if (t === "spatial") {</code></li>
<li class='green'><span class='hits'>1</span><code>                indexType = "SPATIAL ";</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>4</span><code>                indexType = index.unique ? "UNIQUE " : "";</code></li>
<li class='green'><span class='hits'>4</span><code>                using = t ? " USING " + t : "";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>7</span><code>            return format("CREATE %sINDEX %s%s ON %s %s", indexType, indexName, using,</code></li>
<li class='green'><span class=''> </span><code>                this.__quoteSchemaTable(tableName), this.literal(index.columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    return isString(c) ? sql.identifier(c) : c;</code></li>
<li class='green'><span class=''> </span><code>                })));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Rollback the currently open XA transaction</code></li>
<li class='green'><span class=''> </span><code>        __rollbackTransaction:function (conn, opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            opts = opts || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            var s = opts.prepare;</code></li>
<li class='red'><span class='nohits'>0</span><code>            var logConnectionExecute = comb("__logConnectionExecute");</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (s) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                s = this.literal(s);</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__logConnectionExecute(conn, "XA END " + s)</code></li>
<li class='green'><span class=''> </span><code>                    .chain(logConnectionExecute.bindIngore(this, conn, "XA PREPARE " + s))</code></li>
<li class='green'><span class=''> </span><code>                    .chain(logConnectionExecute.bindIngore(this, conn, "XA ROLLBACK " + s))</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // MySQL treats integer primary keys as autoincrementing.</code></li>
<li class='green'><span class=''> </span><code>        _schemaAutoincrementingPrimaryKey:function (schema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this._super(arguments) &amp;&amp; schema.dbType.match(/int/i);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Use the MySQL specific DESCRIBE syntax to get a table description.</code></li>
<li class='green'><span class=''> </span><code>        schemaParseTable:function (tableName, opts) {</code></li>
<li class='green'><span class='hits'>15</span><code>            var m = this.outputIdentifierFunc;</code></li>
<li class='green'><span class='hits'>15</span><code>            var im = this.inputIdentifierFunc;</code></li>
<li class='green'><span class='hits'>15</span><code>            return this.metadataDataset.withSql("DESCRIBE ?", sql.identifier(im(tableName))).map(hitch(this,</code></li>
<li class='green'><span class=''> </span><code>                function (row) {</code></li>
<li class='green'><span class='hits'>39</span><code>                    var ret = {};</code></li>
<li class='green'><span class='hits'>39</span><code>                    var e = row[m("Extra")];</code></li>
<li class='green'><span class='hits'>39</span><code>                    var allowNull = row[m("Null")];</code></li>
<li class='green'><span class='hits'>39</span><code>                    var key = row[m("Key")];</code></li>
<li class='green'><span class='hits'>39</span><code>                    ret.autoIncrement = e.match(/auto_increment/i) !== null;</code></li>
<li class='green'><span class='hits'>39</span><code>                    ret.allowNull = allowNull.match(/Yes/i) !== null;</code></li>
<li class='green'><span class='hits'>39</span><code>                    ret.primaryKey = key.match(/PRI/i) !== null;</code></li>
<li class='green'><span class='hits'>39</span><code>                    var defaultValue = row[m("Default")];</code></li>
<li class='green'><span class='hits'>39</span><code>                    ret["default"] = Buffer.isBuffer(defaultValue) ? defaultValue.toString() : defaultValue;</code></li>
<li class='green'><span class='hits'>39</span><code>                    if (isEmpty(row["default"])) {</code></li>
<li class='green'><span class='hits'>39</span><code>                        row["default"] = null;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>39</span><code>                    ret.dbType = row[m("Type")];</code></li>
<li class='green'><span class='hits'>39</span><code>                    if (Buffer.isBuffer(ret.dbType)) {</code></li>
<li class='green'><span class=''> </span><code>                        //handle case for field type being returned at 252  (i.e. BLOB)</code></li>
<li class='green'><span class='hits'>39</span><code>                        ret.dbType = ret.dbType.toString();</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>39</span><code>                    ret.type = this.schemaColumnType(ret.dbType.toString("utf8"));</code></li>
<li class='green'><span class='hits'>39</span><code>                    var fieldName = m(row[m("Field")]);</code></li>
<li class='green'><span class='hits'>39</span><code>                    return [fieldName, ret];</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Convert tinyint(1) type to boolean if convert_tinyint_to_bool is true</code></li>
<li class='green'><span class=''> </span><code>        schemaColumnType:function (dbType) {</code></li>
<li class='green'><span class='hits'>39</span><code>            return this._static.convertTinyintToBool &amp;&amp; dbType === 'tinyint(1)' ? "boolean" : this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //MySQL doesn't have a true boolean class, so it uses tinyint(1)</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericBoolean:function (column) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return 'tinyint(1)';</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethodDefault:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethodDefault:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            connectionExecuteMethod:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>                return "query";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            dataset:function () {</code></li>
<li class='green'><span class='hits'>176</span><code>                return new DS(this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        __convertTinyintToBool:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __convertInvalidDateTime:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        CAST_TYPES:{string:"CHAR", integer:"SIGNED", time:"DATETIME", datetime:"DATETIME", numeric:"DECIMAL"},</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        AUTOINCREMENT:'AUTO_INCREMENT',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        init:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            this.setAdapterType("mysql");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        FIELD_TYPES:{</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_DECIMAL:0x00,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_TINY:0x01,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_SHORT:0x02,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_LONG:0x03,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_FLOAT:0x04,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_DOUBLE:0x05,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_NULL:0x06,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_TIMESTAMP:0x07,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_LONGLONG:0x08,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_INT24:0x09,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_DATE:0x0a,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_TIME:0x0b,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_DATETIME:0x0c,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_YEAR:0x0d,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_NEWDATE:0x0e,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_VARCHAR:0x0f,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_BIT:0x10,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_NEWDECIMAL:0xf6,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_ENUM:0xf7,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_SET:0xf8,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_TINY_BLOB:0xf9,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_MEDIUM_BLOB:0xfa,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_LONG_BLOB:0xfb,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_BLOB:0xfc,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_VAR_STRING:0xfd,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_STRING:0xfe,</code></li>
<li class='green'><span class=''> </span><code>            FIELD_TYPE_GEOMETRY:0xff</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        convertMysqlType:function (type) {</code></li>
<li class='green'><span class='hits'>304</span><code>            var convert = this.convertTinyintToBool, convertDateTime = this.__convertInvalidDateTime;</code></li>
<li class='green'><span class='hits'>304</span><code>            if (!patio) {</code></li>
<li class='green'><span class='hits'>1</span><code>                patio = require("../index");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>304</span><code>            return hitch(this.FIELD_TYPES, function (type, o) {</code></li>
<li class='green'><span class='hits'>468</span><code>                var ret = o;</code></li>
<li class='green'><span class='hits'>468</span><code>                if (o !== null) {</code></li>
<li class='green'><span class='hits'>347</span><code>                    switch (type) {</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_TIMESTAMP:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_DATETIME:</code></li>
<li class='green'><span class='hits'>5</span><code>                            ret = convertDate(o, "stringToDateTime", convertDateTime);</code></li>
<li class='green'><span class='hits'>4</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_DATE:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_NEWDATE:</code></li>
<li class='green'><span class='hits'>5</span><code>                            ret = convertDate(o, "stringToDate", convertDateTime);</code></li>
<li class='green'><span class='hits'>4</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_TIME:</code></li>
<li class='green'><span class='hits'>5</span><code>                            ret = convertDate(o, "stringToTime", convertDateTime);</code></li>
<li class='green'><span class='hits'>4</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_TINY:</code></li>
<li class='green'><span class='hits'>3</span><code>                            ret = convert ? parseInt(o, 10) === 1 : parseInt(o, 10);</code></li>
<li class='green'><span class='hits'>3</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_YEAR:</code></li>
<li class='red'><span class='nohits'>0</span><code>                            ret = convertDate(o, "stringToYear", convertDateTime);</code></li>
<li class='red'><span class='nohits'>0</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_SHORT:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_LONG:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_LONGLONG:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_INT24:</code></li>
<li class='green'><span class='hits'>68</span><code>                            ret = parseInt(o, 10);</code></li>
<li class='green'><span class='hits'>68</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_FLOAT:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_DOUBLE:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_DECIMAL:</code></li>
<li class='green'><span class=''> </span><code>                            // decimal types cannot be parsed as floats because</code></li>
<li class='green'><span class=''> </span><code>                            // V8 Numbers have less precision than some MySQL Decimals</code></li>
<li class='green'><span class='hits'>1</span><code>                            ret = parseFloat(o);</code></li>
<li class='green'><span class='hits'>1</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_TINY_BLOB:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_MEDIUM_BLOB:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_LONG_BLOB:</code></li>
<li class='green'><span class=''> </span><code>                        case this.FIELD_TYPE_BLOB:</code></li>
<li class='green'><span class='hits'>68</span><code>                            ret = new Buffer(o);</code></li>
<li class='green'><span class='hits'>68</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>465</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            }, type);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            convertTinyintToBool:function () {</code></li>
<li class='green'><span class='hits'>343</span><code>                return this.__convertTinyintToBool;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            convertInvalidDateTime:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__convertInvalidDateTime;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            convertTinyintToBool:function (convert) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                this.__convertTinyintToBool = convert;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            convertInvalidDateTime:function (convert) {</code></li>
<li class='green'><span class='hits'>8</span><code>                this.__convertInvalidDateTime = convert;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "MySQLDatabase");</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="plugins/query.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/query.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>82.31</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>655</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>130</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>23</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/query.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    asyncArray = comb.async.array,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    Dataset = require("../dataset"),</code></li>
<li class='green'><span class=''> </span><code>    ModelError = require("../errors").ModelError,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    hitchIgnore = comb.hitchIgnore,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var QueryPlugin = comb.define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Model.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getPrimaryKeyQuery:function () {</code></li>
<li class='green'><span class='hits'>2023</span><code>            var q = {}, pk = this.primaryKey;</code></li>
<li class='green'><span class='hits'>2023</span><code>            for (var i = 0, l = pk.length; i &lt; l; i++) {</code></li>
<li class='green'><span class='hits'>2023</span><code>                var k = pk[i];</code></li>
<li class='green'><span class='hits'>2023</span><code>                q[k] = this[k];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2023</span><code>            return q;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _clearPrimaryKeys:function () {</code></li>
<li class='green'><span class='hits'>535</span><code>            var pk = this.primaryKey;</code></li>
<li class='green'><span class='hits'>535</span><code>            for (var i = 0, l = pk.length; i &lt; l; i++) {</code></li>
<li class='green'><span class='hits'>535</span><code>                this.__values[pk[i]] = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        reload:function () {</code></li>
<li class='green'><span class='hits'>15</span><code>            if (this.synced) {</code></li>
<li class='green'><span class='hits'>15</span><code>                return serial([</code></li>
<li class='green'><span class=''> </span><code>                    this._hook.bind(this, "pre", "load"),</code></li>
<li class='green'><span class=''> </span><code>                    this.__reload.bind(this),</code></li>
<li class='green'><span class=''> </span><code>                    this._hook.bind(this, "post", "load")</code></li>
<li class='green'><span class=''> </span><code>                ]).chain(this);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("Model " + this.tableName + " has not been synced");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Forces the reload of the data for a particular model instance.  The Promise returned is resolved with the</code></li>
<li class='green'><span class=''> </span><code>         * model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * myModel.reload().then(function(model){</code></li>
<li class='green'><span class=''> </span><code>         *    //model === myModel</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} resolved with the model instance.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __reload:function () {</code></li>
<li class='green'><span class='hits'>1317</span><code>            if (!this.__isNew) {</code></li>
<li class='green'><span class='hits'>1317</span><code>                return this.dataset.naked().filter(this._getPrimaryKeyQuery()).one().chain(function (values) {</code></li>
<li class='green'><span class='hits'>1317</span><code>                    this.__setFromDb(values, true);</code></li>
<li class='green'><span class='hits'>1317</span><code>                    return this;</code></li>
<li class='green'><span class=''> </span><code>                }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return when(this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This method removes the instance of the model. If the model {@link patio.Model#isNew} then the promise is</code></li>
<li class='green'><span class=''> </span><code>         * resolved with a 0 indicating no rows were affected. Otherwise the model is removed, primary keys are cleared</code></li>
<li class='green'><span class=''> </span><code>         * and the model's isNew flag is set to true.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * myModel.remove().then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //model is deleted</code></li>
<li class='green'><span class=''> </span><code>         *     assert.isTrue(myModel.isNew);</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //dont use a transaction to remove this model</code></li>
<li class='green'><span class=''> </span><code>         * myModel.remove({transaction : false}).then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //model is deleted</code></li>
<li class='green'><span class=''> </span><code>         *     assert.isTrue(myModel.isNew);</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.transaction] boolean indicating if a transaction should be used when</code></li>
<li class='green'><span class=''> </span><code>         * removing the model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called back after the deletion is successful.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        remove:function (options) {</code></li>
<li class='green'><span class='hits'>535</span><code>            if (this.synced) {</code></li>
<li class='green'><span class='hits'>535</span><code>                if (!this.__isNew) {</code></li>
<li class='green'><span class='hits'>535</span><code>                    return this._checkTransaction(options, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>535</span><code>                        return serial([</code></li>
<li class='green'><span class=''> </span><code>                            this._hook.bind(this, "pre", "remove", [options]),</code></li>
<li class='green'><span class=''> </span><code>                            this._remove.bind(this, options),</code></li>
<li class='green'><span class=''> </span><code>                            this._hook.bind(this, "post", "remove", [options]),</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>535</span><code>                                this._clearPrimaryKeys();</code></li>
<li class='green'><span class='hits'>535</span><code>                                this.__isNew = true;</code></li>
<li class='green'><span class='hits'>535</span><code>                                if (this._static.emitOnRemove) {</code></li>
<li class='green'><span class='hits'>535</span><code>                                    this.emit("remove", this);</code></li>
<li class='green'><span class='hits'>535</span><code>                                    this._static.emit("remove", this);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this)</code></li>
<li class='green'><span class=''> </span><code>                        ]).chain(this);</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return when(0);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("Model " + this.tableName + " has not been synced");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _remove:function () {</code></li>
<li class='green'><span class='hits'>529</span><code>            return this.dataset.filter(this._getPrimaryKeyQuery()).remove();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Called after a save action to reload the model properties,</code></li>
<li class='green'><span class=''> </span><code>         * abstracted out so this can be overidden by sub classes</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _saveReload:function (options) {</code></li>
<li class='green'><span class='hits'>1144</span><code>            options || (options = {});</code></li>
<li class='green'><span class='hits'>1144</span><code>            var reload = isBoolean(options.reload) ? options.reload : this._static.reloadOnSave;</code></li>
<li class='green'><span class='hits'>1144</span><code>            return reload ? this.__reload() : when(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Called after an update action to reload the model properties,</code></li>
<li class='green'><span class=''> </span><code>         * abstracted out so this can be overidden by sub classes</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _updateReload:function (options) {</code></li>
<li class='green'><span class='hits'>162</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>162</span><code>            options || (options = {});</code></li>
<li class='green'><span class='hits'>162</span><code>            var reload = isBoolean(options.reload) ? options.reload : this._static.reloadOnUpdate;</code></li>
<li class='green'><span class='hits'>162</span><code>            return reload ? this.__reload() : when(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Updates a model. This action checks if the model is not new and values have changed.</code></li>
<li class='green'><span class=''> </span><code>         * If the model is new then the {@link patio.Model#save} action is called.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * When updating a model you can pass values you want set as the first argument.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * someModel.update({</code></li>
<li class='green'><span class=''> </span><code>         *      myVal1 : "newValue1",</code></li>
<li class='green'><span class=''> </span><code>         *      myVal2 : "newValue2",</code></li>
<li class='green'><span class=''> </span><code>         *      myVal3 : "newValue3"</code></li>
<li class='green'><span class=''> </span><code>         * }).then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      //do something</code></li>
<li class='green'><span class=''> </span><code>         * }, errorHandler);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Or you can set values on the model directly</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * someModel.myVal1 = "newValue1";</code></li>
<li class='green'><span class=''> </span><code>         * someModel.myVal2 = "newValue2";</code></li>
<li class='green'><span class=''> </span><code>         * someModel.myVal3 = "newValue3";</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //update model with current values</code></li>
<li class='green'><span class=''> </span><code>         * someModel.update().then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //do something</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Update also accepts an options object as the second argument allowing the overriding of default behavior.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * To override &lt;code&gt;useTransactions&lt;/code&gt; you can set the &lt;code&gt;transaction&lt;/code&gt; option.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * someModel.update(null, {transaction : false});</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * You can also override the &lt;code&gt;reloadOnUpdate&lt;/code&gt; property by setting the &lt;code&gt;reload&lt;/code&gt; option.</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * someModel.update(null, {reload : false});</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [vals] optional values hash to set on the model before saving.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.transaction] boolean indicating if a transaction should be used when</code></li>
<li class='green'><span class=''> </span><code>         * updating the model.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.reload] boolean indicating if the model should be reloaded after the update. This will take</code></li>
<li class='green'><span class=''> </span><code>         * precedence over {@link patio.Model.reloadOnUpdate}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} resolved when the update action has completed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        update:function (vals, options) {</code></li>
<li class='green'><span class='hits'>158</span><code>            if (this.synced) {</code></li>
<li class='green'><span class='hits'>158</span><code>                if (!this.__isNew) {</code></li>
<li class='green'><span class='hits'>158</span><code>                    return this._checkTransaction(options, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>158</span><code>                        if (isHash(vals)) {</code></li>
<li class='green'><span class='hits'>107</span><code>                            this.__set(vals);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>158</span><code>                        var saveChange = !isEmpty(this.__changed);</code></li>
<li class='green'><span class='hits'>158</span><code>                        return serial([</code></li>
<li class='green'><span class=''> </span><code>                            this._hook.bind(this, "pre", "update", [options]),</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>158</span><code>                                return saveChange ? this._update(options) : null;</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this),</code></li>
<li class='green'><span class=''> </span><code>                            this._hook.bind(this, "post", "update", [options]),</code></li>
<li class='green'><span class=''> </span><code>                            this._updateReload.bind(this, options),</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>158</span><code>                                if (this._static.emitOnUpdate) {</code></li>
<li class='green'><span class='hits'>158</span><code>                                    this.emit("update", this);</code></li>
<li class='green'><span class='hits'>158</span><code>                                    this._static.emit("update", this);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this)</code></li>
<li class='green'><span class=''> </span><code>                        ]).chain(this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='red'><span class='nohits'>0</span><code>                } else if (this.__isNew &amp;&amp; this.__isChanged) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this.save(vals, options);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return when(this);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("Model " + this.tableName + " has not been synced");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _update:function (options) {</code></li>
<li class='green'><span class='hits'>139</span><code>            var ret = this.dataset.filter(this._getPrimaryKeyQuery()).update(this.__changed);</code></li>
<li class='green'><span class='hits'>139</span><code>            this.__changed = {};</code></li>
<li class='green'><span class='hits'>139</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Saves a model. This action checks if the model is new and values have changed.</code></li>
<li class='green'><span class=''> </span><code>         * If the model is not new then the {@link patio.Model#update} action is called.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * When saving a model you can pass values you want set as the first argument.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * someModel.save({</code></li>
<li class='green'><span class=''> </span><code>         *      myVal1 : "newValue1",</code></li>
<li class='green'><span class=''> </span><code>         *      myVal2 : "newValue2",</code></li>
<li class='green'><span class=''> </span><code>         *      myVal3 : "newValue3"</code></li>
<li class='green'><span class=''> </span><code>         * }).then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      //do something</code></li>
<li class='green'><span class=''> </span><code>         * }, errorHandler);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Or you can set values on the model directly</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * someModel.myVal1 = "newValue1";</code></li>
<li class='green'><span class=''> </span><code>         * someModel.myVal2 = "newValue2";</code></li>
<li class='green'><span class=''> </span><code>         * someModel.myVal3 = "newValue3";</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //update model with current values</code></li>
<li class='green'><span class=''> </span><code>         * someModel.save().then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //do something</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Save also accepts an options object as the second argument allowing the overriding of default behavior.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * To override &lt;code&gt;useTransactions&lt;/code&gt; you can set the &lt;code&gt;transaction&lt;/code&gt; option.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * someModel.save(null, {transaction : false});</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * You can also override the &lt;code&gt;reloadOnSave&lt;/code&gt; property by setting the &lt;code&gt;reload&lt;/code&gt; option.</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * someModel.save(null, {reload : false});</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [vals] optional values hash to set on the model before saving.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.transaction] boolean indicating if a transaction should be used when</code></li>
<li class='green'><span class=''> </span><code>         * saving the model.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.reload] boolean indicating if the model should be reloaded after the save. This will take</code></li>
<li class='green'><span class=''> </span><code>         * precedence over {@link patio.Model.reloadOnSave}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} resolved when the save action has completed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        save:function (vals, options) {</code></li>
<li class='green'><span class='hits'>1231</span><code>            if (this.synced) {</code></li>
<li class='green'><span class='hits'>1231</span><code>                if (this.__isNew) {</code></li>
<li class='green'><span class='hits'>1183</span><code>                    return this._checkTransaction(options, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>1183</span><code>                        if (isHash(vals)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            this.__set(vals);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>1183</span><code>                        return serial([</code></li>
<li class='green'><span class=''> </span><code>                            this._hook.bind(this, "pre", "save", [options]),</code></li>
<li class='green'><span class=''> </span><code>                            this._save.bind(this, options),</code></li>
<li class='green'><span class=''> </span><code>                            this._hook.bind(this, "post", "save", [options]),</code></li>
<li class='green'><span class=''> </span><code>                            this._saveReload.bind(this, options),</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>1139</span><code>                                if (this._static.emitOnSave) {</code></li>
<li class='green'><span class='hits'>1139</span><code>                                    this.emit("save", this);</code></li>
<li class='green'><span class='hits'>1139</span><code>                                    this._static.emit("save", this);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this)</code></li>
<li class='green'><span class=''> </span><code>                        ]).chain(this);</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>48</span><code>                    return this.update(vals, options);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("Model " + this.tableName + " has not been synced");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _save:function (options) {</code></li>
<li class='green'><span class='hits'>1134</span><code>            var pk = this._static.primaryKey[0];</code></li>
<li class='green'><span class='hits'>1134</span><code>            return this.dataset.insert(this._toObject()).chain(function (id) {</code></li>
<li class='green'><span class='hits'>1134</span><code>                this.__ignore = true;</code></li>
<li class='green'><span class='hits'>1134</span><code>                if (id) {</code></li>
<li class='green'><span class='hits'>1134</span><code>                    this[pk] = id;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1134</span><code>                this.__ignore = false;</code></li>
<li class='green'><span class='hits'>1134</span><code>                this.__isNew = false;</code></li>
<li class='green'><span class='hits'>1134</span><code>                this.__isChanged = false;</code></li>
<li class='green'><span class='hits'>1134</span><code>                return this;</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getUpdateSql:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.updateDataset.filter(this._getPrimaryKeyQuery()).updateSql(this.__changed);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getInsertSql:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.insertDataset.insertSql(this._toObject());</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getRemoveSql:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.removeDataset.filter(this._getPrimaryKeyQuery()).deleteSql;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            updateSql:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this.getUpdateSql();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            insertSql:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this.getInsertSql();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            removeSql:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                return this.getRemoveSql();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            deleteSql:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.removeSql;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Model*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent the emitting on an event when a model is saved.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        emitOnSave:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent the emitting on an event when a model is updated.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        emitOnUpdate:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent the emitting on an event when a model is removed.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        emitOnRemove:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Retrieves a record by the primaryKey/s of a table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var User = patio.getModel("user");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * User.findById(1).then(function(userOne){</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //assume the primary key is a compostie of first_name and last_name</code></li>
<li class='green'><span class=''> </span><code>         * User.findById(["greg", "yukon"]).then(function(userOne){</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} id the primary key of the record to find.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called back with the record or null if one is not found.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        findById:function (id) {</code></li>
<li class='green'><span class='hits'>3</span><code>            var pk = this.primaryKey;</code></li>
<li class='green'><span class='hits'>3</span><code>            pk = pk.length == 1 ? pk[0] : pk;</code></li>
<li class='green'><span class='hits'>3</span><code>            var q = {};</code></li>
<li class='green'><span class='hits'>3</span><code>            if (isArray(id) &amp;&amp; isArray(pk)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (id.length === pk.length) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    pk.forEach(function (k, i) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        q[k] = id[i];</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ModelError("findById : ids length does not equal the primaryKeys length.");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                q[pk] = id;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.filter(q).one();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Finds a single model according to the supplied filter.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Dataset#filter} for filter options.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param id</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        find:function (id) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.filter.apply(this, arguments).first();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Finds a single model according to the supplied filter.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Dataset#filter} for filter options. If the model</code></li>
<li class='green'><span class=''> </span><code>         * does not exist then a new one is created as passed back.</code></li>
<li class='green'><span class=''> </span><code>         * @param q</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        findOrCreate:function (q) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.find(q).chain(hitch(this, function (res) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return res || this.create(q);</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Update multiple rows with a set of values.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var User = patio.getModel("user");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //BEGIN</code></li>
<li class='green'><span class=''> </span><code>         * //UPDATE `user` SET `password` = NULL WHERE (`last_accessed` &lt;= '2011-01-27')</code></li>
<li class='green'><span class=''> </span><code>         * //COMMIT</code></li>
<li class='green'><span class=''> </span><code>         * User.update({password : null}, function(){</code></li>
<li class='green'><span class=''> </span><code>         *  return this.lastAccessed.lte(comb.date.add(new Date(), "year", -1));</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * //same as</code></li>
<li class='green'><span class=''> </span><code>         * User.update({password : null}, {lastAccess : {lte : comb.date.add(new Date(), "year", -1)}});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //UPDATE `user` SET `password` = NULL WHERE (`last_accessed` &lt;= '2011-01-27')</code></li>
<li class='green'><span class=''> </span><code>         * User.update({password : null}, function(){</code></li>
<li class='green'><span class=''> </span><code>         *  return this.lastAccessed.lte(comb.date.add(new Date(), "year", -1));</code></li>
<li class='green'><span class=''> </span><code>         * }, {transaction : false});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} vals a hash of values to update. See {@link patio.Dataset#update}.</code></li>
<li class='green'><span class=''> </span><code>         * @param query a filter to apply to the UPDATE.  See {@link patio.Dataset#filter}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.transaction] boolean indicating if a transaction should be used when</code></li>
<li class='green'><span class=''> </span><code>         * updating the models.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the update statement has completed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        update:function (vals, /*?object*/query, options) {</code></li>
<li class='green'><span class='hits'>2</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>2</span><code>            var args = comb(arguments).toArray();</code></li>
<li class='green'><span class='hits'>2</span><code>            return this._checkTransaction(options, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                var dataset = this.dataset;</code></li>
<li class='green'><span class='hits'>2</span><code>                if (!isUndefined(query)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    dataset = dataset.filter(query);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>2</span><code>                return dataset.update(vals);</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Remove(delete) models. This can be used to do a mass delete of models.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var User = patio.getModel("user");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //remove all users</code></li>
<li class='green'><span class=''> </span><code>         * User.remove();</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //remove all users who's names start with a.</code></li>
<li class='green'><span class=''> </span><code>         * User.remove({name : /A%/i});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //remove all users who's names start with a, without a transaction.</code></li>
<li class='green'><span class=''> </span><code>         * User.remove({name : /A%/i}, {transaction : false});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [q] query to filter the rows to remove. See {@link patio.Dataset#filter}.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.transaction] boolean indicating if a transaction should be used when</code></li>
<li class='green'><span class=''> </span><code>         * removing the models.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.load=true] boolean set to prevent the loading of each model. This is more efficient</code></li>
<li class='green'><span class=''> </span><code>         * but the pre/post remove hooks not be notified of the deletion.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called back when the removal completes.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        remove:function (q, options) {</code></li>
<li class='green'><span class='hits'>373</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>373</span><code>            var loadEach = isBoolean(options.load) ? options.load : true;</code></li>
<li class='green'><span class=''> </span><code>            //first find all records so we call alert the middleware for each model</code></li>
<li class='green'><span class='hits'>373</span><code>            return this._checkTransaction(options, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>373</span><code>                var ds = this.dataset;</code></li>
<li class='green'><span class='hits'>373</span><code>                ds = ds.filter.call(ds, q);</code></li>
<li class='green'><span class='hits'>373</span><code>                if (loadEach) {</code></li>
<li class='green'><span class='hits'>373</span><code>                    return ds.map(function (r) {</code></li>
<li class='green'><span class=''> </span><code>                        //todo this sucks find a better way!</code></li>
<li class='green'><span class='hits'>445</span><code>                        return r.remove(options);</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return ds.remove();</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Similar to remove but takes an id or an array for a composite key.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * User.removeById(1);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param id id or an array for a composite key, to find the model by</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.transaction] boolean indicating if a transaction should be used when</code></li>
<li class='green'><span class=''> </span><code>         * removing the model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called back when the removal completes.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        removeById:function (id, options) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this._checkTransaction(options, hitch(this, function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.findById(id).chain(function (model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return model.remove(options);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Save either a new model or list of models to the database.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var Student = patio.getModel("student");</code></li>
<li class='green'><span class=''> </span><code>         * Student.save([</code></li>
<li class='green'><span class=''> </span><code>         *      {</code></li>
<li class='green'><span class=''> </span><code>         *          firstName:"Bob",</code></li>
<li class='green'><span class=''> </span><code>         *          lastName:"Yukon",</code></li>
<li class='green'><span class=''> </span><code>         *          gpa:3.689,</code></li>
<li class='green'><span class=''> </span><code>         *          classYear:"Senior"</code></li>
<li class='green'><span class=''> </span><code>         *      },</code></li>
<li class='green'><span class=''> </span><code>         *      {</code></li>
<li class='green'><span class=''> </span><code>         *          firstName:"Greg",</code></li>
<li class='green'><span class=''> </span><code>         *          lastName:"Horn",</code></li>
<li class='green'><span class=''> </span><code>         *          gpa:3.689,</code></li>
<li class='green'><span class=''> </span><code>         *          classYear:"Sohpmore"</code></li>
<li class='green'><span class=''> </span><code>         *      },</code></li>
<li class='green'><span class=''> </span><code>         *      {</code></li>
<li class='green'><span class=''> </span><code>         *          firstName:"Sara",</code></li>
<li class='green'><span class=''> </span><code>         *          lastName:"Malloc",</code></li>
<li class='green'><span class=''> </span><code>         *          gpa:4.0,</code></li>
<li class='green'><span class=''> </span><code>         *          classYear:"Junior"</code></li>
<li class='green'><span class=''> </span><code>         *      },</code></li>
<li class='green'><span class=''> </span><code>         *      {</code></li>
<li class='green'><span class=''> </span><code>         *          firstName:"John",</code></li>
<li class='green'><span class=''> </span><code>         *          lastName:"Favre",</code></li>
<li class='green'><span class=''> </span><code>         *          gpa:2.867,</code></li>
<li class='green'><span class=''> </span><code>         *          classYear:"Junior"</code></li>
<li class='green'><span class=''> </span><code>         *      },</code></li>
<li class='green'><span class=''> </span><code>         *      {</code></li>
<li class='green'><span class=''> </span><code>         *          firstName:"Kim",</code></li>
<li class='green'><span class=''> </span><code>         *          lastName:"Bim",</code></li>
<li class='green'><span class=''> </span><code>         *          gpa:2.24,</code></li>
<li class='green'><span class=''> </span><code>         *          classYear:"Senior"</code></li>
<li class='green'><span class=''> </span><code>         *      },</code></li>
<li class='green'><span class=''> </span><code>         *      {</code></li>
<li class='green'><span class=''> </span><code>         *          firstName:"Alex",</code></li>
<li class='green'><span class=''> </span><code>         *          lastName:"Young",</code></li>
<li class='green'><span class=''> </span><code>         *          gpa:1.9,</code></li>
<li class='green'><span class=''> </span><code>         *          classYear:"Freshman"</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         * ]).then(function(users){</code></li>
<li class='green'><span class=''> </span><code>         *     //work with the users</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Save a single record</code></li>
<li class='green'><span class=''> </span><code>         * MyModel.save(m1);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Model|Object|patio.Model[]|Object[]} record the record/s to save.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.transaction] boolean indicating if a transaction should be used when</code></li>
<li class='green'><span class=''> </span><code>         * saving the models.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} called back with the saved record/s.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        save:function (items, options) {</code></li>
<li class='green'><span class='hits'>40</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>40</span><code>            var isArr = isArray(items);</code></li>
<li class='green'><span class='hits'>40</span><code>            return this._checkTransaction(options, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>40</span><code>                return asyncArray(items).map(function (o) {</code></li>
<li class='green'><span class='hits'>537</span><code>                    if (!isInstanceOf(o, this)) {</code></li>
<li class='green'><span class='hits'>57</span><code>                        o = new this(o);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>537</span><code>                    return o.save(null, options);</code></li>
<li class='green'><span class=''> </span><code>                }, this).chain(function (res) {</code></li>
<li class='green'><span class='hits'>40</span><code>                        return isArr ? res : res[0];</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "QueryPlugin");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>Dataset.ACTION_METHODS.concat(Dataset.QUERY_METHODS).forEach(function (m) {</code></li>
<li class='green'><span class='hits'>162</span><code>    if (!QueryPlugin[m]) {</code></li>
<li class='green'><span class='hits'>98</span><code>        QueryPlugin[m] = function () {</code></li>
<li class='green'><span class='hits'>358</span><code>            if (this.synced) {</code></li>
<li class='green'><span class='hits'>358</span><code>                var ds = this.dataset;</code></li>
<li class='green'><span class='hits'>358</span><code>                return ds[m].apply(ds, arguments);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("Model " + this.tableName + " has not been synced");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="database/connect.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/connect.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>83.67</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>154</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>49</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>8</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/connect.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("../errors"),</code></li>
<li class='green'><span class=''> </span><code>    NotImplemented = errors.NotImplemented,</code></li>
<li class='green'><span class=''> </span><code>    URL = require("url"),</code></li>
<li class='green'><span class=''> </span><code>    DatabaseError = errors.DatabaseError;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var ADAPTERS = {};</code></li>
<li class='green'><span class='hits'>1</span><code>var DB = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Disconnects the database closing all connections.</code></li>
<li class='green'><span class=''> </span><code>          * @return Promise a promise that is resolved once all the connections have been closed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        disconnect:function () {</code></li>
<li class='green'><span class='hits'>41</span><code>            return this.pool.endAll().then(this.onDisconnect.bind(this, this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        onDisconnect:function () {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This is an abstract method that should be implemented by adapters to create</code></li>
<li class='green'><span class=''> </span><code>         * a connection to the database.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} options options that are adapter specific.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        createConnection:function (options) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new NotImplemented("Create connection must be implemented by the adapter");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This is an abstract method that should be implemented by adapters to close</code></li>
<li class='green'><span class=''> </span><code>         * a connection to the database.</code></li>
<li class='green'><span class=''> </span><code>         * @param conn the database connection to close.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        closeConnection:function (conn) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new NotImplemented("Close connection must be implemented by the adapter");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Validates a connection before it is returned to the {@link patio.ConnectionPool}. This</code></li>
<li class='green'><span class=''> </span><code>         * method should be implemented by the adapter.</code></li>
<li class='green'><span class=''> </span><code>         * @param conn</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        validate:function (conn) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new NotImplemented("Validate must be implemented by the adapter");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            uri:function () {</code></li>
<li class='green'><span class=''> </span><code>                /**</code></li>
<li class='green'><span class=''> </span><code>                 * @ignore</code></li>
<li class='green'><span class=''> </span><code>                 */</code></li>
<li class='green'><span class='hits'>2</span><code>                if (!this.opts.uri) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var opts = {</code></li>
<li class='green'><span class=''> </span><code>                        protocol:this.type,</code></li>
<li class='green'><span class=''> </span><code>                        hostname:this.opts.host,</code></li>
<li class='green'><span class=''> </span><code>                        auth:format("{user}:{password}", this.opts),</code></li>
<li class='green'><span class=''> </span><code>                        port:this.opts.port,</code></li>
<li class='green'><span class=''> </span><code>                        pathname:"/" + this.opts.database</code></li>
<li class='green'><span class=''> </span><code>                    };</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return URL.format(opts);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>2</span><code>                return this.opts.uri;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            url:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.uri;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a connection to a Database see {@link patio#createConnection}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        connect:function (connectionString, opts) {</code></li>
<li class='green'><span class='hits'>41</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>41</span><code>            if (isString(connectionString)) {</code></li>
<li class='green'><span class='hits'>41</span><code>                var url = URL.parse(connectionString, true);</code></li>
<li class='green'><span class='hits'>41</span><code>                if (url.auth) {</code></li>
<li class='green'><span class='hits'>40</span><code>                    var parts = url.auth.split(":");</code></li>
<li class='green'><span class='hits'>40</span><code>                    if (!opts.user) {</code></li>
<li class='green'><span class='hits'>40</span><code>                        opts.user = parts[0];</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>40</span><code>                    if (!opts.password) {</code></li>
<li class='green'><span class='hits'>40</span><code>                        opts.password = parts[1];</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>41</span><code>                opts.type = url.protocol.replace(":", "");</code></li>
<li class='green'><span class='hits'>41</span><code>                opts.host = url.hostname;</code></li>
<li class='green'><span class='hits'>41</span><code>                if (url.pathname) {</code></li>
<li class='green'><span class='hits'>41</span><code>                    var path = url.pathname;</code></li>
<li class='green'><span class='hits'>41</span><code>                    var pathParts = path.split("/").slice(1);</code></li>
<li class='green'><span class='hits'>41</span><code>                    if (pathParts.length &gt;= 1) {</code></li>
<li class='green'><span class='hits'>41</span><code>                        opts.database = pathParts[0];</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>41</span><code>                opts = merge(opts, url.query, {uri:connectionString});</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                opts = merge({}, connectionString, opts);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>41</span><code>            if (opts &amp;&amp; isHash(opts) &amp;&amp; (opts.adapter || opts.type)) {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>41</span><code>                var type = (opts.type = opts.adapter || opts.type);</code></li>
<li class='green'><span class='hits'>41</span><code>                var Adapter = ADAPTERS[type];</code></li>
<li class='green'><span class='hits'>41</span><code>                if (Adapter) {</code></li>
<li class='green'><span class='hits'>41</span><code>                    var adapter = new Adapter(opts);</code></li>
<li class='green'><span class='hits'>41</span><code>                    this.DATABASES.push(adapter);</code></li>
<li class='green'><span class='hits'>41</span><code>                    return adapter;</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw DatabaseError(type + " adapter was not found");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new DatabaseError("Options required when connecting.");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        setAdapterType:function (type) {</code></li>
<li class='green'><span class='hits'>5</span><code>            type = type.toLowerCase();</code></li>
<li class='green'><span class='hits'>5</span><code>            this.type = type;</code></li>
<li class='green'><span class='hits'>5</span><code>            ADAPTERS[type] = this;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        disconnect:function (cb) {</code></li>
<li class='green'><span class='hits'>41</span><code>            var dbs = this.DATABASES;</code></li>
<li class='green'><span class='hits'>41</span><code>            var ret = new PromiseList(dbs.map(function (d) {</code></li>
<li class='green'><span class='hits'>40</span><code>                return d.disconnect();</code></li>
<li class='green'><span class=''> </span><code>            }), true);</code></li>
<li class='green'><span class='hits'>41</span><code>            dbs.length = 0;</code></li>
<li class='green'><span class='hits'>41</span><code>            ret.classic(cb);</code></li>
<li class='green'><span class='hits'>41</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        ADAPTERS:ADAPTERS</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>DB.setAdapterType("default");</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="associations/_Association.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>associations/_Association.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>84.38</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>521</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>160</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>25</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="associations/_Association.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb-proxy"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    toArray = array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    Middleware = comb.plugins.Middleware,</code></li>
<li class='green'><span class=''> </span><code>    PatioError = require("../errors").PatioError;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var fetch = {</code></li>
<li class='green'><span class=''> </span><code>    LAZY:"lazy",</code></li>
<li class='green'><span class=''> </span><code>    EAGER:"eager"</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class</code></li>
<li class='green'><span class=''> </span><code> * Base class for all associations.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;b&gt;NOT to be instantiated directly&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code> * Its just documented for reference.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @constructs</code></li>
<li class='green'><span class=''> </span><code> * @param {Object} options</code></li>
<li class='green'><span class=''> </span><code> * @param {String} options.model a string to look up the model that we are associated with</code></li>
<li class='green'><span class=''> </span><code> * @param {Function} options.filter  a callback to find association if a filter is defined then</code></li>
<li class='green'><span class=''> </span><code> *                                    the association is read only</code></li>
<li class='green'><span class=''> </span><code> * @param {Object} options.key object with left key and right key</code></li>
<li class='green'><span class=''> </span><code> * @param {String|Object} options.orderBy&lt;String|Object&gt; - how to order our association @see Dataset.order</code></li>
<li class='green'><span class=''> </span><code> * @param {fetch.EAGER|fetch.LAZY} options.fetchType the fetch type of the model if fetch.Eager is supplied then</code></li>
<li class='green'><span class=''> </span><code> *                                    the associations are automatically filled, if fetch.Lazy is supplied</code></li>
<li class='green'><span class=''> </span><code> *                                    then a promise is returned and is called back with the loaded models</code></li>
<li class='green'><span class=''> </span><code> * @property {Model} model the model associatied with this association.</code></li>
<li class='green'><span class=''> </span><code> * @name Association</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.associations</code></li>
<li class='green'><span class=''> </span><code> * */</code></li>
<li class='green'><span class='hits'>1</span><code>define(Middleware, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.associations.Association.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        type:"",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Our associated model</code></li>
<li class='green'><span class=''> </span><code>        _model:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Fetch type</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fetchType:fetch.LAZY,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**how to order our association*/</code></li>
<li class='green'><span class=''> </span><code>        orderBy:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**Our filter method*/</code></li>
<li class='green'><span class=''> </span><code>        filter:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __hooks:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isOwner:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        createSetter:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isCascading:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        supportsStringKey:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        supportsHashKey:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        supportsCompositeKey:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        supportsLeftAndRightKey:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *Method to call to look up association,</code></li>
<li class='green'><span class=''> </span><code>         *called after the model has been filtered</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _fetchMethod:"all",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function (options, patio, filter) {</code></li>
<li class='green'><span class='hits'>55</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>55</span><code>            if (!options.model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new Error("Model is required for " + this.type + " association");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>55</span><code>            this._model = options.model;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.patio = patio;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.__opts = options;</code></li>
<li class='green'><span class='hits'>55</span><code>            !isUndefined(options.isCascading) &amp;&amp; (this.isCascading = options.isCascading);</code></li>
<li class='green'><span class='hits'>55</span><code>            this.filter = filter;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.readOnly = isBoolean(options.readOnly) ? options.readOnly : false;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.__hooks =</code></li>
<li class='green'><span class=''> </span><code>            {before:{add:null, remove:null, "set":null, load:null}, after:{add:null, remove:null, "set":null, load:null}};</code></li>
<li class='green'><span class='hits'>55</span><code>            var hooks = ["Add", "Remove", "Set", "Load"];</code></li>
<li class='green'><span class='hits'>55</span><code>            ["before", "after"].forEach(function (h) {</code></li>
<li class='green'><span class='hits'>110</span><code>                hooks.forEach(function (a) {</code></li>
<li class='green'><span class='hits'>440</span><code>                    var hookName = h + a, hook;</code></li>
<li class='green'><span class='hits'>440</span><code>                    if (isFunction((hook = options[hookName]))) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        this.__hooks[h][a.toLowerCase()] = hook;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>55</span><code>            this.fetchType = options.fetchType || fetch.LAZY;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _callHook:function (hook, action, args) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var func = this.__hooks[hook][action], ret;</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (isFunction(func)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = func.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _clearAssociations:function (model) {</code></li>
<li class='green'><span class='hits'>125</span><code>            if (!this.readOnly) {</code></li>
<li class='green'><span class='hits'>125</span><code>                delete model.__associations[this.name];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _forceReloadAssociations:function (model) {</code></li>
<li class='green'><span class='hits'>243</span><code>            if (!this.readOnly) {</code></li>
<li class='green'><span class='hits'>243</span><code>                delete model.__associations[this.name];</code></li>
<li class='green'><span class='hits'>243</span><code>                return model[this.name];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return {Boolean} true if the association is eager.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isEager:function () {</code></li>
<li class='green'><span class='hits'>2120</span><code>            return this.fetchType === fetch.EAGER;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _checkAssociationKey:function (parent) {</code></li>
<li class='green'><span class='hits'>787</span><code>            var q = {};</code></li>
<li class='green'><span class='hits'>787</span><code>            this._setAssociationKeys(parent, q);</code></li>
<li class='green'><span class='hits'>787</span><code>            return Object.keys(q).every(function (k) {</code></li>
<li class='green'><span class='hits'>787</span><code>                return q[k] !== null;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getAssociationKey:function () {</code></li>
<li class='green'><span class='hits'>5213</span><code>            var options = this.__opts, key, ret = [], lk, rk;</code></li>
<li class='green'><span class='hits'>5213</span><code>            if (!isUndefinedOrNull((key = options.key))) {</code></li>
<li class='green'><span class='hits'>730</span><code>                if (this.supportsStringKey &amp;&amp; isString(key)) {</code></li>
<li class='green'><span class=''> </span><code>                    //normalize the key first!</code></li>
<li class='green'><span class='hits'>364</span><code>                    ret = [</code></li>
<li class='green'><span class=''> </span><code>                        [this.isOwner ? this.defaultLeftKey : key],</code></li>
<li class='green'><span class=''> </span><code>                        [this.isOwner ? key : this.defaultRightKey]</code></li>
<li class='green'><span class=''> </span><code>                    ];</code></li>
<li class='green'><span class='hits'>366</span><code>                } else if (this.supportsHashKey &amp;&amp; isHash(key)) {</code></li>
<li class='green'><span class='hits'>366</span><code>                    var leftKey = Object.keys(key)[0];</code></li>
<li class='green'><span class='hits'>366</span><code>                    var rightKey = key[leftKey];</code></li>
<li class='green'><span class='hits'>366</span><code>                    ret = [</code></li>
<li class='green'><span class=''> </span><code>                        [leftKey],</code></li>
<li class='green'><span class=''> </span><code>                        [rightKey]</code></li>
<li class='green'><span class=''> </span><code>                    ];</code></li>
<li class='red'><span class='nohits'>0</span><code>                } else if (this.supportsCompositeKey &amp;&amp; isArray(key)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret = [</code></li>
<li class='green'><span class=''> </span><code>                        [key],</code></li>
<li class='green'><span class=''> </span><code>                        null</code></li>
<li class='green'><span class=''> </span><code>                    ];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>4483</span><code>            } else if (this.supportsLeftAndRightKey &amp;&amp; (!isUndefinedOrNull((lk = options.leftKey)) &amp;&amp; !isUndefinedOrNull((rk = options.rightKey)))) {</code></li>
<li class='green'><span class='hits'>140</span><code>                ret = [</code></li>
<li class='green'><span class=''> </span><code>                    toArray(lk), toArray(rk)</code></li>
<li class='green'><span class=''> </span><code>                ];</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class=''> </span><code>                //todo handle composite primary keys</code></li>
<li class='green'><span class='hits'>4343</span><code>                ret = [</code></li>
<li class='green'><span class=''> </span><code>                    [this.defaultLeftKey],</code></li>
<li class='green'><span class=''> </span><code>                    [this.defaultRightKey]</code></li>
<li class='green'><span class=''> </span><code>                ];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>5213</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setAssociationKeys:function (parent, model, val) {</code></li>
<li class='green'><span class='hits'>1577</span><code>            var keys = this._getAssociationKey(parent), leftKey = keys[0], rightKey = keys[1], i = leftKey.length - 1;</code></li>
<li class='green'><span class='hits'>1577</span><code>            if (leftKey &amp;&amp; rightKey) {</code></li>
<li class='green'><span class='hits'>1577</span><code>                for (; i &gt;= 0; i--) {</code></li>
<li class='green'><span class='hits'>1577</span><code>                    model[rightKey[i]] = !isUndefined(val) ? val : parent[leftKey[i]];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                for (; i &gt;= 0; i--) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var k = leftKey[i];</code></li>
<li class='red'><span class='nohits'>0</span><code>                    model[k] = !isUndefined(val) ? val : parent[k];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setDatasetOptions:function (ds) {</code></li>
<li class='green'><span class='hits'>976</span><code>            var options = this.__opts || {};</code></li>
<li class='green'><span class='hits'>976</span><code>            var order, limit, distinct, select, query;</code></li>
<li class='green'><span class=''> </span><code>            //allow for multi key ordering</code></li>
<li class='green'><span class='hits'>976</span><code>            if (!isUndefined((select = this.select))) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.select.apply(ds, toArray(select));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>976</span><code>            if (!isUndefined((query = options.query)) || !isUndefined((query = options.conditions))) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.filter(query);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>976</span><code>            if (isFunction(this.filter)) {</code></li>
<li class='green'><span class='hits'>334</span><code>                var ret = this.filter.apply(this, [ds]);</code></li>
<li class='green'><span class='hits'>334</span><code>                if (isInstanceOf(ret, ds._static)) {</code></li>
<li class='green'><span class='hits'>334</span><code>                    ds = ret;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>976</span><code>            if (!isUndefined((distinct = options.distinct))) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.limit.apply(ds, toArray(distinct));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>976</span><code>            if (!isUndefined((order = options.orderBy)) || !isUndefined((order = options.order))) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.order.apply(ds, toArray(order));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>976</span><code>            if (!isUndefined((limit = options.limit))) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.limit.apply(ds, toArray(limit));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>976</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Filters our associated dataset to load our association.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *@return {Dataset} the dataset with all filters applied.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _filter:function (parent) {</code></li>
<li class='green'><span class='hits'>650</span><code>            var options = this.__opts || {};</code></li>
<li class='green'><span class='hits'>650</span><code>            var ds;</code></li>
<li class='green'><span class='hits'>650</span><code>            if (!isUndefined((ds = options.dataset)) &amp;&amp; isFunction(ds)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.apply(parent, [parent]);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>650</span><code>            if (!ds) {</code></li>
<li class='green'><span class='hits'>650</span><code>                var q = {};</code></li>
<li class='green'><span class='hits'>650</span><code>                this._setAssociationKeys(parent, q);</code></li>
<li class='green'><span class='hits'>650</span><code>                ds = this.model.dataset.naked().filter(q);</code></li>
<li class='green'><span class='hits'>650</span><code>                var recip = this.model._findAssociation(this);</code></li>
<li class='green'><span class='hits'>650</span><code>                recip &amp;&amp; (recip = recip[1]);</code></li>
<li class='green'><span class='hits'>650</span><code>                ds.rowCb = hitch(this, function (item) {</code></li>
<li class='green'><span class='hits'>495</span><code>                    var ret = new Promise();</code></li>
<li class='green'><span class='hits'>495</span><code>                    var model = this._toModel(item, true);</code></li>
<li class='green'><span class='hits'>495</span><code>                    recip &amp;&amp; recip.__setValue(model, parent);</code></li>
<li class='green'><span class=''> </span><code>                    //call hook to finish other model associations</code></li>
<li class='green'><span class='hits'>495</span><code>                    return model._hook("post", "load").chain(model);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (!ds.rowCb &amp;&amp; this.model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds.rowCb = hitch(this, function (item) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var model = this._toModel(item, true);</code></li>
<li class='green'><span class=''> </span><code>                    //call hook to finish other model associations</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return model._hook("post", "load").chain(model);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>650</span><code>            return this._setDatasetOptions(ds);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __setValue:function (parent, model) {</code></li>
<li class='green'><span class='hits'>2067</span><code>            parent.__associations[this.name] = this._fetchMethod</code></li>
<li class='green'><span class=''> </span><code>                === "all" ? !isArray(model) ? [model] : model : isArray(model) ? model[0] : model;</code></li>
<li class='green'><span class='hits'>2067</span><code>            return parent.__associations[this.name];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        fetch:function (parent) {</code></li>
<li class='green'><span class='hits'>787</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>787</span><code>            if (this._checkAssociationKey(parent)) {</code></li>
<li class='green'><span class='hits'>735</span><code>                return this._filter(parent)[this._fetchMethod]().chain(function (result) {</code></li>
<li class='green'><span class='hits'>735</span><code>                    this.__setValue(parent, result);</code></li>
<li class='green'><span class='hits'>735</span><code>                    parent = null;</code></li>
<li class='green'><span class='hits'>735</span><code>                    return result;</code></li>
<li class='green'><span class=''> </span><code>                }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>52</span><code>                this.__setValue(parent, null);</code></li>
<li class='green'><span class='hits'>52</span><code>                ret.callback(null);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>52</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called before a model is removed.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being acted up.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _preRemove:function (next, model) {</code></li>
<li class='green'><span class='hits'>223</span><code>            if (this.isOwner &amp;&amp; !this.isCascading) {</code></li>
<li class='green'><span class='hits'>46</span><code>                var q = {};</code></li>
<li class='green'><span class='hits'>46</span><code>                this._setAssociationKeys(model, q, null);</code></li>
<li class='green'><span class='hits'>46</span><code>                model[this.associatedDatasetName].update(q).classic(next);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>177</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called aft era model is removed.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _postRemove:function (next, model) {</code></li>
<li class='green'><span class='hits'>514</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called before a model is saved.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _preSave:function (next, model) {</code></li>
<li class='green'><span class='hits'>324</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called after a model is saved.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _postSave:function (next, model) {</code></li>
<li class='green'><span class='hits'>198</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called before a model is updated.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _preUpdate:function (next, model) {</code></li>
<li class='green'><span class='hits'>2</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called before a model is updated.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _postUpdate:function (next, model) {</code></li>
<li class='green'><span class='hits'>129</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called before a model is loaded.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _preLoad:function (next, model) {</code></li>
<li class='green'><span class='hits'>1576</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Middleware called after a model is loaded.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; This is called in the scope of the model&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} next function to pass control up the middleware stack.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _postLoad:function (next, model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Alias used to explicitly set an association on a model.</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} val the value to set the association to</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _setter:function (val, model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            model.__associations[this.name] = val;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        associationLoaded:function (model) {</code></li>
<li class='green'><span class='hits'>2715</span><code>            return model.__associations.hasOwnProperty(this.name);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getAssociation:function (model) {</code></li>
<li class='green'><span class='hits'>887</span><code>            return model.__associations[this.name];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Alias used to explicitly get an association on a model.</code></li>
<li class='green'><span class=''> </span><code>         * @param {_Association} self reference to the Association that is being called.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _getter:function (model) {</code></li>
<li class='green'><span class=''> </span><code>            //if we have them return them;</code></li>
<li class='green'><span class='hits'>612</span><code>            if (this.associationLoaded(model)) {</code></li>
<li class='green'><span class='hits'>220</span><code>                var assoc = this.getAssociation(model);</code></li>
<li class='green'><span class='hits'>220</span><code>                return this.isEager() ? assoc : when(assoc)</code></li>
<li class='green'><span class='hits'>392</span><code>            } else if (model.isNew) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>392</span><code>                return this.fetch(model);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _toModel:function (val, fromDb) {</code></li>
<li class='green'><span class='hits'>1418</span><code>            var Model = this.model;</code></li>
<li class='green'><span class='hits'>1418</span><code>            if (!isUndefinedOrNull(Model)) {</code></li>
<li class='green'><span class='hits'>1418</span><code>                if (!isInstanceOf(val, Model)) {</code></li>
<li class='green'><span class='hits'>1173</span><code>                    val = new this.model(val, fromDb);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new PatioError("Invalid model " + this.name);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1418</span><code>            return val;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Method to inject functionality into a model. This method alters the model</code></li>
<li class='green'><span class=''> </span><code>         * to prepare it for associations, and initializes all required middleware calls</code></li>
<li class='green'><span class=''> </span><code>         * to fulfill requirements needed to loaded the associations.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Model} parent the model that is having an associtaion set on it.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} name the name of the association.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        inject:function (parent, name) {</code></li>
<li class='green'><span class='hits'>55</span><code>            this.name = name;</code></li>
<li class='green'><span class='hits'>55</span><code>            var self = this;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.parent = parent;</code></li>
<li class='green'><span class='hits'>55</span><code>            var parentProto = parent.prototype;</code></li>
<li class='green'><span class='hits'>55</span><code>            parentProto.__defineGetter__(name, function () {</code></li>
<li class='green'><span class='hits'>612</span><code>                return  self._getter(this);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>55</span><code>            parentProto.__defineGetter__(this.associatedDatasetName, function () {</code></li>
<li class='green'><span class='hits'>146</span><code>                return  self._filter(this);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>55</span><code>            if (!this.readOnly &amp;&amp; this.createSetter) {</code></li>
<li class='green'><span class=''> </span><code>                //define a setter because we arent read only</code></li>
<li class='green'><span class='hits'>55</span><code>                parentProto.__defineSetter__(name, function (vals) {</code></li>
<li class='green'><span class='hits'>139</span><code>                    self._setter(vals, this);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //set up all callbacks</code></li>
<li class='green'><span class='hits'>55</span><code>            ["pre", "post"].forEach(function (op) {</code></li>
<li class='green'><span class='hits'>110</span><code>                ["save", "update", "remove", "load"].forEach(function (type) {</code></li>
<li class='green'><span class='hits'>440</span><code>                    parent[op](type, function (next) {</code></li>
<li class='green'><span class='hits'>5614</span><code>                        return self["_" + op + type.charAt(0).toUpperCase() + type.slice(1)](next, this);</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            select:function () {</code></li>
<li class='green'><span class='hits'>650</span><code>                return this.__opts.select;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            defaultLeftKey:function () {</code></li>
<li class='green'><span class='hits'>2843</span><code>                var ret = "";</code></li>
<li class='green'><span class='hits'>2843</span><code>                if (this.isOwner) {</code></li>
<li class='green'><span class='hits'>2097</span><code>                    ret = this.__opts.primaryKey || this.parent.primaryKey[0]</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>746</span><code>                    ret = this.model.tableName + "Id";</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>2843</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            defaultRightKey:function () {</code></li>
<li class='green'><span class='hits'>2727</span><code>                return this.associatedModelKey;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Returns our model</code></li>
<li class='green'><span class=''> </span><code>            model:function () {</code></li>
<li class='green'><span class='hits'>2912</span><code>                return this.__model__ || (this.__model__ = this.patio.getModel(this._model, this.parent.db));</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            associatedModelKey:function () {</code></li>
<li class='green'><span class='hits'>2727</span><code>                var ret = "";</code></li>
<li class='green'><span class='hits'>2727</span><code>                if (this.isOwner) {</code></li>
<li class='green'><span class='hits'>1857</span><code>                    ret = this.__opts.primaryKey || this.parent.tableName + "Id";</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>870</span><code>                    ret = this.model.primaryKey[0];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>2727</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            associatedDatasetName:function () {</code></li>
<li class='green'><span class='hits'>201</span><code>                return this.name + "Dataset";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            removeAssociationFlagName:function () {</code></li>
<li class='green'><span class='hits'>27</span><code>                return "__remove" + this.name + "association";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.associations.Association*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        fetch:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            LAZY:"lazy",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            EAGER:"eager"</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="associations/manyToMany.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>associations/manyToMany.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>85.71</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>304</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>133</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>19</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="associations/manyToMany.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb-proxy"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    zip = array.zip,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    hitchIgnore = comb.hitchIgnore,</code></li>
<li class='green'><span class=''> </span><code>    OneToMany = require("./oneToMany"),</code></li>
<li class='green'><span class=''> </span><code>    pluralize = comb.pluralize,</code></li>
<li class='green'><span class=''> </span><code>    AssociationError = require("../errors").AssociationError;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var LOGGER = comb.logger("comb.associations.ManyToMany");</code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Class to define a manyToMany association.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;b&gt;NOT to be instantiated directly&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code> * Its just documented for reference.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name ManyToMany</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.associations.OneToMany</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.associations</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @param {String} options.joinTable the joinTable of the association.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @property {String} joinTable the join table used in the relation.</code></li>
<li class='green'><span class=''> </span><code> * */</code></li>
<li class='green'><span class='hits'>1</span><code>module.exports = define(OneToMany, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.associations.ManyToMany.prototype*/</code></li>
<li class='green'><span class=''> </span><code>        type:"manyToMany",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _fetchMethod:"all",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        supportsStringKey:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        supportsCompositeKey:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _filter:function (parent) {</code></li>
<li class='green'><span class='hits'>326</span><code>            var keys = this._getAssociationKey(parent);</code></li>
<li class='green'><span class='hits'>326</span><code>            var options = this.__opts || {};</code></li>
<li class='green'><span class='hits'>326</span><code>            var ds;</code></li>
<li class='green'><span class='hits'>326</span><code>            if (!isUndefined((ds = options.dataset)) &amp;&amp; isFunction(ds)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds = ds.apply(parent, [parent]);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>326</span><code>            if (!ds) {</code></li>
<li class='green'><span class='hits'>326</span><code>                ds = this.model.dataset.naked().innerJoin(this.joinTableName, zip(keys[1], this.modelPrimaryKey.map(function (k) {</code></li>
<li class='green'><span class='hits'>326</span><code>                    return sql.stringToIdentifier(k);</code></li>
<li class='green'><span class=''> </span><code>                })).concat(zip(keys[0], this.parentPrimaryKey.map(function (k) {</code></li>
<li class='green'><span class='hits'>326</span><code>                    return parent[k];</code></li>
<li class='green'><span class=''> </span><code>                }))));</code></li>
<li class='green'><span class='hits'>326</span><code>                var recip = this.model._findAssociation(this);</code></li>
<li class='green'><span class='hits'>326</span><code>                if (recip) {</code></li>
<li class='green'><span class='hits'>326</span><code>                    recip = recip[1];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>326</span><code>                ds.rowCb = hitch(this, function (item) {</code></li>
<li class='green'><span class='hits'>340</span><code>                    var model = this._toModel(item, true);</code></li>
<li class='green'><span class='hits'>340</span><code>                    if (recip) {</code></li>
<li class='green'><span class='hits'>340</span><code>                        recip.__setValue(model, parent);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                    //call hook to finish other model associations</code></li>
<li class='green'><span class='hits'>340</span><code>                    return model._hook("post", "load").chain(model);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (!ds.rowCb &amp;&amp; this.model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ds.rowCb = hitch(this, function (item) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var model = this._toModel(item, true);</code></li>
<li class='green'><span class=''> </span><code>                    //call hook to finish other model associations</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return model._hook("post", "load").chain(model);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>326</span><code>            return this._setDatasetOptions(ds);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setAssociationKeys:function (parent, model, val) {</code></li>
<li class='green'><span class='hits'>534</span><code>            var keys = this._getAssociationKey(parent),</code></li>
<li class='green'><span class=''> </span><code>                leftKey = keys[0],</code></li>
<li class='green'><span class=''> </span><code>                parentPk = this.parentPrimaryKey;</code></li>
<li class='green'><span class='hits'>534</span><code>            if (!(leftKey &amp;&amp; leftKey.length === parentPk.length)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new AssociationError("Invalid leftKey for " + this.name + " : " + leftKey);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>534</span><code>            for (var i = 0; i &lt; leftKey.length; i++) {</code></li>
<li class='green'><span class='hits'>534</span><code>                model[leftKey[i]] = !isUndefined(val) ? val : parent[parentPk[i]];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __createJoinTableInsertRemoveQuery:function (model, item) {</code></li>
<li class='green'><span class='hits'>176</span><code>            var q = {};</code></li>
<li class='green'><span class='hits'>176</span><code>            var keys = this._getAssociationKey(model),</code></li>
<li class='green'><span class=''> </span><code>                leftKey = keys[0],</code></li>
<li class='green'><span class=''> </span><code>                rightKey = keys[1],</code></li>
<li class='green'><span class=''> </span><code>                parentPk = this.parentPrimaryKey,</code></li>
<li class='green'><span class=''> </span><code>                modelPk = this.modelPrimaryKey;</code></li>
<li class='green'><span class='hits'>176</span><code>            if (!(leftKey &amp;&amp; leftKey.length === parentPk.length)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new AssociationError("Invalid leftKey for " + this.name + " : " + leftKey);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>176</span><code>            if (!(rightKey &amp;&amp; rightKey.length === modelPk.length)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new AssociationError("Invalid rightKey for " + this.name + " : " + rightKey);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>176</span><code>            for (var i = 0; i &lt; leftKey.length; i++) {</code></li>
<li class='green'><span class='hits'>176</span><code>                q[leftKey[i]] = model[parentPk[i]];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>176</span><code>            for (i = 0; i &lt; rightKey.length; i++) {</code></li>
<li class='green'><span class='hits'>176</span><code>                q[rightKey[i]] = item[modelPk[i]];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>176</span><code>            return q;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _preRemove:function (next, model) {</code></li>
<li class='green'><span class='hits'>202</span><code>            if (this.isOwner &amp;&amp; !this.isCascading) {</code></li>
<li class='green'><span class='hits'>202</span><code>                var q = {};</code></li>
<li class='green'><span class='hits'>202</span><code>                this._setAssociationKeys(model, q);</code></li>
<li class='green'><span class='hits'>202</span><code>                this.joinTable.where(q).remove().classic(next);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        addAssociation:function (item, model, reload) {</code></li>
<li class='green'><span class='hits'>260</span><code>            reload = isBoolean(reload) ? reload : false;</code></li>
<li class='green'><span class='hits'>260</span><code>            var ret = new Promise().callback(model);</code></li>
<li class='green'><span class='hits'>260</span><code>            if (!isUndefinedOrNull(item)) {</code></li>
<li class='green'><span class='hits'>260</span><code>                if (!model.isNew) {</code></li>
<li class='green'><span class='hits'>148</span><code>                    item = this._toModel(item);</code></li>
<li class='green'><span class='hits'>148</span><code>                    var loaded = this.associationLoaded(model);</code></li>
<li class='green'><span class='hits'>148</span><code>                    var recip = this.model._findAssociation(this), save = item.isNew;</code></li>
<li class='green'><span class='hits'>148</span><code>                    ret = model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>148</span><code>                        var joinTable = this.joinTable, ret = new Promise();</code></li>
<li class='green'><span class='hits'>148</span><code>                        return serial([</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>148</span><code>                                return save ? item.save() : null;</code></li>
<li class='green'><span class=''> </span><code>                            },</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>148</span><code>                                return joinTable.insert(this.__createJoinTableInsertRemoveQuery(model, item));</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this),</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>148</span><code>                                if (recip) {</code></li>
<li class='green'><span class='hits'>148</span><code>                                    recip[1].__setValue(item, [model]);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            },</code></li>
<li class='green'><span class=''> </span><code>                            function () {</code></li>
<li class='green'><span class='hits'>148</span><code>                                if (loaded &amp;&amp; reload) {</code></li>
<li class='green'><span class='hits'>3</span><code>                                    return this.parent._reloadAssociationsForType(this.type, this.model, model);</code></li>
<li class='green'><span class=''> </span><code>                                } else {</code></li>
<li class='green'><span class='hits'>145</span><code>                                    return model;</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this)</code></li>
<li class='green'><span class=''> </span><code>                        ]).chain(model);</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>112</span><code>                    item = this._toModel(item);</code></li>
<li class='green'><span class='hits'>112</span><code>                    var items = this.getAssociation(model);</code></li>
<li class='green'><span class='hits'>112</span><code>                    if (isUndefinedOrNull(items)) {</code></li>
<li class='green'><span class='hits'>39</span><code>                        this.__setValue(model, [item]);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>73</span><code>                        items.push(item);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>260</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        removeItem:function (item, model, remove, reload) {</code></li>
<li class='green'><span class='hits'>56</span><code>            reload = isBoolean(reload) ? reload : false;</code></li>
<li class='green'><span class='hits'>56</span><code>            remove = isBoolean(remove) ? remove : false;</code></li>
<li class='green'><span class='hits'>56</span><code>            if (!isUndefinedOrNull(item)) {</code></li>
<li class='green'><span class='hits'>56</span><code>                if (!model.isNew) {</code></li>
<li class='green'><span class='hits'>56</span><code>                    if (isInstanceOf(item, this.model) &amp;&amp; !item.isNew) {</code></li>
<li class='green'><span class='hits'>56</span><code>                        var loaded = this.associationLoaded(model);</code></li>
<li class='green'><span class='hits'>56</span><code>                        remove = remove &amp;&amp; !item.isNew;</code></li>
<li class='green'><span class='hits'>56</span><code>                        return model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>56</span><code>                            return remove ? item.remove() : this.joinTable.where(this.__createJoinTableInsertRemoveQuery(model, item)).remove();</code></li>
<li class='green'><span class=''> </span><code>                        })).chain(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>56</span><code>                            if (loaded &amp;&amp; reload) {</code></li>
<li class='green'><span class='hits'>18</span><code>                                return this.parent._reloadAssociationsForType(this.type, this.model, model);</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        })).chain(model);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    item = this._toModel(item);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var items = this.getAssociation(model), index;</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (!isUndefinedOrNull(items) &amp;&amp; (index = items.indexOf(item)) !== -1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        items.splice(index, 1);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return when(model);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        removeAllItems:function (model, remove) {</code></li>
<li class='green'><span class='hits'>4</span><code>            remove = isBoolean(remove) ? remove : false;</code></li>
<li class='green'><span class='hits'>4</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>4</span><code>            if (!model.isNew) {</code></li>
<li class='green'><span class='hits'>4</span><code>                var q = {}, removeQ = {};</code></li>
<li class='green'><span class='hits'>4</span><code>                this._setAssociationKeys(model, q);</code></li>
<li class='green'><span class='hits'>4</span><code>                this._setAssociationKeys(model, removeQ, null);</code></li>
<li class='green'><span class='hits'>4</span><code>                var loaded = this.associationLoaded(model);</code></li>
<li class='green'><span class='hits'>4</span><code>                return model._checkTransaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                    var ds = this.model.dataset, ret = new Promise();</code></li>
<li class='green'><span class='hits'>4</span><code>                    when(remove ? this._filter(model).forEach(function (m) {</code></li>
<li class='green'><span class='hits'>6</span><code>                        return m.remove();</code></li>
<li class='green'><span class=''> </span><code>                    }) : this.joinTable.filter(q).update(removeQ)).then(function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                        if (loaded) {</code></li>
<li class='green'><span class='hits'>2</span><code>                            this.parent._reloadAssociationsForType(this.type, this.model, model)</code></li>
<li class='green'><span class=''> </span><code>                                .then(hitchIgnore(ret, "callback", model), ret);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                            ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this), ret);</code></li>
<li class='green'><span class='hits'>4</span><code>                    return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class=''> </span><code>                //todo we may want to check if any of the items were previously saved items;</code></li>
<li class='red'><span class='nohits'>0</span><code>                this._clearAssociations(model);</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.callback(model);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            select:function () {</code></li>
<li class='green'><span class='hits'>326</span><code>                return this.__select;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            defaultLeftKey:function () {</code></li>
<li class='green'><span class='hits'>1740</span><code>                return this.__opts.leftKey || this.parent.tableName + "Id";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            defaultRightKey:function () {</code></li>
<li class='green'><span class='hits'>1740</span><code>                return this.__opts.rightKey || this.model.tableName + "Id";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            parentPrimaryKey:function () {</code></li>
<li class='green'><span class='hits'>1036</span><code>                return this.__opts.leftPrimaryKey || this.parent.primaryKey;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            modelPrimaryKey:function () {</code></li>
<li class='green'><span class='hits'>502</span><code>                return this.__opts.rightPrimaryKey || this.model.primaryKey;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            joinTableName:function () {</code></li>
<li class='green'><span class='hits'>344</span><code>                if (!this._joinTable) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    var options = this.__opts;</code></li>
<li class='green'><span class='hits'>18</span><code>                    var joinTable = options.joinTable;</code></li>
<li class='green'><span class='hits'>18</span><code>                    if (isUndefined(joinTable)) {</code></li>
<li class='green'><span class='hits'>18</span><code>                        var defaultJoinTable = this.defaultJoinTable;</code></li>
<li class='green'><span class='hits'>18</span><code>                        if (isUndefined(defaultJoinTable)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            throw new Error("Unable to determine jointable for " + this.name);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>18</span><code>                            this._joinTable = defaultJoinTable;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        this._joinTable = joinTable;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>344</span><code>                return this._joinTable;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //returns our join table model</code></li>
<li class='green'><span class=''> </span><code>            joinTable:function () {</code></li>
<li class='green'><span class='hits'>380</span><code>                if (!this.__joinTableDataset) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    var ds = this.__joinTableDataset = this.model.dataset.db.from(this.joinTableName), model = this.model, options = this.__opts;</code></li>
<li class='green'><span class='hits'>18</span><code>                    var identifierInputMethod = isUndefined(options.identifierInputMethod) ? model.identifierInputMethod : options.identifierInputMethod,</code></li>
<li class='green'><span class=''> </span><code>                        identifierOutputMethod = isUndefined(options.identifierOutputMethod) ? model.identifierOutputMethod : options.identifierOutputMethod;</code></li>
<li class='green'><span class='hits'>18</span><code>                    if (identifierInputMethod) {</code></li>
<li class='green'><span class='hits'>14</span><code>                        ds.identifierInputMethod = identifierInputMethod;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>18</span><code>                    if (identifierOutputMethod) {</code></li>
<li class='green'><span class='hits'>14</span><code>                        ds.identifierOutputMethod = identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>380</span><code>                return this.__joinTableDataset;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            defaultJoinTable:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>                var ret;</code></li>
<li class='green'><span class='hits'>18</span><code>                var recip = this.model._findAssociation(this);</code></li>
<li class='green'><span class='hits'>18</span><code>                if (recip &amp;&amp; recip.length) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    var names = [pluralize(this._model), pluralize(recip[1]._model)].sort();</code></li>
<li class='green'><span class='hits'>18</span><code>                    names[1] = names[1].charAt(0).toUpperCase() + names[1].substr(1);</code></li>
<li class='green'><span class='hits'>18</span><code>                    ret = names.join("");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>18</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="dataset/index.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>dataset/index.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>86.11</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>457</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>72</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>10</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="dataset/index.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    logging = comb.logging,</code></li>
<li class='green'><span class=''> </span><code>    Logger = logging.Logger,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("../errors"),</code></li>
<li class='green'><span class=''> </span><code>    QueryError = errors.QueryError,</code></li>
<li class='green'><span class=''> </span><code>    DatasetError = errors.DatasetError,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    graph = require("./graph"),</code></li>
<li class='green'><span class=''> </span><code>    actions = require("./actions"),</code></li>
<li class='green'><span class=''> </span><code>    features = require("./features"),</code></li>
<li class='green'><span class=''> </span><code>    query = require("./query"),</code></li>
<li class='green'><span class=''> </span><code>    sql = require("./sql"),</code></li>
<li class='green'><span class=''> </span><code>    SQL = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    AliasedExpression = SQL.AliasedExpression,</code></li>
<li class='green'><span class=''> </span><code>    Identifier = SQL.Identifier,</code></li>
<li class='green'><span class=''> </span><code>    QualifiedIdentifier = SQL.QualifiedIdentifier;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var LOGGER = comb.logger("patio.Dataset");</code></li>
<li class='green'><span class='hits'>1</span><code>define([actions, graph, features, query, sql], {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Class that is used for querying/retirving datasets from a database.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt; Dynamically genertated methods include</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;Join methods from {@link patio.Dataset.CONDITIONED_JOIN_TYPES} and</code></li>
<li class='green'><span class=''> </span><code>         *         {@link  patio.Dataset.UNCONDITIONED_JOIN_TYPES}, these methods handle the type call</code></li>
<li class='green'><span class=''> </span><code>         *         to {@link patio.Dataset#joinTable}, so to invoke include all arguments that</code></li>
<li class='green'><span class=''> </span><code>         *         {@link patio.Dataset#joinTable} requires except the type parameter. The default list includes.</code></li>
<li class='green'><span class=''> </span><code>         *         &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;Conditioned join types that accept conditions.</code></li>
<li class='green'><span class=''> </span><code>         *                  &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;inner - INNER JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;fullOuter - FULL OUTER&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;rightOuter - RIGHT OUTER JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;leftOuter - LEFT OUTER JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;full - FULL JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;right - RIGHT JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;left - LEFT JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                  &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;Unconditioned join types that do not accept join conditions</code></li>
<li class='green'><span class=''> </span><code>         *                  &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;natural - NATURAL JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;naturalLeft - NATURAL LEFT JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;naturalRight - NATURAL RIGHT JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;naturalFull - NATURA FULLL JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                      &lt;li&gt;cross - CROSS JOIN&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *                  &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *         &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;h4&gt;Features:&lt;/h4&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *           Features that a particular {@link patio.Dataset} supports are shown in the example below.</code></li>
<li class='green'><span class=''> </span><code>         *           If you wish to implement an adapter please override these values depending on the database that</code></li>
<li class='green'><span class=''> </span><code>         *           you are developing the adapter for.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          var ds = DB.from("test");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //The default values returned</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether this dataset quotes identifiers.</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether this dataset quotes identifiers.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.quoteIdentifiers //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether this dataset will provide accurate number of rows matched for</code></li>
<li class='green'><span class=''> </span><code>         *          //delete and update statements.  Accurate in this case is the number of</code></li>
<li class='green'><span class=''> </span><code>         *          //rows matched by the dataset's filter.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.providesAccurateRowsMatched; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Times Whether the dataset requires SQL standard datetimes (false by default,</code></li>
<li class='green'><span class=''> </span><code>         *          // as most allow strings with ISO 8601 format).</code></li>
<li class='green'><span class=''> </span><code>         *          ds.requiresSqlStandardDate; //=&gt;false</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports common table expressions (the WITH clause).</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsCte; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports the DISTINCT ON clause, false by default.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsDistinctOn; //=&gt;false</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports the INTERSECT and EXCEPT compound operations, true by default.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsIntersectExcept; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports the INTERSECT ALL and EXCEPT ALL compound operations, true by default</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsIntersectExceptAll; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports the IS TRUE syntax.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsIsTrue; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports the JOIN table USING (column1, ...) syntax.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsJoinUsing; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether modifying joined datasets is supported.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsModifyingJoin; //=&gt;false</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the IN/NOT IN operators support multiple columns when an</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsMultipleColumnIn; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports timezones in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsTimestampTimezone; //=&gt;false</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports fractional seconds in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsTimestampUsecs; //=&gt;true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *          //Whether the dataset supports window functions.</code></li>
<li class='green'><span class=''> </span><code>         *          ds.supportsWindowFunctions; //=&gt;false</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;h4&gt;Actions&lt;/h4&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *         Each dataset does not actually send any query to the database until an action method has</code></li>
<li class='green'><span class=''> </span><code>         *         been called upon it(with the exception of {@link patio.Dataset#graph} because columns</code></li>
<li class='green'><span class=''> </span><code>         *         from the other table might need retrived in order to set up the graph). Each action</code></li>
<li class='green'><span class=''> </span><code>         *         returns a &lt;i&gt;comb.Promise&lt;/i&gt; that will be resolved with the result or errback, it is important</code></li>
<li class='green'><span class=''> </span><code>         *         that you account for errors otherwise it can be difficult to track down issues.</code></li>
<li class='green'><span class=''> </span><code>         *         The list of action methods is:</code></li>
<li class='green'><span class=''> </span><code>         *         &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#all}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#one}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#avg}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#count}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#columns}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#remove}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#forEach}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#empty}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#first}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#get}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#import}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#insert}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#save}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#insertMultiple}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#saveMultiple}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#interval}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#last}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#map}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#max}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#min}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#multiInsert}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#range}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#selectHash}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#selectMap}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#selectOrderMap}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#set}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#singleRecord}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#singleValue}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#sum}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#toCsv}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#toHash}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#truncate}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *             &lt;li&gt;{@link patio.Dataset#update}&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *         &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Database} db the database this dataset should use when querying for data.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} opts options to set on this dataset instance</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {Function} rowCb callback to be invoked for each row returned from the database.</code></li>
<li class='green'><span class=''> </span><code>         *                      the return value will be used as the result of query. The rowCb can also return a promise,</code></li>
<li class='green'><span class=''> </span><code>         *                      The resolved value of the promise will be used as result.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} identifierInputMethod this is the method that will be called on each identifier returned from the database.</code></li>
<li class='green'><span class=''> </span><code>         *                                          This value will be defaulted to whatever the identifierInputMethod</code></li>
<li class='green'><span class=''> </span><code>         *                                          is on the database used in initialization.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} identifierOutputMethod this is the method that will be called on each identifier sent to the database.</code></li>
<li class='green'><span class=''> </span><code>         *                                          This value will be defaulted to whatever the identifierOutputMethod</code></li>
<li class='green'><span class=''> </span><code>         *                                          is on the database used in initialization.</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} firstSourceAlias The first source (primary table) for this dataset. If the table is aliased, returns the aliased name.</code></li>
<li class='green'><span class=''> </span><code>         *                                     throws a {patio.DatasetError} tf the dataset doesn't have a table.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("table").firstSourceAlias;</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; "table"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("table___t").firstSourceAlias;</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; "t"</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} firstSourceTable  The first source (primary table) for this dataset.  If the dataset doesn't</code></li>
<li class='green'><span class=''> </span><code>         *                                      have a table, raises a {@link patio.erros.DatasetError}.</code></li>
<li class='green'><span class=''> </span><code>         *&lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").firstSourceTable;</code></li>
<li class='green'><span class=''> </span><code>         *         //=&gt; "table"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table___t").firstSourceTable;</code></li>
<li class='green'><span class=''> </span><code>         *         //=&gt; "t"</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @property {Boolean} isSimpleSelectAll Returns true if this dataset is a simple SELECT * FROM {table}, otherwise false.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     DB.from("items").isSimpleSelectAll; //=&gt; true</code></li>
<li class='green'><span class=''> </span><code>         *     DB.from("items").filter({a : 1}).isSimpleSelectAll; //=&gt; false</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [quoteIdentifiers=true]  Whether this dataset quotes identifiers.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [providesAccurateRowsMatched=true] Whether this dataset will provide accurate number of rows matched for</code></li>
<li class='green'><span class=''> </span><code>         *   delete and update statements.  Accurate in this case is the number of</code></li>
<li class='green'><span class=''> </span><code>         *   rows matched by the dataset's filter.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [requiresSqlStandardDate=false] Whether the dataset requires SQL standard datetimes (false by default,</code></li>
<li class='green'><span class=''> </span><code>         *                                                     as most allow strings with ISO 8601 format).</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsCte=true] Whether the dataset supports common table expressions (the WITH clause).</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsDistinctOn=false] Whether the dataset supports the DISTINCT ON clause, false by default.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsIntersectExcept=true] Whether the dataset supports the INTERSECT and EXCEPT compound operations, true by default.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsIntersectExceptAll=true] Whether the dataset supports the INTERSECT ALL and EXCEPT ALL compound operations, true by default.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsIsTrue=true] Whether the dataset supports the IS TRUE syntax.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsJoinUsing=true] Whether the dataset supports the JOIN table USING (column1, ...) syntax.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsModifyingJoin=false] Whether modifying joined datasets is supported.</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsMultipleColumnIn=true] Whether the IN/NOT IN operators support multiple columns when an</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsTimestampTimezone=false] Whether the dataset supports timezones in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsTimestampUsecs=true] Whether the dataset supports fractional seconds in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>         * @property {boolean} [supportsWindowFunctions=false] Whether the dataset supports window functions.</code></li>
<li class='green'><span class=''> </span><code>         * @property {patio.sql.Identifier[]} [sourceList=[]] a list of sources for this dataset.</code></li>
<li class='green'><span class=''> </span><code>         * @property {patio.sql.Identifier[]} [joinSourceList=[]] a list of join sources</code></li>
<li class='green'><span class=''> </span><code>         * @property {Boolean} hasSelectSource true if this dataset already has a select sources.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (db, opts) {</code></li>
<li class='green'><span class='hits'>28667</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>28667</span><code>            this.db = db;</code></li>
<li class='green'><span class='hits'>28667</span><code>            this.__opts = {};</code></li>
<li class='green'><span class='hits'>28667</span><code>            this.__rowCb = null;</code></li>
<li class='green'><span class='hits'>28667</span><code>            if (db) {</code></li>
<li class='green'><span class='hits'>14909</span><code>                this.__quoteIdentifiers = db.quoteIdentifiers;</code></li>
<li class='green'><span class='hits'>14909</span><code>                this.__identifierInputMethod = db.identifierInputMethod;</code></li>
<li class='green'><span class='hits'>14909</span><code>                this.__identifierOutputMethod = db.identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a new clone of the dataset with with the given options merged into the current datasets options.</code></li>
<li class='green'><span class=''> </span><code>         * If the options changed include options in {@link patio.dataset.Query#COLUMN_CHANGE_OPTS}, the cached</code></li>
<li class='green'><span class=''> </span><code>         * columns are deleted.  This method should generally not be called</code></li>
<li class='green'><span class=''> </span><code>         * directly by user code.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} opts options to merge into the curred datasets options and applied to the returned dataset.</code></li>
<li class='green'><span class=''> </span><code>         * @return [patio.Dataset] a cloned dataset with the merged options</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        mergeOptions:function (opts) {</code></li>
<li class='green'><span class='hits'>14920</span><code>            opts = isUndefined(opts) ? {} : opts;</code></li>
<li class='green'><span class='hits'>14920</span><code>            var ds = new this._static(this.db, {});</code></li>
<li class='green'><span class='hits'>14920</span><code>            ds.rowCb = this.rowCb;</code></li>
<li class='green'><span class='hits'>14920</span><code>            this._static.FEATURES.forEach(function (f) {</code></li>
<li class='green'><span class='hits'>208880</span><code>                ds[f] = this[f];</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>14920</span><code>            var dsOpts = ds.__opts = merge({}, this.__opts, opts);</code></li>
<li class='green'><span class='hits'>14920</span><code>            ds.identifierInputMethod = this.identifierInputMethod;</code></li>
<li class='green'><span class='hits'>14920</span><code>            ds.identifierOutputMethod = this.identifierOutputMethod;</code></li>
<li class='green'><span class='hits'>14920</span><code>            var columnChangeOpts = this._static.COLUMN_CHANGE_OPTS;</code></li>
<li class='green'><span class='hits'>14920</span><code>            if (Object.keys(opts).some(function (o) {</code></li>
<li class='green'><span class='hits'>13500</span><code>                return columnChangeOpts.indexOf(o) !== -1;</code></li>
<li class='green'><span class=''> </span><code>            })) {</code></li>
<li class='green'><span class='hits'>2357</span><code>                dsOpts.columns = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>14920</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a string to an {@link patio.sql.Identifier}, {@link patio.sql.QualifiedIdentifier},</code></li>
<li class='green'><span class=''> </span><code>         * or {@link patio.sql.AliasedExpression}, depending on the format:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;For columns : table__column___alias.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;For tables : schema__table___alias.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * each portion of the identifier is optional. See example below</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.stringToIdentifier("a") //= &gt; new patio.sql.Identifier("a");</code></li>
<li class='green'><span class=''> </span><code>         * ds.stringToIdentifier("table__column"); //=&gt; new patio.sql.QualifiedIdentifier(table, column);</code></li>
<li class='green'><span class=''> </span><code>         * ds.stringToIdentifier("table__column___alias");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; new patio.sql.AliasedExpression(new patio.sql.QualifiedIdentifier(table, column), alias);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} name the name to covert to an an {@link patio.sql.Identifier}, {@link patio.sql.QualifiedIdentifier},</code></li>
<li class='green'><span class=''> </span><code>         * or {@link patio.sql.AliasedExpression}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return  {patio.sql.Identifier|patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} an identifier generated based on the name string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        stringToIdentifier:function (name) {</code></li>
<li class='green'><span class='hits'>14504</span><code>            if (isString(name)) {</code></li>
<li class='green'><span class='hits'>9680</span><code>                var parts = this._splitString(name);</code></li>
<li class='green'><span class='hits'>9680</span><code>                var schema = parts[0], table = parts[1], alias = parts[2];</code></li>
<li class='green'><span class='hits'>9680</span><code>                return (schema &amp;&amp; table &amp;&amp; alias</code></li>
<li class='green'><span class=''> </span><code>                    ? new AliasedExpression(new QualifiedIdentifier(schema, table), alias)</code></li>
<li class='green'><span class=''> </span><code>                    : (schema &amp;&amp; table</code></li>
<li class='green'><span class=''> </span><code>                    ? new QualifiedIdentifier(schema, table)</code></li>
<li class='green'><span class=''> </span><code>                    : (table &amp;&amp; alias</code></li>
<li class='green'><span class=''> </span><code>                    ? new AliasedExpression(new Identifier(table), alias) : new Identifier(table))));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>4824</span><code>                return name;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Can either be a string or null.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * //columns</code></li>
<li class='green'><span class=''> </span><code>         *  table__column___alias //=&gt; table.column as alias</code></li>
<li class='green'><span class=''> </span><code>         *  table__column //=&gt; table.column</code></li>
<li class='green'><span class=''> </span><code>         *  //tables</code></li>
<li class='green'><span class=''> </span><code>         *  schema__table___alias //=&gt; schema.table as alias</code></li>
<li class='green'><span class=''> </span><code>         *  schema__table //=&gt; schema.table</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //name and alias</code></li>
<li class='green'><span class=''> </span><code>         * columnOrTable___alias //=&gt; columnOrTable as alias</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String[]} an array with the elements being:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;For columns :[table, column, alias].&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;For tables : [schema, table, alias].&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _splitString:function (s) {</code></li>
<li class='green'><span class='hits'>19252</span><code>            var ret, m;</code></li>
<li class='green'><span class='hits'>19252</span><code>            if ((m = s.match(this._static.COLUMN_REF_RE1)) !== null) {</code></li>
<li class='green'><span class='hits'>156</span><code>                ret = m.slice(1);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>19096</span><code>            else if ((m = s.match(this._static.COLUMN_REF_RE2)) !== null) {</code></li>
<li class='green'><span class='hits'>24</span><code>                ret = [null, m[1], m[2]];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>19072</span><code>            else if ((m = s.match(this._static.COLUMN_REF_RE3)) !== null) {</code></li>
<li class='green'><span class='hits'>1782</span><code>                ret = [m[1], m[2], null];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>            else {</code></li>
<li class='green'><span class='hits'>17290</span><code>                ret = [null, s, null];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>19252</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            rowCb:function () {</code></li>
<li class='green'><span class='hits'>21756</span><code>                return this.__rowCb;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function () {</code></li>
<li class='green'><span class='hits'>14920</span><code>                return this.__identifierInputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function () {</code></li>
<li class='green'><span class='hits'>14920</span><code>                return this.__identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            firstSourceAlias:function () {</code></li>
<li class='green'><span class='hits'>579</span><code>                var source = this.__opts.from;</code></li>
<li class='green'><span class='hits'>579</span><code>                if (isUndefinedOrNull(source) || !source.length) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    throw new DatasetError("No source specified for the query");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>577</span><code>                source = source[0];</code></li>
<li class='green'><span class='hits'>577</span><code>                if (isInstanceOf(source, AliasedExpression)) {</code></li>
<li class='green'><span class='hits'>20</span><code>                    return source.alias;</code></li>
<li class='green'><span class='hits'>557</span><code>                } else if (isString(source)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var parts = this._splitString(source);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var alias = parts[2];</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return alias ? alias : source;</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>557</span><code>                    return source;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            firstSourceTable:function () {</code></li>
<li class='green'><span class='hits'>15</span><code>                var source = this.__opts.from;</code></li>
<li class='green'><span class='hits'>15</span><code>                if (isUndefinedOrNull(source) || !source.length) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    throw new QueryError("No source specified for the query");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>14</span><code>                var source = source[0];</code></li>
<li class='green'><span class='hits'>14</span><code>                if (isInstanceOf(source, AliasedExpression)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    return source.expression;</code></li>
<li class='green'><span class='hits'>11</span><code>                } else if (isString(source)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var parts = this._splitString(source);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return source;</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>11</span><code>                    return source;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            sourceList:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return (this.__opts.from || []).map(this.stringToIdentifier, this);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            joinSourceList:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return (this.__opts.join || []).map(function (join) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this.stringToIdentifier(join.tableAlias || join.table);</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            hasSelectSource:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var select = this.__opts.select;</code></li>
<li class='red'><span class='nohits'>0</span><code>                return !(isUndefinedOrNull(select) || select.length === 0);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function (meth) {</code></li>
<li class='green'><span class='hits'>15010</span><code>                this.__identifierInputMethod = meth;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function (meth) {</code></li>
<li class='green'><span class='hits'>15010</span><code>                this.__identifierOutputMethod = meth;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            rowCb:function (cb) {</code></li>
<li class='green'><span class='hits'>18552</span><code>                if (isFunction(cb) || isNull(cb)) {</code></li>
<li class='green'><span class='hits'>18547</span><code>                    this.__rowCb = cb;</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>5</span><code>                    throw new DatasetError("rowCb mus be a function");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        COLUMN_REF_RE1:/^(\w+)__(\w+)___(\w+)$/,</code></li>
<li class='green'><span class=''> </span><code>        COLUMN_REF_RE2:/^(\w+)___(\w+)$/,</code></li>
<li class='green'><span class=''> </span><code>        COLUMN_REF_RE3:/^(\w+)__(\w+)$/</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="model.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>model.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>87.95</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>1118</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>332</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>40</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="model.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isDefined = comb.isDefined,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    toArray = comb.array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    ModelError = require("./errors").ModelError,</code></li>
<li class='green'><span class=''> </span><code>    plugins = require("./plugins"),</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    AssociationPlugin = plugins.AssociationPlugin,</code></li>
<li class='green'><span class=''> </span><code>    QueryPlugin = plugins.QueryPlugin,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    HashTable = comb.collections.HashTable,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    hitchIgnore = comb.hitchIgnore,</code></li>
<li class='green'><span class=''> </span><code>    Middleware = comb.plugins.Middleware,</code></li>
<li class='green'><span class=''> </span><code>    EventEmitter = require("events").EventEmitter,</code></li>
<li class='green'><span class=''> </span><code>    util = require("util"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    patio;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var MODELS = new HashTable();</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var applyColumnTransformMethod = function (val, meth) {</code></li>
<li class='green'><span class='hits'>947</span><code>    return !isUndefinedOrNull(meth) ? isFunction(val[meth]) ? val[meth] : isFunction(comb[meth]) ? comb[meth](val) : val : val;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var checkAndTransformName = function (name) {</code></li>
<li class='green'><span class='hits'>176</span><code>    return isString(name) ? applyColumnTransformMethod(name, Model.camelize === true ? "camelize" : Model.underscore === true ? "underscore" : null) : name;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Model = define([QueryPlugin, Middleware], {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @lends patio.Model.prototype</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __ignore:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __changed:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __values:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * patio  - read only</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type patio</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        patio:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The database type such as mysql</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        type:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Whether or not this model is new</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __isNew:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Signifies if the model has changed</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __isChanged:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Base class for all models.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;This is used through {@link patio.addModel}, &lt;b&gt;NOT directly.&lt;/b&gt;&lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments comb.plugins.Middleware</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} columnValues values of each column to be used by this Model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {patio.Dataset} dataset a dataset to use to retrieve models from the database. The dataset</code></li>
<li class='green'><span class=''> </span><code>         *                          has the {@link patio.Dataset#rowCb} set to create instances of this model.</code></li>
<li class='green'><span class=''> </span><code>         * @property {String[]} columns a list of columns this models table contains.</code></li>
<li class='green'><span class=''> </span><code>         * @property {Object} schema the schema of this models table.</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} tableName the table name of this models table.</code></li>
<li class='green'><span class=''> </span><code>         * @property {*} primaryKeyValue the value of this models primaryKey</code></li>
<li class='green'><span class=''> </span><code>         * @property {Boolean} isNew true if this model is new and does not exist in the database.</code></li>
<li class='green'><span class=''> </span><code>         * @property {Boolean} isChanged true if the model has been changed and not saved.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#all as all</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#one as one</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#avg as avg</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#count as count</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#columns as columns</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#forEach as forEach</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#isEmpty as empty</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#first as first</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#get as get</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#import as import</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#insert as insert</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#insertMultiple as insertMultiple</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#saveMultiple as saveMultiple</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#interval as interval</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#last as last</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#map as map</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#max as max</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#min as min</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#multiInsert as multiInsert</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#range as range</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#selectHash as selectHash</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#selectMap as selectMap</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#selectOrderMap as selectOrderMap</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#set as set</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#singleRecord as singleRecord</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#singleValue as singleValue</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#sum as sum</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#toCsv as toCsv</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#toHash as toHash</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#truncate as truncate</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#addGraphAliases as addGraphAliases</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#and as and</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#distinct as distinct</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#except as except</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#exclude as exclude</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#is as is</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#isNot as isNot</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#eq as eq</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#neq as neq</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#lt as lt</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#lte as lte</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#gt as gt</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#gte as gte</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#forUpdate as forUpdate</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#from as from</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#fromSelf as fromSelf</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#graph as graph</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#grep as grep</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#group as group</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#groupAndCount as groupAndCount</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#groupBy as groupBy</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#having as having</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#intersect as intersect</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#invert as invert</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#limit as limit</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#lockStyle as lockStyle</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#naked as naked</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#or as or</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#order as order</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#orderAppend as orderAppend</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#orderBy as orderBy</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#orderMore as orderMore</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#orderPrepend as orderPrepend</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#qualify as qualify</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#reverse as reverse</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#reverseOrder as reverseOrder</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#select as select</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#selectAll as selectAll</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#selectAppend as selectAppend</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#selectMore as selectMore</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#setDefaults as setDefaults</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#setGraphAliases as setGraphAliases</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#setOverrides as setOverrides</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#unfiltered as unfiltered</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#ungraphed as ungraphed</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#ungrouped as ungrouped</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#union as union</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#unlimited as unlimited</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#unordered as unordered</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#where as where</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#with as with</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#withRecursive as withRecursive</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#withSql as withSql</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#naturalJoin as naturalJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#naturalLeftJoin as naturalLeftJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#naturalRightJoin as naturalRightJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#naturalFullJoin as naturalFullJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#crossJoin as crossJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#innerJoin as innerJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#fullOuterJoin as fullOuterJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#rightOuterJoin as rightOuterJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#leftOuterJoin as leftOuterJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#fullJoin as fullJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#rightJoin as rightJoin</code></li>
<li class='green'><span class=''> </span><code>         * @borrows patio.Dataset#leftJoin as leftJoin</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (options, fromDb) {</code></li>
<li class='green'><span class='hits'>3125</span><code>            if (this.synced) {</code></li>
<li class='green'><span class='hits'>3125</span><code>                this.__emitter = new EventEmitter();</code></li>
<li class='green'><span class='hits'>3125</span><code>                this._super(arguments);</code></li>
<li class='green'><span class='hits'>3125</span><code>                this.patio = patio || require("./index");</code></li>
<li class='green'><span class='hits'>3125</span><code>                fromDb = isBoolean(fromDb) ? fromDb : false;</code></li>
<li class='green'><span class='hits'>3125</span><code>                this.__changed = {};</code></li>
<li class='green'><span class='hits'>3125</span><code>                this.__values = {};</code></li>
<li class='green'><span class='hits'>3125</span><code>                if (fromDb) {</code></li>
<li class='green'><span class='hits'>1770</span><code>                    this._hook("pre", "load");</code></li>
<li class='green'><span class='hits'>1770</span><code>                    this.__isNew = false;</code></li>
<li class='green'><span class='hits'>1770</span><code>                    this.__setFromDb(options, true);</code></li>
<li class='green'><span class='hits'>1770</span><code>                    if (this._static.emitOnLoad) {</code></li>
<li class='green'><span class='hits'>1770</span><code>                        this.emit("load", this);</code></li>
<li class='green'><span class='hits'>1770</span><code>                        this._static.emit("load", this);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>1355</span><code>                    this.__isNew = true;</code></li>
<li class='green'><span class='hits'>1355</span><code>                    this.__set(options);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("Model " + this.tableName + " has not been synced");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __set:function (values, ignore) {</code></li>
<li class='green'><span class='hits'>1479</span><code>            values = values || {};</code></li>
<li class='green'><span class='hits'>1479</span><code>            this.__ignore = ignore === true;</code></li>
<li class='green'><span class='hits'>1479</span><code>            Object.keys(values).forEach(function (attribute) {</code></li>
<li class='green'><span class='hits'>6698</span><code>                var value = values[attribute];</code></li>
<li class='green'><span class=''> </span><code>                //check if the column is a constrained value and is allowed to be set</code></li>
<li class='green'><span class='hits'>6698</span><code>                !ignore &amp;&amp; this._checkIfColumnIsConstrained(attribute);</code></li>
<li class='green'><span class='hits'>6698</span><code>                this[attribute] = value;</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>1479</span><code>            this.__ignore = false;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __setFromDb:function (values, ignore) {</code></li>
<li class='green'><span class='hits'>3087</span><code>            values = values || {};</code></li>
<li class='green'><span class='hits'>3087</span><code>            this.__ignore = ignore === true;</code></li>
<li class='green'><span class='hits'>3087</span><code>            var schema = this.schema;</code></li>
<li class='green'><span class='hits'>3087</span><code>            Object.keys(values).forEach(function (column) {</code></li>
<li class='green'><span class='hits'>26056</span><code>                var value = values[column];</code></li>
<li class='green'><span class=''> </span><code>                // Typecast value retrieved from db</code></li>
<li class='green'><span class='hits'>26056</span><code>                if (schema.hasOwnProperty(column)) {</code></li>
<li class='green'><span class='hits'>25375</span><code>                    this.__values[column] = this._typeCastValue(column, value, ignore);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>681</span><code>                    this[column] = value;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>3087</span><code>            this.__ignore = false;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set multiple values at once. Useful if you have a hash of properties that you want to set.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;NOTE:&lt;/b&gt; This method will use the static restrictedColumns property of the model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * myModel.setValues({firstName : "Bob", lastName : "yukon"});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //this will throw an error by default, assuming id is a pk.</code></li>
<li class='green'><span class=''> </span><code>         * myModel.setValues({id : 1, firstName : "Bob", lastName : "yukon"});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} values value to set on the model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Model} return this for chaining.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        setValues:function (values) {</code></li>
<li class='green'><span class='hits'>17</span><code>            this.__set(values, false);</code></li>
<li class='green'><span class='hits'>17</span><code>            return this;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _toObject:function () {</code></li>
<li class='green'><span class='hits'>1138</span><code>            if (this.synced) {</code></li>
<li class='green'><span class='hits'>1138</span><code>                var columns = this._static.columns, ret = {};</code></li>
<li class='green'><span class='hits'>1138</span><code>                for (var i in columns) {</code></li>
<li class='green'><span class='hits'>10365</span><code>                    var col = columns[i];</code></li>
<li class='green'><span class='hits'>10365</span><code>                    var val = this.__values[col];</code></li>
<li class='green'><span class='hits'>10365</span><code>                    if (!isUndefined(val)) {</code></li>
<li class='green'><span class='hits'>6278</span><code>                        ret[col] = val;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1138</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("Model " + this.tableName + " has not been synced");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _addColumnToIsChanged:function (name, val) {</code></li>
<li class='green'><span class='hits'>7643</span><code>            if (!this.isNew &amp;&amp; !this.__ignore) {</code></li>
<li class='green'><span class='hits'>174</span><code>                this.__isChanged = true;</code></li>
<li class='green'><span class='hits'>174</span><code>                this.__changed[name] = val;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _checkIfColumnIsConstrained:function (name) {</code></li>
<li class='green'><span class='hits'>6698</span><code>            if (this.synced &amp;&amp; !this.__ignore) {</code></li>
<li class='green'><span class='hits'>6698</span><code>                var col = this.schema[name], restrictedCols = this._static.restrictedColumns || [];</code></li>
<li class='green'><span class='hits'>6698</span><code>                if (!isUndefined(col) &amp;&amp; (col.primaryKey &amp;&amp; this._static.isRestrictedPrimaryKey) || restrictedCols.indexOf(name) != -1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ModelError("Cannot set primary key of model " + this._static.tableName);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getColumnValue:function (name) {</code></li>
<li class='green'><span class='hits'>5464</span><code>            var val = this.__values[name];</code></li>
<li class='green'><span class='hits'>5464</span><code>            var getterFunc = this["_get" + name.charAt(0).toUpperCase() + name.substr(1)];</code></li>
<li class='green'><span class='hits'>5464</span><code>            var columnValue = isFunction(getterFunc) ? getterFunc.call(this, val) : val;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>5464</span><code>            return columnValue;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setColumnValue:function (name, val) {</code></li>
<li class='green'><span class='hits'>7643</span><code>            var ignore = this.__ignore;</code></li>
<li class='green'><span class='hits'>7643</span><code>            val = this._typeCastValue(name, val, ignore);</code></li>
<li class='green'><span class='hits'>7643</span><code>            this._addColumnToIsChanged(name, val);</code></li>
<li class='green'><span class='hits'>7643</span><code>            var setterFunc = this["_set" + name.charAt(0).toUpperCase() + name.substr(1)];</code></li>
<li class='green'><span class='hits'>7643</span><code>            var columnValue = isFunction(setterFunc) ? setterFunc.call(this, val, ignore) : val;</code></li>
<li class='green'><span class='hits'>7643</span><code>            this.__values[name] = columnValue;</code></li>
<li class='green'><span class='hits'>7643</span><code>            if (this._static.emitOnColumnSet) {</code></li>
<li class='green'><span class='hits'>7643</span><code>                this.emit("column", name, columnValue, ignore);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Typecast the value to the column's type if typecasting.  Calls the database's</code></li>
<li class='green'><span class=''> </span><code>        //typecast_value method, so database adapters can override/augment the handling</code></li>
<li class='green'><span class=''> </span><code>        //for database specific column types.</code></li>
<li class='green'><span class=''> </span><code>        _typeCastValue:function (column, value, fromDatabase) {</code></li>
<li class='green'><span class='hits'>33018</span><code>            var colSchema, clazz = this._static;</code></li>
<li class='green'><span class='hits'>33018</span><code>            if (((fromDatabase &amp;&amp; clazz.typecastOnLoad) || (!fromDatabase &amp;&amp; clazz.typecastOnAssignment)) &amp;&amp; !isUndefinedOrNull(this.schema) &amp;&amp; !isUndefinedOrNull((colSchema = this.schema[column]))) {</code></li>
<li class='green'><span class='hits'>33018</span><code>                var type = colSchema.type;</code></li>
<li class='green'><span class='hits'>33018</span><code>                if (value === "" &amp;&amp; clazz.typecastEmptyStringToNull === true &amp;&amp; !isUndefinedOrNull(type) &amp;&amp; ["string", "blob"].indexOf(type) === -1) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    value = null;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>33018</span><code>                var raiseOnError = clazz.raiseOnTypecastError;</code></li>
<li class='green'><span class='hits'>33018</span><code>                if (raiseOnError === true &amp;&amp; isUndefinedOrNull(value) &amp;&amp; colSchema.allowNull === false) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ModelError("null is not allowed for the " + column + " column.");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>33018</span><code>                try {</code></li>
<li class='green'><span class='hits'>33018</span><code>                    value = clazz.db.typecastValue(type, value);</code></li>
<li class='green'><span class=''> </span><code>                } catch (e) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (raiseOnError === true) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        throw e;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>33018</span><code>            return value;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Convert this model to an object, containing column, value pairs.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Object} the object version of this model.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        toObject:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this._toObject(false);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Convert this model to JSON, containing column, value pairs.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {JSON} the JSON version of this model.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        toJSON:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.toObject();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Convert this model to a string, containing column, value pairs.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the string version of this model.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        toString:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return JSON.stringify(this.toObject(), null, 4);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Convert this model to a string, containing column, value pairs.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the string version of this model.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        valueOf:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.toObject();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _checkTransaction:function (options, cb) {</code></li>
<li class='green'><span class='hits'>2515</span><code>            return this._static._checkTransaction(options, cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        addListener:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var emitter = this.__emitter;</code></li>
<li class='red'><span class='nohits'>0</span><code>            return emitter.addListener.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        on:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            var emitter = this.__emitter;</code></li>
<li class='green'><span class='hits'>6</span><code>            return emitter.on.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        once:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var emitter = this.__emitter;</code></li>
<li class='red'><span class='nohits'>0</span><code>            return emitter.once.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        removeListener:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            var emitter = this.__emitter;</code></li>
<li class='green'><span class='hits'>6</span><code>            return emitter.removeListener.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        removeAllListeners:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var emitter = this.__emitter;</code></li>
<li class='red'><span class='nohits'>0</span><code>            return emitter.removeAllListeners.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        setMaxListeners:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var emitter = this.__emitter;</code></li>
<li class='red'><span class='nohits'>0</span><code>            return emitter.setMaxListeners.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        listeners:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var emitter = this.__emitter;</code></li>
<li class='red'><span class='nohits'>0</span><code>            return emitter.listeners.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        emit:function () {</code></li>
<li class='green'><span class='hits'>11245</span><code>            var emitter = this.__emitter;</code></li>
<li class='green'><span class='hits'>11245</span><code>            return emitter.emit.apply(emitter, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Model.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /*Returns my actual primary key value*/</code></li>
<li class='green'><span class=''> </span><code>            primaryKeyValue:function () {</code></li>
<li class='green'><span class='hits'>48</span><code>                return this[this.primaryKey];</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /*Return if Im a new object*/</code></li>
<li class='green'><span class=''> </span><code>            isNew:function () {</code></li>
<li class='green'><span class='hits'>9733</span><code>                return this.__isNew;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /*Return if Im changed*/</code></li>
<li class='green'><span class=''> </span><code>            isChanged:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__isChanged;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Model.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            primaryKey:function () {</code></li>
<li class='green'><span class='hits'>2611</span><code>                return this._static.primaryKey;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            tableName:function () {</code></li>
<li class='green'><span class='hits'>41</span><code>                return this._static.tableName;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            dataset:function () {</code></li>
<li class='green'><span class='hits'>3119</span><code>                return this.__dataset || (this.__dataset = this._static.dataset);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            removeDataset:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                return this.__removeDataset || (this.__removeDataset = this._static.removeDataset);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            queryDataset:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__queryDataset || (this.__queryDataset = this._static.queryDataset);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            updateDataset:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this.__updateDataset || (this.__updateDataset = this._static.updateDataset);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            insertDataset:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this.__insertDataset || (this.__insertDataset = this._static.insertDataset);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            db:function () {</code></li>
<li class='green'><span class='hits'>30</span><code>                return this._static.db;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            schema:function () {</code></li>
<li class='green'><span class='hits'>75821</span><code>                return this._static.schema;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            columns:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this._static.columns;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            synced:function () {</code></li>
<li class='green'><span class='hits'>12900</span><code>                return this._static.synced;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @lends patio.Model</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        synced:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent the emitting of an event on load</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        emitOnLoad:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent the emitting of an event on the setting of a column value</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        emitOnColumnSet:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent empty strings from being type casted to null</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        typecastEmptyStringToNull:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent properties from being type casted when loaded from the database.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Database#typecastValue}</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        typecastOnLoad:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent properties from being type casted when manually set.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Database#typecastValue}</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        typecastOnAssignment:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent errors thrown while type casting a value from being propogated.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        raiseOnTypecastError:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to allow the setting of primary keys.</code></li>
<li class='green'><span class=''> </span><code>         * @default false</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isRestrictedPrimaryKey:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent models from using transactions when saving, deleting, or updating.</code></li>
<li class='green'><span class=''> </span><code>         * This applies to the model associations also.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        useTransactions:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Dataset#identifierOutputMethod}</code></li>
<li class='green'><span class=''> </span><code>         * @default null</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        identifierOutputMethod:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Dataset#identifierInputMethod}</code></li>
<li class='green'><span class=''> </span><code>         * @default null</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        identifierInputMethod:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent the reload of a model after saving.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        reloadOnSave:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Columns that should be restriced when setting values through the {@link patio.Model#set} method.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        restrictedColumns:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent the reload of a model after updating.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        reloadOnUpdate:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __camelize:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __underscore:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __columns:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __schema:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __primaryKey:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __dataset:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __db:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __tableName:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The table that this Model represents.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;READ ONLY&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        table:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * patio  - read only</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type patio</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        patio:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        init:function () {</code></li>
<li class='green'><span class='hits'>92</span><code>            var emitter = new EventEmitter();</code></li>
<li class='green'><span class='hits'>92</span><code>            ["addListener", "on", "once", "removeListener",</code></li>
<li class='green'><span class=''> </span><code>                "removeAllListeners", "setMaxListeners", "listeners", "emit"].forEach(function (name) {</code></li>
<li class='green'><span class='hits'>736</span><code>                    this[name] = emitter[name].bind(emitter);</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class='hits'>92</span><code>            if (this.__tableName) {</code></li>
<li class='green'><span class='hits'>91</span><code>                this._setTableName(this.__tableName);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>92</span><code>            if (this.__db) {</code></li>
<li class='green'><span class='hits'>40</span><code>                this._setDb(this.__db);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        sync:function (cb) {</code></li>
<li class='green'><span class='hits'>4016</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>4016</span><code>            if (!this.synced) {</code></li>
<li class='green'><span class='hits'>93</span><code>                var db = this.db, tableName = this.tableName, supers = this.__supers;</code></li>
<li class='green'><span class='hits'>93</span><code>                ret = db.schema(tableName).chain(hitch(this, function (schema) {</code></li>
<li class='green'><span class='hits'>93</span><code>                    if (!this.synced &amp;&amp; schema) {</code></li>
<li class='green'><span class='hits'>93</span><code>                        this._setSchema(schema);</code></li>
<li class='green'><span class='hits'>93</span><code>                        if (supers &amp;&amp; supers.length) {</code></li>
<li class='green'><span class='hits'>3</span><code>                            return when(supers.map(function (sup) {</code></li>
<li class='green'><span class='hits'>3</span><code>                                return sup.sync();</code></li>
<li class='green'><span class=''> </span><code>                            })).chain(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                                this.synced = true;</code></li>
<li class='green'><span class='hits'>3</span><code>                                supers.forEach(this.inherits, this);</code></li>
<li class='green'><span class='hits'>3</span><code>                                return this;</code></li>
<li class='green'><span class=''> </span><code>                            }));</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>90</span><code>                            this.synced = true;</code></li>
<li class='green'><span class='hits'>90</span><code>                            return this;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        var error = new ModelError("Unable to find schema for " + tableName);</code></li>
<li class='red'><span class='nohits'>0</span><code>                        this.emit("error", error);</code></li>
<li class='red'><span class='nohits'>0</span><code>                        throw error;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3923</span><code>                ret.callback(this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4016</span><code>            if (isFunction(cb)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.classic(cb);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4016</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Stub for plugins to notified of model inheritance</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Model} model a model class to inherit from</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        inherits:function (model) {</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Create a new model initialized with the specified values.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} values  the values to initialize the model with.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @returns {Model} instantiated model initialized with the values passed in.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        create:function (values) {</code></li>
<li class='green'><span class=''> </span><code>            //load an object from an object</code></li>
<li class='red'><span class='nohits'>0</span><code>            return new this(values, false);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        load:function (vals) {</code></li>
<li class='green'><span class='hits'>934</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class=''> </span><code>            //sync our model</code></li>
<li class='green'><span class='hits'>934</span><code>            return this.sync().chain(function () {</code></li>
<li class='green'><span class='hits'>934</span><code>                var m = new this(vals, true);</code></li>
<li class='green'><span class=''> </span><code>                //call the hooks!</code></li>
<li class='green'><span class='hits'>934</span><code>                return m._hook("post", "load").chain(function () {</code></li>
<li class='green'><span class='hits'>934</span><code>                    return m;</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _checkTransaction:function (opts, cb) {</code></li>
<li class='green'><span class='hits'>2930</span><code>            if (isFunction(opts)) {</code></li>
<li class='green'><span class='hits'>639</span><code>                cb = opts;</code></li>
<li class='green'><span class='hits'>639</span><code>                opts = {};</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2291</span><code>                opts = opts || {};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2930</span><code>            var ret = new Promise(), retVal = null, errored = false;</code></li>
<li class='green'><span class='hits'>2930</span><code>            this.sync().then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>2930</span><code>                if (this.useTransaction(opts)) {</code></li>
<li class='green'><span class='hits'>2930</span><code>                    this.db.transaction(opts, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>2930</span><code>                        return when(cb()).then(function () {</code></li>
<li class='green'><span class='hits'>2886</span><code>                            retVal = argsToArray(arguments);</code></li>
<li class='green'><span class=''> </span><code>                        }, function () {</code></li>
<li class='green'><span class='hits'>44</span><code>                            retVal = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>44</span><code>                            errored = true;</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class=''> </span><code>                    })).then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>2886</span><code>                        ret[errored ? "errback" : "callback"].apply(ret, retVal);</code></li>
<li class='green'><span class=''> </span><code>                    }), hitch(this, function () {</code></li>
<li class='green'><span class='hits'>44</span><code>                        if (errored) {</code></li>
<li class='green'><span class='hits'>44</span><code>                            ret.errback.apply(ret, retVal);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            ret.errback.apply(ret, arguments);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    when(cb()).then(ret);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }), ret);</code></li>
<li class='green'><span class='hits'>2930</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Returns a boolean indicating whether or not to use a transaction.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] set a transaction property to override the {@link patio.Model#useTransaction}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        useTransaction:function (opts) {</code></li>
<li class='green'><span class='hits'>2930</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>2930</span><code>            return isBoolean(opts.transaction) ? opts.transaction === true : this.useTransactions === true;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setDataset:function (ds) {</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__dataset = ds;</code></li>
<li class='green'><span class='hits'>3</span><code>            if (ds.db) {</code></li>
<li class='green'><span class='hits'>3</span><code>                this._setDb(ds.db);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setDb:function (db) {</code></li>
<li class='green'><span class='hits'>43</span><code>            this.__db = db;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setTableName:function (name) {</code></li>
<li class='green'><span class='hits'>91</span><code>            this.__tableName = name;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setColumns:function (cols) {</code></li>
<li class='green'><span class='hits'>96</span><code>            var proto = this.prototype;</code></li>
<li class='green'><span class='hits'>96</span><code>            if (this.__columns) {</code></li>
<li class='green'><span class='hits'>6</span><code>                this.__columns.forEach(function (name) {</code></li>
<li class='green'><span class='hits'>16</span><code>                    delete proto[name];</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>96</span><code>            this.__columns = cols;</code></li>
<li class='green'><span class='hits'>96</span><code>            cols.forEach(function (name) {</code></li>
<li class='green'><span class='hits'>779</span><code>                this._defineColumnSetter(name);</code></li>
<li class='green'><span class='hits'>779</span><code>                this._defineColumnGetter(name);</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setPrimaryKey:function (pks) {</code></li>
<li class='green'><span class='hits'>99</span><code>            this.__primaryKey = pks || [];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setSchema:function (schema) {</code></li>
<li class='green'><span class='hits'>96</span><code>            var columns = [];</code></li>
<li class='green'><span class='hits'>96</span><code>            var pks = [];</code></li>
<li class='green'><span class='hits'>96</span><code>            for (var i in schema) {</code></li>
<li class='green'><span class='hits'>779</span><code>                var col = schema[i];</code></li>
<li class='green'><span class='hits'>779</span><code>                var name = applyColumnTransformMethod(i, this.identifierOutputMethod);</code></li>
<li class='green'><span class='hits'>779</span><code>                schema[name] = col;</code></li>
<li class='green'><span class='hits'>779</span><code>                columns.push(name);</code></li>
<li class='green'><span class='hits'>779</span><code>                col.primaryKey &amp;&amp; pks.push(name);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>96</span><code>            this.__schema = schema;</code></li>
<li class='green'><span class='hits'>96</span><code>            this._setPrimaryKey(pks);</code></li>
<li class='green'><span class='hits'>96</span><code>            this._setColumns(columns);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _defineColumnSetter:function (name) {</code></li>
<li class='green'><span class=''> </span><code>            /*Adds a setter to an object*/</code></li>
<li class='green'><span class='hits'>779</span><code>            this.prototype.__defineSetter__(name, function (val) {</code></li>
<li class='green'><span class='hits'>7643</span><code>                this._setColumnValue(name, val);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _defineColumnGetter:function (name) {</code></li>
<li class='green'><span class='hits'>779</span><code>            this.prototype.__defineGetter__(name, function () {</code></li>
<li class='green'><span class='hits'>5464</span><code>                return this._getColumnValue(name);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getDataset:function () {</code></li>
<li class='green'><span class='hits'>3576</span><code>            var ds = this.__dataset;</code></li>
<li class='green'><span class='hits'>3576</span><code>            if (!ds) {</code></li>
<li class='green'><span class='hits'>84</span><code>                ds = this.db.from(this.tableName);</code></li>
<li class='green'><span class='hits'>84</span><code>                ds.rowCb = hitch(this, function (vals) {</code></li>
<li class='green'><span class='hits'>883</span><code>                    return this.load(vals);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>84</span><code>                this.identifierInputMethod &amp;&amp; (ds.identifierInputMethod = this.identifierInputMethod);</code></li>
<li class='green'><span class='hits'>84</span><code>                this.identifierOutputMethod &amp;&amp; (ds.identifierOutputMethod = this.identifierOutputMethod);</code></li>
<li class='green'><span class='hits'>84</span><code>                this.__dataset = ds;</code></li>
<li class='green'><span class='hits'>3492</span><code>            } else if (!ds.rowCb) {</code></li>
<li class='green'><span class='hits'>6</span><code>                ds.rowCb = hitch(this, function rowCb(vals) {</code></li>
<li class='green'><span class='hits'>25</span><code>                    return this.load(vals);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3576</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getQueryDataset:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this._getDataset();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getUpdateDataset:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this._getDataset();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getRemoveDataset:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this._getDataset();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getInsertDataset:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this._getDataset();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Model*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Set to true if this models column names should be use the "underscore" method when sending</code></li>
<li class='green'><span class=''> </span><code>             * keys to the database and to "camelize" method on columns returned from the database. If set to false see</code></li>
<li class='green'><span class=''> </span><code>             * {@link patio.Model#underscore}.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @default false</code></li>
<li class='green'><span class=''> </span><code>             * @type {Boolean}</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            camelize:function (camelize) {</code></li>
<li class='green'><span class='hits'>169</span><code>                return  this.__camelize;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Set to true if this models column names should be use the "camelize" method when sending</code></li>
<li class='green'><span class=''> </span><code>             * keys to the database and to "underscore" method on columns returned from the database. If set to false see</code></li>
<li class='green'><span class=''> </span><code>             * {@link patio.Model#underscore}.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @default false</code></li>
<li class='green'><span class=''> </span><code>             * @type {Boolean}</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            underscore:function (underscore) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return this.__underscore;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Model*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The name of the table all instances of the this {@link patio.Model} use.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            tableName:function () {</code></li>
<li class='green'><span class='hits'>6319</span><code>                return this.__tableName;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The database all instances of this {@link patio.Model} use.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             *  @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @type patio.Database</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            db:function () {</code></li>
<li class='green'><span class='hits'>36210</span><code>                var db = this.__db;</code></li>
<li class='green'><span class='hits'>36210</span><code>                if (!db) {</code></li>
<li class='green'><span class='hits'>53</span><code>                    db = this.__db = patio.defaultDatabase;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>36210</span><code>                if (!db) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ModelError("patio has not been connected to a database");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>36210</span><code>                return db;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * A dataset to use to retrieve instances of this {@link patio.Model{ from the database. The dataset</code></li>
<li class='green'><span class=''> </span><code>             * has the {@link patio.Dataset#rowCb} set to create instances of this model.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             *  @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @type patio.Dataset</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            dataset:function () {</code></li>
<li class='green'><span class='hits'>3566</span><code>                return this._getDataset();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            removeDataset:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                return this._getRemoveDataset();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            queryDataset:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this._getQueryDataset();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            updateDataset:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this._getUpdateDataset();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            insertDataset:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this._getInsertDataset();</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * A list of columns this models table contains.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             *  @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @type String[]</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            columns:function () {</code></li>
<li class='green'><span class='hits'>1142</span><code>                return this.__columns;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The schema of this {@link patio.Model}'s table. See {@link patio.Database#schema} for details</code></li>
<li class='green'><span class=''> </span><code>             * on the schema object.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             *  @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             * @type Object</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            schema:function () {</code></li>
<li class='green'><span class='hits'>75825</span><code>                if (this.synced) {</code></li>
<li class='green'><span class='hits'>75825</span><code>                    return this.__schema;</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ModelError("Model has not been synced yet");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The primaryKey column/s of this {@link patio.Model}</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             *  @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            primaryKey:function () {</code></li>
<li class='green'><span class='hits'>8282</span><code>                if (this.synced) {</code></li>
<li class='green'><span class='hits'>8282</span><code>                    return this.__primaryKey.slice(0);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ModelError("Model has not been synced yet");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * A reference to the global {@link patio}.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             *  @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            patio:function () {</code></li>
<li class='green'><span class='hits'>81</span><code>                return patio || require("./index");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Model*/</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            camelize:function (camelize) {</code></li>
<li class='green'><span class='hits'>26</span><code>                camelize = camelize === true;</code></li>
<li class='green'><span class='hits'>26</span><code>                if (camelize) {</code></li>
<li class='green'><span class='hits'>26</span><code>                    this.identifierOutputMethod = "camelize";</code></li>
<li class='green'><span class='hits'>26</span><code>                    this.identifierInputMethod = "underscore";</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>26</span><code>                this.__camelize = camelize;</code></li>
<li class='green'><span class='hits'>26</span><code>                this.__underscore = !camelize;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            underscore:function (underscore) {</code></li>
<li class='green'><span class='hits'>1</span><code>                underscore = underscore === true;</code></li>
<li class='green'><span class='hits'>1</span><code>                if (underscore) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    this.identifierOutputMethod = "underscore";</code></li>
<li class='green'><span class='hits'>1</span><code>                    this.identifierInputMethod = "camelize";</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1</span><code>                this.__underscore = underscore;</code></li>
<li class='green'><span class='hits'>1</span><code>                this.__camelize = !underscore;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "Model");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>function checkAndAddDBToTable(db, table) {</code></li>
<li class='green'><span class='hits'>93</span><code>    if (!table.contains(db)) {</code></li>
<li class='green'><span class='hits'>34</span><code>        table.set(db, new HashTable());</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**@ignore*/</code></li>
<li class='green'><span class='hits'>1</span><code>exports.create = function (name, supers, modelOptions) {</code></li>
<li class='green'><span class='hits'>93</span><code>    if (!patio) {</code></li>
<li class='green'><span class='hits'>1</span><code>        (patio = require("./index"));</code></li>
<li class='green'><span class='hits'>1</span><code>        patio.on("disconnect", function () {</code></li>
<li class='green'><span class='hits'>39</span><code>            MODELS.clear();</code></li>
<li class='green'><span class=''> </span><code>        });</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>93</span><code>    var db, ds, tableName;</code></li>
<li class='green'><span class='hits'>93</span><code>    var key, modelKey;</code></li>
<li class='green'><span class='hits'>93</span><code>    if (isString(name)) {</code></li>
<li class='green'><span class='hits'>87</span><code>        tableName = name;</code></li>
<li class='green'><span class='hits'>87</span><code>        key = db = patio.defaultDatabase || "default";</code></li>
<li class='green'><span class='hits'>6</span><code>    } else if (isInstanceOf(name, patio.Dataset)) {</code></li>
<li class='green'><span class='hits'>6</span><code>        ds = name;</code></li>
<li class='green'><span class='hits'>6</span><code>        tableName = ds.firstSourceAlias;</code></li>
<li class='green'><span class='hits'>6</span><code>        key = db = ds.db;</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>93</span><code>    var hasSuper = false;</code></li>
<li class='green'><span class='hits'>93</span><code>    if (isHash(supers) || isUndefinedOrNull(supers)) {</code></li>
<li class='green'><span class='hits'>90</span><code>        modelOptions = supers;</code></li>
<li class='green'><span class='hits'>90</span><code>        supers = [Model];</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='green'><span class='hits'>3</span><code>        supers = toArray(supers);</code></li>
<li class='green'><span class='hits'>3</span><code>        supers = supers.map(function (sup) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return exports.getModel(sup, db);</code></li>
<li class='green'><span class=''> </span><code>        });</code></li>
<li class='green'><span class='hits'>3</span><code>        hasSuper = true;</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>93</span><code>    var model;</code></li>
<li class='green'><span class='hits'>93</span><code>    checkAndAddDBToTable(key, MODELS);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>93</span><code>    var DEFAULT_PROTO = {instance:{}, "static":{}};</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions = merge(DEFAULT_PROTO, modelOptions || {});</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions.instance._hooks = ["save", "update", "remove", "load"];</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions.instance.__hooks = {pre:{}, post:{}};</code></li>
<li class='green'><span class=''> </span><code>    //Mixin the column setter/getters</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions["static"].synced = false;</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions["static"].__tableName = tableName;</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions["static"].__db = (db === "default" ? null : db);</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions["static"].__supers = hasSuper ? supers : [];</code></li>
<li class='green'><span class='hits'>93</span><code>    modelOptions["static"].__dataset = ds;</code></li>
<li class='green'><span class='hits'>93</span><code>    model = define(supers.concat(modelOptions.plugins || []).concat([AssociationPlugin]), modelOptions);</code></li>
<li class='green'><span class='hits'>93</span><code>    ["pre", "post"].forEach(function (op) {</code></li>
<li class='green'><span class='hits'>186</span><code>        var optionsOp = modelOptions[op];</code></li>
<li class='green'><span class='hits'>186</span><code>        if (optionsOp) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            for (var i in optionsOp) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                model[op](i, optionsOp[i]);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    });</code></li>
<li class='green'><span class='hits'>93</span><code>    if (!(MODELS.get(key).contains(checkAndTransformName(name)))) {</code></li>
<li class='green'><span class='hits'>61</span><code>        MODELS.get(key).set(name, model);</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>93</span><code>    return model;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>exports.syncModels = function (cb) {</code></li>
<li class='green'><span class='hits'>35</span><code>    var ret = new Promise();</code></li>
<li class='green'><span class='hits'>35</span><code>    serial(MODELS.entrySet.map(function (entry) {</code></li>
<li class='green'><span class='hits'>34</span><code>        return function () {</code></li>
<li class='green'><span class='hits'>34</span><code>            var value = entry.value;</code></li>
<li class='green'><span class='hits'>34</span><code>            return serial(value.entrySet.map(function (m) {</code></li>
<li class='green'><span class='hits'>61</span><code>                return hitch(m.value, "sync");</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        };</code></li>
<li class='green'><span class=''> </span><code>    })).then(hitchIgnore(ret, "callback", true), ret);</code></li>
<li class='green'><span class='hits'>35</span><code>    if (isFunction(cb)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>        ret.classic(cb);</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>35</span><code>    return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var checkAndGetModel = function (db, name) {</code></li>
<li class='green'><span class='hits'>164</span><code>    var ret;</code></li>
<li class='green'><span class='hits'>164</span><code>    if (MODELS.contains(db)) {</code></li>
<li class='green'><span class='hits'>83</span><code>        ret = MODELS.get(db).get(checkAndTransformName(name));</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>164</span><code>    return ret;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>exports.getModel = function (name, db) {</code></li>
<li class='green'><span class='hits'>86</span><code>    var ret = null;</code></li>
<li class='green'><span class='hits'>86</span><code>    if (isDefined(name)) {</code></li>
<li class='green'><span class='hits'>86</span><code>        !patio &amp;&amp; (patio = require("./index"));</code></li>
<li class='green'><span class='hits'>86</span><code>        if (isFunction(name)) {</code></li>
<li class='green'><span class='hits'>3</span><code>            ret = name;</code></li>
<li class='green'><span class=''> </span><code>        } else {</code></li>
<li class='green'><span class='hits'>83</span><code>            if (!db &amp;&amp; isInstanceOf(name, patio.Dataset)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                db = name.db;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>83</span><code>            var defaultDb = patio.defaultDatabase;</code></li>
<li class='green'><span class='hits'>83</span><code>            if (db) {</code></li>
<li class='green'><span class='hits'>57</span><code>                ret = checkAndGetModel(db, name);</code></li>
<li class='green'><span class='hits'>57</span><code>                if (!ret &amp;&amp; db === defaultDb) {</code></li>
<li class='green'><span class='hits'>55</span><code>                    ret = checkAndGetModel("default", name);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>26</span><code>                db = patio.defaultDatabase;</code></li>
<li class='green'><span class='hits'>26</span><code>                ret = checkAndGetModel(db, name);</code></li>
<li class='green'><span class='hits'>26</span><code>                if (!ret) {</code></li>
<li class='green'><span class='hits'>26</span><code>                    ret = checkAndGetModel("default", name);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>        ret = name;</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>86</span><code>    if (isUndefinedOrNull(ret)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>        throw new ModelError("Model " + name + " has not been registered with patio");</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>86</span><code>    return ret;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="errors.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>errors.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>89.47</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>81</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>19</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>2</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="errors.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var patio = exports;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if a function is not impltemened</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.NotImplemented = function(message) {</code></li>
<li class='green'><span class='hits'>4</span><code>  return new Error("Not Implemented :  " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if there is an Expression Error.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.ExpressionError = function(message) {</code></li>
<li class='red'><span class='nohits'>0</span><code>  return new Error("Expression Error :" + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if there is a Query Error.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.QueryError = function(message) {</code></li>
<li class='green'><span class='hits'>122</span><code>  return new Error("QueryError : " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if there is a Dataset Error.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.DatasetError = function(message) {</code></li>
<li class='green'><span class='hits'>7</span><code>  return new Error("DatasetError : " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if there is a Database Error.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.DatabaseError = function(message) {</code></li>
<li class='green'><span class='hits'>5</span><code>  return new Error("Database error : " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if there is a unexpected Error.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.PatioError = function(message) {</code></li>
<li class='green'><span class='hits'>31</span><code>  return new Error("Patio error : " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if there is a error thrown within a model.</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.ModelError = function(message) {</code></li>
<li class='green'><span class='hits'>2</span><code>  return new Error("Model error : " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Thrown if there is an error when loading/creating/deleteing an association.</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.AssociationError = function(message) {</code></li>
<li class='red'><span class='nohits'>0</span><code>  return new Error("Association error : " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * Thrown if there is an error when performing a migration.</code></li>
<li class='green'><span class=''> </span><code> * @param {String} message the message to show.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>patio.MigrationError = function(message) {</code></li>
<li class='green'><span class='hits'>2</span><code>    return new Error("Migration error : " + message);</code></li>
<li class='green'><span class=''> </span><code>};</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-med" id="database/schema.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/schema.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>89.49</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>1204</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>257</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>27</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/schema.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>"use strict";</code></li>
<li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    asyncArray = comb.async.array,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isNumber = comb.isNumber,</code></li>
<li class='green'><span class=''> </span><code>    toArray = comb.array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    Dataset = require("../dataset"),</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("../errors"),</code></li>
<li class='green'><span class=''> </span><code>    DatabaseError = errors.DatabaseError,</code></li>
<li class='green'><span class=''> </span><code>    generators = require("./schemaGenerators"),</code></li>
<li class='green'><span class=''> </span><code>    SchemaGenerator = generators.SchemaGenerator,</code></li>
<li class='green'><span class=''> </span><code>    AlterTableGenerator = generators.AlterTableGenerator,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    Time = sql.Time,</code></li>
<li class='green'><span class=''> </span><code>    TimeStamp = sql.TimeStamp,</code></li>
<li class='green'><span class=''> </span><code>    DateTime = sql.DateTime,</code></li>
<li class='green'><span class=''> </span><code>    Year = sql.Year,</code></li>
<li class='green'><span class=''> </span><code>    Float = sql.Float,</code></li>
<li class='green'><span class=''> </span><code>    Decimal = sql.Decimal,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    Identifier = sql.Identifier,</code></li>
<li class='green'><span class=''> </span><code>    QualifiedIdentifier = sql.QualifiedIdentifier,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>122</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>122</span><code>            this.schemas = {};</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds a column to the specified table. This method expects a column name,</code></li>
<li class='green'><span class=''> </span><code>         * a datatype and optionally a hash with additional constraints and options:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     This method is a shortcut to {@link patio.Database#alterTable} with an</code></li>
<li class='green'><span class=''> </span><code>         *     addColumn call.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * //Outside of a table</code></li>
<li class='green'><span class=''> </span><code>         * //ALTER TABLE test ADD COLUMN name text UNIQUE'</code></li>
<li class='green'><span class=''> </span><code>         * DB.addColumn("test", "name", "text", {unique : true});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} table the table to add the column to.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} column the name of the column to add.</code></li>
<li class='green'><span class=''> </span><code>         * @param type datatype of the column</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] additional options that can be used when adding a column.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.primaryKey] set to true if this column is a primary key.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.allowNull] whether or not this column should allow null.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.unique] set to true to add a UNIQUE constraint to a column,</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved when the ADD COLUMN action is complete.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        addColumn:function (table, column, type, opts) {</code></li>
<li class='green'><span class='hits'>9</span><code>            var args = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>9</span><code>            return this.alterTable(table, function () {</code></li>
<li class='green'><span class='hits'>9</span><code>                this.addColumn.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds an index to a table for the given columns</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     This method is a shortcut to {@link patio.Database#alterTable} with an</code></li>
<li class='green'><span class=''> </span><code>         *     addIndex call.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.addIndex("test", "name", {unique : true});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; 'CREATE UNIQUE INDEX test_name_index ON test (name)'</code></li>
<li class='green'><span class=''> </span><code>         * DB.addIndex("test", ["one", "two"]);</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ''CREATE INDEX test_one_two_index ON test (one, two)''</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} table the table to add the index to.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|String[]} columns the name of the column/s to create an index for.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] additional options that can be used when adding an index.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.unique] set to true if this this index should have a UNIQUE constraint.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.ignoreErrors] set to true to ignore errors.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved when the CREATE INDEX action is complete.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        addIndex:function (table, columns, options) {</code></li>
<li class='green'><span class='hits'>4</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>4</span><code>            var ignoreErrors = options.ignoreErrors === true;</code></li>
<li class='green'><span class='hits'>4</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>4</span><code>            this.alterTable(table,function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                this.addIndex(columns, options);</code></li>
<li class='green'><span class=''> </span><code>            }).then(ret, function (err) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    if (!ignoreErrors) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret.errback(err);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret.callback();</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>4</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Removes a column from the specified table.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     This method is a shortcut to {@link patio.Database#alterTable} with an</code></li>
<li class='green'><span class=''> </span><code>         *     dropColumn call.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.dropColumn("items", "category");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; 'ALTER TABLE items DROP COLUMN category',</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} table the table to alter.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the column to drop.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the DROP COLUMN action is complete.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        dropColumn:function (table, column) {</code></li>
<li class='green'><span class='hits'>3</span><code>            column = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.alterTable(table, function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                this.dropColumn.apply(this, column);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Removes an index for the given table and column/s.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     This method is a shortcut to {@link patio.Database#alterTable} with an</code></li>
<li class='green'><span class=''> </span><code>         *     dropIndex call.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.dropIndex("posts", "title");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP INDEX posts_title_index</code></li>
<li class='green'><span class=''> </span><code>         *   DB.dropIndex("posts", ["author", "title"]);</code></li>
<li class='green'><span class=''> </span><code>         *      //'DROP INDEX posts_author_title_index'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} table the table to alter.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the name of the column/s the index was created from.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the DROP INDEX action is complete.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        dropIndex:function (table, columns, options) {</code></li>
<li class='green'><span class='hits'>1</span><code>            var args = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.alterTable(table, function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                this.dropIndex.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Renames a column in the specified table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     This method is a shortcut to {@link patio.Database#alterTable} with an</code></li>
<li class='green'><span class=''> </span><code>         *     renameColumn call.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.renameColumn("items", "cntr", "counter");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ALTER TABLE items RENAME COLUMN cntr TO counter</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} table the table to alter.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the name of the column to rename.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} newColumn the new name of the column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the RENAME COLUMN action is complete.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        renameColumn:function (table, column, newColumn) {</code></li>
<li class='green'><span class='hits'>4</span><code>            var args = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.alterTable(table, function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                this.renameColumn.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Sets the default value for the given column in the given table:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     This method is a shortcut to {@link patio.Database#alterTable} with an</code></li>
<li class='green'><span class=''> </span><code>         *     setColumnDefault call.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.setColumnDefault("items", "category", "misc");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ALTER TABLE items ALTER COLUMN category SET DEFAULT 'misc'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} table the table to alter.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the name of the column to set the DEFAULT on.</code></li>
<li class='green'><span class=''> </span><code>         * @param  def the new default value of the column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the SET DEFAULT action is complete.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        setColumnDefault:function (table, column, def) {</code></li>
<li class='green'><span class='hits'>1</span><code>            var args = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.alterTable(table, function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                this.setColumnDefault.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Set the data type for the given column in the given table:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     This method is a shortcut to {@link patio.Database#alterTable} with an</code></li>
<li class='green'><span class=''> </span><code>         *     setColumnType call.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.setColumnType("items", "category", String);</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; ALTER TABLE items ALTER COLUMN category TYPE varchar(255)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} table the table to alter.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the name of the column to set the TYPE on.</code></li>
<li class='green'><span class=''> </span><code>         * @param  type the datatype of the column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the SET TYPE action is complete.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        setColumnType:function (table, column, type) {</code></li>
<li class='green'><span class='hits'>3</span><code>            var args = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.alterTable(table, function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                this.setColumnType.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Alters the given table with the specified block.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;NOTE:&lt;/b&gt; The block is invoked in the scope of the table that is being altered. The block</code></li>
<li class='green'><span class=''> </span><code>         *      is also called with the table as the first argument. Within the block you must use</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;this&lt;/b&gt;(If the block has not been bound to a different scope), or the table object</code></li>
<li class='green'><span class=''> </span><code>         *      that is passed in for all alter table operations. See {@link patio.AlterTableGenerator} for</code></li>
<li class='green'><span class=''> </span><code>         *      avaiable operations.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;Note&lt;/b&gt; that addColumn accepts all the options available for column</code></li>
<li class='green'><span class=''> </span><code>         *      definitions using createTable, and addIndex accepts all the options</code></li>
<li class='green'><span class=''> </span><code>         *      available for index definition.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   //using the table object</code></li>
<li class='green'><span class=''> </span><code>         *   DB.alterTable("items", function(table){</code></li>
<li class='green'><span class=''> </span><code>         *      //you must use the passed in table object.</code></li>
<li class='green'><span class=''> </span><code>         *     table.addColumn("category", "text", {default : 'javascript'});</code></li>
<li class='green'><span class=''> </span><code>         *     table.dropColumn("category");</code></li>
<li class='green'><span class=''> </span><code>         *     table.renameColumn("cntr", "counter");</code></li>
<li class='green'><span class=''> </span><code>         *     table.setColumnType("value", "float");</code></li>
<li class='green'><span class=''> </span><code>         *     table.setColumnDefault("value", "float");</code></li>
<li class='green'><span class=''> </span><code>         *     table.addIndex(["group", "category"]);</code></li>
<li class='green'><span class=''> </span><code>         *     table.dropIndex [:group, :category]</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   //using this</code></li>
<li class='green'><span class=''> </span><code>         *    DB.alterTable("items", function(){</code></li>
<li class='green'><span class=''> </span><code>         *     this.addColumn("category", "text", {default : 'javascript'});</code></li>
<li class='green'><span class=''> </span><code>         *     this.dropColumn("category");</code></li>
<li class='green'><span class=''> </span><code>         *     this.renameColumn("cntr", "counter");</code></li>
<li class='green'><span class=''> </span><code>         *     this.setColumnType("value", "float");</code></li>
<li class='green'><span class=''> </span><code>         *     this.setColumnDefault("value", "float");</code></li>
<li class='green'><span class=''> </span><code>         *     this.addIndex(["group", "category"]);</code></li>
<li class='green'><span class=''> </span><code>         *     this.dropIndex [:group, :category]</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   //This will not work</code></li>
<li class='green'><span class=''> </span><code>         *   DB.alterTable("items", comb.hitch(someObject, function(){</code></li>
<li class='green'><span class=''> </span><code>         *    //This is called in the scope of someObject so this</code></li>
<li class='green'><span class=''> </span><code>         *    //will not work and will throw an error</code></li>
<li class='green'><span class=''> </span><code>         *     this.addColumn("category", "text", {default : 'javascript'});</code></li>
<li class='green'><span class=''> </span><code>         *   }));</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *    //This will work</code></li>
<li class='green'><span class=''> </span><code>         *   DB.alterTable("items", comb.hitch(someObject, function(table){</code></li>
<li class='green'><span class=''> </span><code>         *    //This is called in the scope of someObject so you must</code></li>
<li class='green'><span class=''> </span><code>         *    //use the table argument</code></li>
<li class='green'><span class=''> </span><code>         *     table.category("text", {default : 'javascript'});</code></li>
<li class='green'><span class=''> </span><code>         *   }));</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} table to the table to perform the ALTER TABLE operations on.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} block the block to invoke for the ALTER TABLE operations</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once all ALTER TABLE operations have completed.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        alterTable:function (name, generator, block) {</code></li>
<li class='green'><span class='hits'>80</span><code>            if (isFunction(generator)) {</code></li>
<li class='green'><span class='hits'>80</span><code>                block = generator;</code></li>
<li class='green'><span class='hits'>80</span><code>                generator = new AlterTableGenerator(this, block);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>80</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>80</span><code>            return this.__alterTableSqlList(name, generator.operations).chain(function (res) {</code></li>
<li class='green'><span class='hits'>80</span><code>                return asyncArray(comb(res).pluck("1").flatten()).forEach(function (sql) {</code></li>
<li class='green'><span class='hits'>91</span><code>                    return this.executeDdl(sql);</code></li>
<li class='green'><span class=''> </span><code>                }, this).chain(comb("removeCachedSchema").bindIgnore(this, name));</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a table with the columns given in the provided block:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;NOTE:&lt;/b&gt; The block is invoked in the scope of the table that is being created. The block</code></li>
<li class='green'><span class=''> </span><code>         *      is also called with the table as the first argument. Within the block you must use</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;this&lt;/b&gt;(If the block has not been bound to a different scope), or the table object</code></li>
<li class='green'><span class=''> </span><code>         *      that is passed in for all create table operations. See {@link patio.SchemaGenerator} for</code></li>
<li class='green'><span class=''> </span><code>         *      available operations.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   //using the table to create the table</code></li>
<li class='green'><span class=''> </span><code>         *   DB.createTable("posts", function(table){</code></li>
<li class='green'><span class=''> </span><code>         *     table.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *     table.column('title", "text");</code></li>
<li class='green'><span class=''> </span><code>         *     //you may also invoke the column name as</code></li>
<li class='green'><span class=''> </span><code>         *     //function on the table</code></li>
<li class='green'><span class=''> </span><code>         *     table.content(String);</code></li>
<li class='green'><span class=''> </span><code>         *     table.index(title);</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   //using this to create the table</code></li>
<li class='green'><span class=''> </span><code>         *   DB.createTable("posts", function(){</code></li>
<li class='green'><span class=''> </span><code>         *     this.primaryKey("id");</code></li>
<li class='green'><span class=''> </span><code>         *     this.column('title", "text");</code></li>
<li class='green'><span class=''> </span><code>         *     //you may also invoke the column name as</code></li>
<li class='green'><span class=''> </span><code>         *     //function on the table</code></li>
<li class='green'><span class=''> </span><code>         *     this.content(String);</code></li>
<li class='green'><span class=''> </span><code>         *     this.index(title);</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the table to create.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] an optional options object</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.temp] set to true if this table is a TEMPORARY table.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.ignoreIndexErrors] Ignore any errors when creating indexes.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} block the block to invoke when creating the table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved when the CREATE TABLE action is completed.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        createTable:function (name, options, block) {</code></li>
<li class='green'><span class='hits'>218</span><code>            if (isFunction(options)) {</code></li>
<li class='green'><span class='hits'>208</span><code>                block = options;</code></li>
<li class='green'><span class='hits'>208</span><code>                options = {};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>218</span><code>            this.removeCachedSchema(name);</code></li>
<li class='green'><span class='hits'>218</span><code>            if (isInstanceOf(options, SchemaGenerator)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                options = {generator:options};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>218</span><code>            var generator = options.generator || new SchemaGenerator(this, block);</code></li>
<li class='green'><span class='hits'>218</span><code>            return this.__createTableFromGenerator(name, generator, options)</code></li>
<li class='green'><span class=''> </span><code>                .chain(comb("__createTableIndexesFromGenerator").bindIgnore(this, name, generator, options));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Forcibly creates a table, attempting to drop it unconditionally (and catching any errors), then creating it.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      See {@link patio.Database#createTable} for parameter types.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // DROP TABLE a</code></li>
<li class='green'><span class=''> </span><code>         *  // CREATE TABLE a (a integer)</code></li>
<li class='green'><span class=''> </span><code>         *   DB.forceCreateTable("a", function(){</code></li>
<li class='green'><span class=''> </span><code>         *      this.a("integer");</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        forceCreateTable:function (name, options, block) {</code></li>
<li class='green'><span class='hits'>18</span><code>            return this.dropTable(name).chainBoth(comb("createTable").bindIgnore(this, name, options, block));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates the table unless the table already exists.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      See {@link patio.Database#createTable} for parameter types.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        createTableUnlessExists:function (name, options, block) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ret = new Promise();</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.tableExists(name).chain(function (exists) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (!exists) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this.createTable(name, options, block);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a view, replacing it if it already exists:</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.createOrReplaceView("cheapItems", "SELECT * FROM items WHERE price &lt; 100");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; CREATE OR REPLACE VIEW cheapItems AS SELECT * FROM items WHERE price &lt; 100</code></li>
<li class='green'><span class=''> </span><code>         *   DB.createOrReplaceView("miscItems", DB[:items].filter({category : 'misc'}));</code></li>
<li class='green'><span class=''> </span><code>         *     //=&gt; CREATE OR REPLACE VIEW miscItems AS SELECT * FROM items WHERE category = 'misc'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the view to create.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.Dataset} source the SQL or {@link patio.Dataset} to use as the source of the</code></li>
<li class='green'><span class=''> </span><code>         * view.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved when the CREATE OR REPLACE VIEW action is complete.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        createOrReplaceView:function (name, source) {</code></li>
<li class='green'><span class='hits'>4</span><code>            if (isInstanceOf(source, Dataset)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                source = source.sql;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.executeDdl(format("CREATE OR REPLACE VIEW %s AS %s", this.__quoteSchemaTable(name), source)).chain(function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                this.removeCachedSchema(name);</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a view based on a dataset or an SQL string:</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.createView("cheapItems", "SELECT * FROM items WHERE price &lt; 100");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; CREATE VIEW cheapItems AS SELECT * FROM items WHERE price &lt; 100</code></li>
<li class='green'><span class=''> </span><code>         *   DB.createView("miscItems", DB[:items].filter({category : 'misc'}));</code></li>
<li class='green'><span class=''> </span><code>         *     //=&gt; CREATE  VIEW miscItems AS SELECT * FROM items WHERE category = 'misc'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the view to create.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.Dataset} source the SQL or {@link patio.Dataset} to use as the source of the</code></li>
<li class='green'><span class=''> </span><code>         * view.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        createView:function (name, source) {</code></li>
<li class='green'><span class='hits'>4</span><code>            if (isInstanceOf(source, Dataset)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                source = source.sql;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.executeDdl(format("CREATE VIEW %s AS %s", this.__quoteSchemaTable(name), source));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Drops one or more tables corresponding to the given names.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.dropTable("test");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE test'</code></li>
<li class='green'><span class=''> </span><code>         * DB.dropTable("a", "bb", "ccc");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE a',</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE bb',</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE ccc'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|String[]|patio.sql.Identifier|patio.sql.Identifier[]} names the names of the tables</code></li>
<li class='green'><span class=''> </span><code>         * to drop.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once all tables have been dropped.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        dropTable:function (names) {</code></li>
<li class='green'><span class='hits'>48</span><code>            if (!isArray(names)) {</code></li>
<li class='green'><span class='hits'>33</span><code>                names = comb(arguments).toArray();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>48</span><code>            return serial(names.filter(function (t) {</code></li>
<li class='green'><span class='hits'>67</span><code>                return isString(t) || isInstanceOf(t, Identifier, QualifiedIdentifier);</code></li>
<li class='green'><span class=''> </span><code>            }).map(function (name) {</code></li>
<li class='green'><span class='hits'>65</span><code>                return function () {</code></li>
<li class='green'><span class='hits'>65</span><code>                    return this.executeDdl(this.__dropTableSql(name)).chain(function () {</code></li>
<li class='green'><span class='hits'>55</span><code>                        return this.removeCachedSchema(name);</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>                }.bind(this);</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Forcible drops one or more tables corresponding to the given names, ignoring errors.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.dropTable("test");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE test'</code></li>
<li class='green'><span class=''> </span><code>         * DB.dropTable("a", "bb", "ccc");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE a',</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE bb',</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP TABLE ccc'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|String[]|patio.sql.Identifier|patio.sql.Identifier[]} names the names of the tables</code></li>
<li class='green'><span class=''> </span><code>         * to drop.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once all tables have been dropped.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        forceDropTable:function (names) {</code></li>
<li class='green'><span class='hits'>97</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>97</span><code>            if (!isArray(names)) {</code></li>
<li class='green'><span class='hits'>63</span><code>                names = comb(arguments).toArray();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>97</span><code>            names = names.filter(function (t) {</code></li>
<li class='green'><span class='hits'>146</span><code>                return isString(t) || isInstanceOf(t, Identifier, QualifiedIdentifier);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>97</span><code>            var l = names.length;</code></li>
<li class='green'><span class='hits'>97</span><code>            var drop = function (i) {</code></li>
<li class='green'><span class='hits'>243</span><code>                if (i &lt; l) {</code></li>
<li class='green'><span class='hits'>146</span><code>                    var name = names[i++];</code></li>
<li class='green'><span class='hits'>146</span><code>                    this.executeDdl(this.__dropTableSql(name)).both(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>146</span><code>                        this.removeCachedSchema(name);</code></li>
<li class='green'><span class='hits'>146</span><code>                        drop(i);</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>97</span><code>                    ret.callback();</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this);</code></li>
<li class='green'><span class='hits'>97</span><code>            drop(0);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>97</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Drops one or more views corresponding to the given names.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.dropView("test_view");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP VIEW test_view'</code></li>
<li class='green'><span class=''> </span><code>         * DB.dropTable("test_view_1", "test_view_2", "test_view_3");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP VIEW test_view_1',</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP VIEW test_view_2',</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'DROP VIEW test_view_3'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|String[]|patio.sql.Identifier|patio.sql.Identifier[]} names the names of the views</code></li>
<li class='green'><span class=''> </span><code>         * to drop.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the view/s have been dropped.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        dropView:function (names) {</code></li>
<li class='green'><span class='hits'>8</span><code>            var ret = new Promise(), l = names.length;</code></li>
<li class='green'><span class='hits'>8</span><code>            if (isArray(names)) {</code></li>
<li class='green'><span class='hits'>4</span><code>                var drop = hitch(this, function (i) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    if (i &lt; l) {</code></li>
<li class='green'><span class='hits'>4</span><code>                        var name = names[i++];</code></li>
<li class='green'><span class='hits'>4</span><code>                        this.executeDdl(format("DROP VIEW %s", this.__quoteSchemaTable(name))).then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                            this.removeCachedSchema(name);</code></li>
<li class='green'><span class='hits'>4</span><code>                            drop(i);</code></li>
<li class='green'><span class=''> </span><code>                        }), ret);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>4</span><code>                        ret.callback();</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>4</span><code>                drop(0);</code></li>
<li class='green'><span class='hits'>4</span><code>                return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this.dropView(argsToArray(arguments).filter(function (t) {</code></li>
<li class='green'><span class='hits'>4</span><code>                    return isString(t) || isInstanceOf(t, Identifier, QualifiedIdentifier);</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Renames a table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * comb.executeInOrder(DB, function(DB){</code></li>
<li class='green'><span class=''> </span><code>         *   DB.tables(); //=&gt; ["items"]</code></li>
<li class='green'><span class=''> </span><code>         *   DB.renameTable("items", "old_items");</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;'ALTER TABLE items RENAME TO old_items'</code></li>
<li class='green'><span class=''> </span><code>         *   DB.tables; //=&gt; ["old_items"]</code></li>
<li class='green'><span class=''> </span><code>         *});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} name the name of the table to rename</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} newName the new name of the table</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the table is renamed.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        renameTable:function (name, newName) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.executeDdl(this.__renameTableSql(name, newName)).chain(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                this.removeCachedSchema(name);</code></li>
<li class='green'><span class=''> </span><code>            })).promise();</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *  The SQL to execute to modify the DDL for the given table name.  op</code></li>
<li class='green'><span class=''> </span><code>         * should be one of the operations returned by the AlterTableGenerator.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __alterTableSql:function (table, op) {</code></li>
<li class='green'><span class='hits'>79</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>79</span><code>            var quotedName = op.name ? this.__quoteIdentifier(op.name) : null;</code></li>
<li class='green'><span class='hits'>79</span><code>            var alterTableOp = null;</code></li>
<li class='green'><span class='hits'>79</span><code>            switch (op.op) {</code></li>
<li class='green'><span class=''> </span><code>                case "addColumn":</code></li>
<li class='green'><span class='hits'>13</span><code>                    alterTableOp = format("ADD COLUMN %s", this.__columnDefinitionSql(op));</code></li>
<li class='green'><span class='hits'>13</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "dropColumn":</code></li>
<li class='green'><span class='hits'>4</span><code>                    alterTableOp = format("DROP COLUMN %s", quotedName);</code></li>
<li class='green'><span class='hits'>4</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "renameColumn":</code></li>
<li class='green'><span class='hits'>48</span><code>                    alterTableOp = format("RENAME COLUMN %s TO %s", quotedName, this.__quoteIdentifier(op.newName));</code></li>
<li class='green'><span class='hits'>48</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "setColumnType":</code></li>
<li class='green'><span class='hits'>3</span><code>                    alterTableOp = format("ALTER COLUMN %s TYPE %s", quotedName, this.typeLiteral(op));</code></li>
<li class='green'><span class='hits'>3</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "setColumnDefault":</code></li>
<li class='green'><span class='hits'>2</span><code>                    alterTableOp = format("ALTER COLUMN %s SET DEFAULT %s", quotedName, this.literal(op["default"]));</code></li>
<li class='green'><span class='hits'>2</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "setColumnNull":</code></li>
<li class='red'><span class='nohits'>0</span><code>                    alterTableOp = format("ALTER COLUMN %s %s NOT NULL", quotedName, op["null"] ? "DROP" : "SET");</code></li>
<li class='red'><span class='nohits'>0</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "addIndex":</code></li>
<li class='green'><span class='hits'>5</span><code>                    return ret.callback(this.__indexDefinitionSql(table, op)).promise();</code></li>
<li class='green'><span class=''> </span><code>                case "dropIndex":</code></li>
<li class='green'><span class='hits'>2</span><code>                    return ret.callback(this.__dropIndexSql(table, op)).promise();</code></li>
<li class='green'><span class=''> </span><code>                case "addConstraint":</code></li>
<li class='green'><span class='hits'>1</span><code>                    alterTableOp = format("ADD %s", this.__constraintDefinitionSql(op));</code></li>
<li class='green'><span class='hits'>1</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "dropConstraint":</code></li>
<li class='red'><span class='nohits'>0</span><code>                    alterTableOp = format("DROP CONSTRAINT %s", quotedName);</code></li>
<li class='red'><span class='nohits'>0</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                default :</code></li>
<li class='green'><span class='hits'>1</span><code>                    throw new DatabaseError("Invalid altertable operator");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>71</span><code>            return ret.callback(format("ALTER TABLE %s %s", this.__quoteSchemaTable(table), alterTableOp)).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Array of SQL DDL modification statements for the given table,</code></li>
<li class='green'><span class=''> </span><code>         * corresponding to the DDL changes specified by the operations.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __alterTableSqlList:function (table, operations) {</code></li>
<li class='green'><span class='hits'>80</span><code>            return new PromiseList(operations.map(hitch(this, "__alterTableSql", table)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL fragment containing the column creation SQL for the given column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param column</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __columnDefinitionSql:function (column) {</code></li>
<li class='green'><span class='hits'>643</span><code>            var sql = [format("%s %s", this.__quoteIdentifier(column.name), this.typeLiteral(column))];</code></li>
<li class='green'><span class='hits'>643</span><code>            column.unique &amp;&amp; sql.push(this._static.UNIQUE);</code></li>
<li class='green'><span class='hits'>643</span><code>            (column.allowNull === false || column["null"] === false) &amp;&amp; sql.push(this._static.NOT_NULL);</code></li>
<li class='green'><span class='hits'>643</span><code>            (column.allowNull === true || column["null"] === true) &amp;&amp; sql.push(this._static.NULL);</code></li>
<li class='green'><span class='hits'>643</span><code>            !isUndefined(column["default"]) &amp;&amp; sql.push(format(" DEFAULT %s", this.literal(column["default"])));</code></li>
<li class='green'><span class='hits'>643</span><code>            column.primaryKey &amp;&amp; sql.push(this._static.PRIMARY_KEY);</code></li>
<li class='green'><span class='hits'>643</span><code>            column.autoIncrement &amp;&amp; sql.push(" " + this.autoIncrementSql);</code></li>
<li class='green'><span class='hits'>643</span><code>            column.table &amp;&amp; sql.push(this.__columnReferencesColumnConstraintSql(column));</code></li>
<li class='green'><span class='hits'>643</span><code>            return sql.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL fragment containing the column creation</code></li>
<li class='green'><span class=''> </span><code>         * SQL for all given columns, used inside a CREATE TABLE block.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __columnListSql:function (generator) {</code></li>
<li class='green'><span class='hits'>218</span><code>            return generator.columns.map(hitch(this, "__columnDefinitionSql")).concat(generator.constraints.map(hitch(this, "__constraintDefinitionSql"))).join(this._static.COMMA_SEPARATOR);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *SQL DDL fragment for column foreign key references (column constraints)</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __columnReferencesColumnConstraintSql:function (column) {</code></li>
<li class='green'><span class='hits'>30</span><code>            return this.__columnReferencesSql(column);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL fragment for column foreign key references</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __columnReferencesSql:function (column) {</code></li>
<li class='green'><span class='hits'>38</span><code>            var sql = format(" REFERENCES %s", this.__quoteSchemaTable(column.table));</code></li>
<li class='green'><span class='hits'>38</span><code>            column.key &amp;&amp; (sql += format("(%s)", array.toArray(column.key).map(this.__quoteIdentifier, this).join(this._static.COMMA_SEPARATOR)));</code></li>
<li class='green'><span class='hits'>38</span><code>            column.onDelete &amp;&amp; (sql += format(" ON DELETE %s", this.__onDeleteClause(column.onDelete)));</code></li>
<li class='green'><span class='hits'>38</span><code>            column.onUpdate &amp;&amp; (sql += format(" ON UPDATE %s", this.__onUpdateClause(column.onUpdate)));</code></li>
<li class='green'><span class='hits'>38</span><code>            column.deferrable &amp;&amp; (sql += " DEFERRABLE INITIALLY DEFERRED");</code></li>
<li class='green'><span class='hits'>38</span><code>            return sql;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL fragment for table foreign key references (table constraints)</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __columnReferencesTableConstraintSql:function (constraint) {</code></li>
<li class='green'><span class='hits'>6</span><code>            return format("FOREIGN KEY %s%s", this.literal(constraint.columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>6</span><code>                return isString(c) ? sql.stringToIdentifier(c) : c;</code></li>
<li class='green'><span class=''> </span><code>            })), this.__columnReferencesSql(constraint));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL fragment specifying a constraint on a table.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __constraintDefinitionSql:function (constraint) {</code></li>
<li class='green'><span class='hits'>6</span><code>            var ret = [constraint.name ? format("CONSTRAINT %s ", this.__quoteIdentifier(constraint.name)) : ""];</code></li>
<li class='green'><span class='hits'>6</span><code>            switch (constraint.type) {</code></li>
<li class='green'><span class=''> </span><code>                case "check":</code></li>
<li class='red'><span class='nohits'>0</span><code>                    var check = constraint.check;</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret.push(format("CHECK %s", this.__filterExpr(isArray(check) &amp;&amp; check.length === 1 ? check[0] : check)));</code></li>
<li class='red'><span class='nohits'>0</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "primaryKey":</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret.push(format("PRIMARY KEY %s", this.literal(constraint.columns.map(function (c) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return isString(c) ? sql.stringToIdentifier(c) : c;</code></li>
<li class='green'><span class=''> </span><code>                    }))));</code></li>
<li class='red'><span class='nohits'>0</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "foreignKey":</code></li>
<li class='green'><span class='hits'>6</span><code>                    ret.push(this.__columnReferencesTableConstraintSql(constraint));</code></li>
<li class='green'><span class='hits'>6</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case "unique":</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret.push(format("UNIQUE %s", this.literal(constraint.columns.map(function (c) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return isString(c) ? sql.stringToIdentifier(c) : c;</code></li>
<li class='green'><span class=''> </span><code>                    }))));</code></li>
<li class='red'><span class='nohits'>0</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                default:</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new DatabaseError(format("Invalid constriant type %s, should be 'check', 'primaryKey', foreignKey', or 'unique'", constraint.type));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>6</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Execute the create table statements using the generator.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __createTableFromGenerator:function (name, generator, options) {</code></li>
<li class='green'><span class='hits'>218</span><code>            return this.executeDdl(this.__createTableSql(name, generator, options));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Execute the create index statements using the generator.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __createTableIndexesFromGenerator:function (name, generator, options) {</code></li>
<li class='green'><span class='hits'>218</span><code>            var e = options.ignoreIndexErrors;</code></li>
<li class='green'><span class='hits'>218</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>218</span><code>            var promises = generator.indexes.map(function (index) {</code></li>
<li class='green'><span class='hits'>17</span><code>                var ps = this.__indexSqlList(name, [index]).map(this.executeDdl, this);</code></li>
<li class='green'><span class='hits'>17</span><code>                return new PromiseList(ps);</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>218</span><code>            if (promises.length) {</code></li>
<li class='green'><span class='hits'>15</span><code>                new PromiseList(promises).then(ret, hitch(ret, e ? "callback" : "errback"));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>203</span><code>                ret.callback();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>218</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * DDL statement for creating a table with the given name, columns, and options</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __createTableSql:function (name, generator, options) {</code></li>
<li class='green'><span class='hits'>218</span><code>            return format("CREATE %sTABLE %s (%s)", options.temp ? this.temporaryTableSql : "", this.__quoteSchemaTable(name), this.__columnListSql(generator));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Default index name for the table and columns, may be too long</code></li>
<li class='green'><span class=''> </span><code>         * for certain databases.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __defaultIndexName:function (tableName, columns) {</code></li>
<li class='green'><span class='hits'>24</span><code>            var parts = this.__schemaAndTable(tableName);</code></li>
<li class='green'><span class='hits'>24</span><code>            var schema = parts[0], table = parts[1];</code></li>
<li class='green'><span class='hits'>24</span><code>            var index = [];</code></li>
<li class='green'><span class='hits'>24</span><code>            if (schema &amp;&amp; schema !== this.defaultSchema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                index.push(schema);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>24</span><code>            index.push(table);</code></li>
<li class='green'><span class='hits'>24</span><code>            index = index.concat(columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>27</span><code>                return isString(c) ? c : this.literal(c).replace(/\W/g, "");</code></li>
<li class='green'><span class=''> </span><code>            }, this));</code></li>
<li class='green'><span class='hits'>24</span><code>            index.push("index");</code></li>
<li class='green'><span class='hits'>24</span><code>            return index.join(this._static.UNDERSCORE);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * The SQL to drop an index for the table.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __dropIndexSql:function (table, op) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return format("DROP INDEX %s", this.__quoteIdentifier(op.name || this.__defaultIndexName(table, op.columns)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  SQL DDL statement to drop the table with the given name.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        __dropTableSql:function (name) {</code></li>
<li class='green'><span class='hits'>211</span><code>            return format("DROP TABLE %s", this.__quoteSchemaTable(name));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Proxy the filterExpr call to the dataset, used for creating constraints.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __filterExpr:function (args, block) {</code></li>
<li class='green'><span class='hits'>2</span><code>            var ds = this.__schemaUtiltyDataset;</code></li>
<li class='green'><span class='hits'>2</span><code>            return ds.literal(ds._filterExpr.apply(ds, arguments));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL statement for creating an index for the table with the given name</code></li>
<li class='green'><span class=''> </span><code>         * and index specifications.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __indexDefinitionSql:function (tableName, index) {</code></li>
<li class='green'><span class='hits'>6</span><code>            var indexName = index.name || this.__defaultIndexName(tableName, index.columns);</code></li>
<li class='green'><span class='hits'>6</span><code>            if (index.type) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new DatabaseError("Index types are not supported for this database");</code></li>
<li class='green'><span class='hits'>6</span><code>            } else if (index.where) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new DatabaseError("Partial indexes are not supported for this database");</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>6</span><code>                return format("CREATE %sINDEX %s ON %s %s", index.unique ? "UNIQUE " : "", this.__quoteIdentifier(indexName), this.__quoteSchemaTable(tableName), this.literal(index.columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>7</span><code>                    return isString(c) ? new Identifier(c) : c;</code></li>
<li class='green'><span class=''> </span><code>                })));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Array of SQL DDL statements, one for each index specification,</code></li>
<li class='green'><span class=''> </span><code>         * for the given table.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __indexSqlList:function (tableName, indexes) {</code></li>
<li class='green'><span class='hits'>17</span><code>            return indexes.map(hitch(this, this.__indexDefinitionSql, tableName));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL ON DELETE fragment to use, based on the given action.</code></li>
<li class='green'><span class=''> </span><code>         *The following actions are recognized:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;cascade - Delete rows referencing this row.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;noAction (default) - Raise an error if other rows reference this</code></li>
<li class='green'><span class=''> </span><code>         *   row, allow deferring of the integrity check.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;restrict - Raise an error if other rows reference this row,</code></li>
<li class='green'><span class=''> </span><code>         *   but do not allow deferring the integrity check.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt; setDefault - Set columns referencing this row to their default value.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;setNull - Set columns referencing this row to NULL.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __onDeleteClause:function (action) {</code></li>
<li class='green'><span class='hits'>23</span><code>            return this._static[action.toUpperCase()] || this._static.NO_ACTION;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL ON UPDATE fragment to use, based on the given action.</code></li>
<li class='green'><span class=''> </span><code>         *The following actions are recognized:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;cascade - Delete rows referencing this row.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;noAction (default) - Raise an error if other rows reference this</code></li>
<li class='green'><span class=''> </span><code>         *   row, allow deferring of the integrity check.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;restrict - Raise an error if other rows reference this row,</code></li>
<li class='green'><span class=''> </span><code>         *   but do not allow deferring the integrity check.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt; setDefault - Set columns referencing this row to their default value.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;setNull - Set columns referencing this row to NULL.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __onUpdateClause:function (action) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this._static[action.toUpperCase()] || this._static.NO_ACTION;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Proxy the quoteSchemaTable method to the dataset</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __quoteSchemaTable:function (table) {</code></li>
<li class='green'><span class='hits'>2219</span><code>            return this.__schemaUtiltyDataset.quoteSchemaTable(table);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Proxy the quoteIdentifier method to the dataset, used for quoting tables and columns.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __quoteIdentifier:function (v) {</code></li>
<li class='green'><span class='hits'>836</span><code>            return this.__schemaUtiltyDataset.quoteIdentifier(v);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL DDL statement for renaming a table.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __renameTableSql:function (name, newName) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return format("ALTER TABLE %s RENAME TO %s", this.__quoteSchemaTable(name), this.__quoteSchemaTable(newName));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Remove the cached schemaUtilityDataset, because the identifier</code></li>
<li class='green'><span class=''> </span><code>         * quoting has changed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __resetSchemaUtilityDataset:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.__schemaUtiltyDs = null;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Split the schema information from the table</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __schemaAndTable:function (tableName) {</code></li>
<li class='green'><span class='hits'>210</span><code>            return  this.__schemaUtiltyDataset.schemaAndTable(tableName);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Return true if the given column schema represents an autoincrementing primary key.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _schemaAutoincrementingPrimaryKey:function (schema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return !!schema.primaryKey;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment specifying the type of a given column.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        typeLiteral:function (column) {</code></li>
<li class='green'><span class='hits'>689</span><code>            return this.__typeLiteralGeneric(column);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment specifying the full type of a column,</code></li>
<li class='green'><span class=''> </span><code>         * consider the type with possible modifiers.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGeneric:function (column) {</code></li>
<li class='green'><span class='hits'>689</span><code>            var type = column.type;</code></li>
<li class='green'><span class='hits'>689</span><code>            var meth = "__typeLiteralGeneric";</code></li>
<li class='green'><span class='hits'>689</span><code>            var isStr = isString(type);</code></li>
<li class='green'><span class='hits'>689</span><code>            var proper = isStr ? type.charAt(0).toUpperCase() + type.substr(1) : null;</code></li>
<li class='green'><span class='hits'>689</span><code>            if (type === String || (isStr &amp;&amp; type.match(/string/i))) {</code></li>
<li class='green'><span class='hits'>198</span><code>                meth += "String";</code></li>
<li class='green'><span class='hits'>491</span><code>            } else if ((isStr &amp;&amp; type.match(/number/i)) || type === Number) {</code></li>
<li class='green'><span class='hits'>12</span><code>                meth += "Numeric";</code></li>
<li class='green'><span class='hits'>479</span><code>            } else if ((isStr &amp;&amp; type.match(/datetime/i)) || type === DateTime) {</code></li>
<li class='green'><span class='hits'>8</span><code>                meth += "DateTime";</code></li>
<li class='green'><span class='hits'>471</span><code>            } else if ((isStr &amp;&amp; type.match(/date/i)) || type === Date) {</code></li>
<li class='green'><span class='hits'>11</span><code>                meth += "Date";</code></li>
<li class='green'><span class='hits'>460</span><code>            } else if ((isStr &amp;&amp; type.match(/year/i)) || type === Year) {</code></li>
<li class='green'><span class='hits'>2</span><code>                meth += "Year";</code></li>
<li class='green'><span class='hits'>458</span><code>            } else if ((isStr &amp;&amp; type.match(/timestamp/i)) || type === TimeStamp) {</code></li>
<li class='green'><span class='hits'>4</span><code>                meth += "Timestamp";</code></li>
<li class='green'><span class='hits'>454</span><code>            } else if ((isStr &amp;&amp; type.match(/time/i)) || type === Time) {</code></li>
<li class='green'><span class='hits'>2</span><code>                meth += "Time";</code></li>
<li class='green'><span class='hits'>452</span><code>            } else if ((isStr &amp;&amp; type.match(/decimal/i)) || type === Decimal) {</code></li>
<li class='green'><span class='hits'>2</span><code>                meth += "Decimal";</code></li>
<li class='green'><span class='hits'>450</span><code>            } else if ((isStr &amp;&amp; type.match(/float/i)) || type === Float) {</code></li>
<li class='green'><span class='hits'>15</span><code>                meth += "Float";</code></li>
<li class='green'><span class='hits'>435</span><code>            } else if ((isStr &amp;&amp; type.match(/boolean/i)) || type === Boolean) {</code></li>
<li class='green'><span class='hits'>5</span><code>                meth += "Boolean";</code></li>
<li class='green'><span class='hits'>430</span><code>            } else if ((isStr &amp;&amp; type.match(/buffer/i)) || type === Buffer) {</code></li>
<li class='green'><span class='hits'>29</span><code>                meth += "Blob";</code></li>
<li class='green'><span class='hits'>401</span><code>            } else if (isStr &amp;&amp; isFunction(this[meth + proper])) {</code></li>
<li class='green'><span class='hits'>138</span><code>                meth += proper;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>263</span><code>                return this.__typeLiteralSpecific(column);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>426</span><code>            return this[meth](column);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * patio uses the date type by default for Dates.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;if onlyTime is present then time is used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;if timeStamp is present then timestamp is used,&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;if dateTime is present then datetime is used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;if yearOnly is present then year is used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;li&gt;else date is used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericDate:function (column) {</code></li>
<li class='green'><span class='hits'>11</span><code>            var type = column.type, ret = "date";</code></li>
<li class='green'><span class='hits'>11</span><code>            if (column.onlyTime) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = "time";</code></li>
<li class='green'><span class='hits'>9</span><code>            } else if (column.timeStamp) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = "timestamp";</code></li>
<li class='green'><span class='hits'>7</span><code>            } else if (column.dateTime) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = "datetime";</code></li>
<li class='green'><span class='hits'>5</span><code>            } else if (column.yearOnly) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = "year";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>11</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * * patio uses the blob type by default for Buffers.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericBlob:function (column) {</code></li>
<li class='green'><span class='hits'>25</span><code>            return "blob";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * * patio uses the year type by default for {@link patio.sql.DateTime}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericDateTime:function (column) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return "datetime";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * patio uses the timestamp type by default for {@link patio.sql.TimeStamp}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericTimestamp:function (column) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return "timestamp";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * patio uses the time type by default for {@link patio.sql.Time}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericTime:function (column) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return "time";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * patio uses the year type by default for {@link patio.sql.Year}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericYear:function (column) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return "year";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * patio uses the boolean type by default for Boolean class</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericBoolean:function (column) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return "boolean";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * patio uses the numeric type by default for NumericTypes</code></li>
<li class='green'><span class=''> </span><code>         * If a size is given, it is used, otherwise, it will default to whatever</code></li>
<li class='green'><span class=''> </span><code>         * the database default is for an unsized value.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;li&gt; if isInt is present the int is used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;li&gt; if isDouble is present then double precision is used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericNumeric:function (column) {</code></li>
<li class='green'><span class='hits'>10</span><code>            return column.size ? format("numeric(%s)", array.toArray(column.size).join(', ')) : column.isInt ? "integer" : column.isDouble ? "double precision" : "numeric";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericFloat:function (column) {</code></li>
<li class='green'><span class='hits'>15</span><code>            return "double precision";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericDecimal:function (column) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return "double precision";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * patio uses the varchar type by default for Strings.  If a</code></li>
<li class='green'><span class=''> </span><code>         * size isn't present, patio assumes a size of 255.  If the</code></li>
<li class='green'><span class=''> </span><code>         * fixed option is used, patio uses the char type.  If the</code></li>
<li class='green'><span class=''> </span><code>         * text option is used, patio uses the :text type.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralGenericString:function (column) {</code></li>
<li class='green'><span class='hits'>41</span><code>            return column.text ? "text" : format("%s(%s)", column.fixed ? "char" : "varchar", column.size || 255);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for the given type of a column if the column is not one of the</code></li>
<li class='green'><span class=''> </span><code>         * generic types specified with a native javascript type class.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __typeLiteralSpecific:function (column) {</code></li>
<li class='green'><span class='hits'>335</span><code>            var type = column.type;</code></li>
<li class='green'><span class='hits'>335</span><code>            type = type === "double" ? "double precision" : type;</code></li>
<li class='green'><span class='hits'>335</span><code>            if (type === "varchar") {</code></li>
<li class='green'><span class='hits'>7</span><code>                column.size = isNumber(column.size) ? column.size : 255;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>335</span><code>            var elements = column.size || column.elements;</code></li>
<li class='green'><span class='hits'>335</span><code>            return format("%s%s%s", type, elements ? this.literal(toArray(elements)) : "", column.unsigned ? " UNSIGNED" : "");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @private</code></li>
<li class='green'><span class=''> </span><code>             *  The SQL string specify the autoincrement property, generally used by</code></li>
<li class='green'><span class=''> </span><code>             * primary keys.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            autoIncrementSql:function () {</code></li>
<li class='green'><span class='hits'>9</span><code>                return this._static.AUTOINCREMENT;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @private</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            temporaryTableSql:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                return this._static.TEMPORARY;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @private</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            __schemaUtiltyDataset:function () {</code></li>
<li class='green'><span class='hits'>3267</span><code>                this.__schemaUtiltyDs = this.__schemaUtiltyDs || this.dataset;</code></li>
<li class='green'><span class='hits'>3267</span><code>                return this.__schemaUtiltyDs;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  AUTO INCREMENT SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        AUTOINCREMENT:'AUTOINCREMENT',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  CASCACDE SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        CASCADE:'CASCADE',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default comma</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        COMMA_SEPARATOR:', ',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  NO ACTION SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        NO_ACTION:'NO ACTION',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  NOT NULL SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        NOT_NULL:' NOT NULL',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default NULL SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        NULL:' NULL',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  PRIMARY KEY SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        PRIMARY_KEY:' PRIMARY KEY',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  RESTRICT SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        RESTRICT:'RESTRICT',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  SET DEFAULT SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SET_DEFAULT:'SET DEFAULT',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  SET NULL SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SET_NULL:'SET NULL',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  TEMPORARY SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        TEMPORARY:'TEMPORARY ',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  UNDERSCORE SQL, used in index creation.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        UNDERSCORE:'_',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Default  UNIQUE SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        UNIQUE:' UNIQUE',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default  UNSIGNED SQL</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        UNSIGNED:' UNSIGNED'</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="sql.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>sql.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>90.99</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>2745</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>466</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>42</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="sql.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb-proxy"),</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    flatten = array.flatten,</code></li>
<li class='green'><span class=''> </span><code>    ExpressionError = require("./errors").ExpressionError,</code></li>
<li class='green'><span class=''> </span><code>    methodMissing = comb.methodMissing,</code></li>
<li class='green'><span class=''> </span><code>    createFunctionWrapper = comb.createFunctionWrapper,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isDate = comb.isDate,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    toArray = array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isNumber = comb.isNumber,</code></li>
<li class='green'><span class=''> </span><code>    isObject = comb.isObject,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    isRegExp = comb.isRegExp,</code></li>
<li class='green'><span class=''> </span><code>    Dataset, patio;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var virtualRow = function (name) {</code></li>
<li class='green'><span class='hits'>975</span><code>    var WILDCARD = new LiteralString('*');</code></li>
<li class='green'><span class='hits'>975</span><code>    var QUESTION_MARK = new LiteralString('?');</code></li>
<li class='green'><span class='hits'>975</span><code>    var COMMA_SEPARATOR = new LiteralString(', ');</code></li>
<li class='green'><span class='hits'>975</span><code>    var DOUBLE_UNDERSCORE = '__';</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>975</span><code>    var parts = name.split(DOUBLE_UNDERSCORE);</code></li>
<li class='green'><span class='hits'>975</span><code>    var table = parts[0], column = parts[1];</code></li>
<li class='green'><span class='hits'>975</span><code>    var ident = column ? QualifiedIdentifier.fromArgs([table, column]) : Identifier.fromArgs([name]);</code></li>
<li class='green'><span class='hits'>975</span><code>    var prox = methodMissing(ident, function (m) {</code></li>
<li class='green'><span class='hits'>4</span><code>        return function () {</code></li>
<li class='green'><span class='hits'>3</span><code>            var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>3</span><code>            return SQLFunction.fromArgs([m, name].concat(args));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }, column ? QualifiedIdentifier : Identifier);</code></li>
<li class='green'><span class='hits'>975</span><code>    var ret = createFunctionWrapper(prox, function (m) {</code></li>
<li class='green'><span class='hits'>548</span><code>        var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>548</span><code>        if (args.length) {</code></li>
<li class='green'><span class='hits'>542</span><code>            return SQLFunction.fromArgs([name].concat(args));</code></li>
<li class='green'><span class=''> </span><code>        } else {</code></li>
<li class='green'><span class='hits'>6</span><code>            return prox;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }, function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>        return SQLFunction.fromArgs(arguments);</code></li>
<li class='green'><span class=''> </span><code>    });</code></li>
<li class='green'><span class='hits'>975</span><code>    ret.__proto__ = ident;</code></li>
<li class='green'><span class='hits'>975</span><code>    return ret;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var DATE_METHODS = ["getDate", "getDay", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getSeconds",</code></li>
<li class='green'><span class=''> </span><code>    "getTime", "getTimezoneOffset", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds",</code></li>
<li class='green'><span class=''> </span><code>    "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getYear", "parse", "setDate", "setFullYear", "setHours", "setMilliseconds",</code></li>
<li class='green'><span class=''> </span><code>    "setMinutes", "setMonth", "setSeconds", "setTime", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds",</code></li>
<li class='green'><span class=''> </span><code>    "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setYear", "toDateString", "toGMTString", "toLocaleDateString",</code></li>
<li class='green'><span class=''> </span><code>    "toLocaleTimeString", "toLocaleString", "toTimeString", "toUTCString", "UTC", "valueOf"];</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var addDateMethod = function (op) {</code></li>
<li class='green'><span class='hits'>180</span><code>    return function () {</code></li>
<li class='green'><span class='hits'>4</span><code>        return this.date[op].apply(this.date, arguments);</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @constructor</code></li>
<li class='green'><span class=''> </span><code> * Creates a Year type to be used in queries that require a SQL year datatype.</code></li>
<li class='green'><span class=''> </span><code> * All &lt;i&gt;Date&lt;/i&gt; methods ar included in the prototype of the Year type. toString and toJSON</code></li>
<li class='green'><span class=''> </span><code> * are overridden to return a year format instead of the default &lt;i&gt;Date&lt;/i&gt; formatting.</code></li>
<li class='green'><span class=''> </span><code> * See {@link patioTime#yearToString} for formatting information.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * var year = patio.Year(2009); //=&gt; 2009</code></li>
<li class='green'><span class=''> </span><code> * JSON.stringify(year)l //=&gt; 2009</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} y the year this year represents.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var Year = function (y) {</code></li>
<li class='green'><span class='hits'>10</span><code>    this.date = isUndefined(y) ? new Date() : isDate(y) ? y : new Date(y, 0, 1, 0, 0, 0);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>Year.prototype.toJSON = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>Year.prototype.toString = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class='hits'>1</span><code>DATE_METHODS.forEach(function (op) {</code></li>
<li class='green'><span class='hits'>45</span><code>    Year.prototype[op] = addDateMethod(op);</code></li>
<li class='green'><span class=''> </span><code>}, this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @constructor</code></li>
<li class='green'><span class=''> </span><code> * Creates a Time type to be used in queries that require a SQL time datatype.</code></li>
<li class='green'><span class=''> </span><code> * All &lt;i&gt;Date&lt;/i&gt; methods ar included in the prototype of the Time type. toString and toJSON</code></li>
<li class='green'><span class=''> </span><code> * are overridden to return a time format instead of the default &lt;i&gt;Date&lt;/i&gt; formatting.</code></li>
<li class='green'><span class=''> </span><code> * See {@link patioTime#timeToString} for formatting information.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * var time = patio.Time(12, 12, 12); //=&gt; 12:12:12</code></li>
<li class='green'><span class=''> </span><code> * JSON.stringify(time); //=&gt; 12:12:12</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [h=0] the hour</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [min=0] the minute/s</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [s=0] the second/s</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [ms=0] the millisecond/s, this paramater is not be used, but may depending on the adapter.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var Time = function (h, min, s, ms) {</code></li>
<li class='green'><span class='hits'>14</span><code>    var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>14</span><code>    if (args.length === 0) {</code></li>
<li class='red'><span class='nohits'>0</span><code>        this.date = new Date();</code></li>
<li class='green'><span class='hits'>14</span><code>    } else if (isDate(h)) {</code></li>
<li class='green'><span class='hits'>9</span><code>        this.date = h;</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='green'><span class='hits'>5</span><code>        var date = new Date(1970, 0, 1, 0, 0, 0);</code></li>
<li class='green'><span class='hits'>5</span><code>        isNumber(h) &amp;&amp; date.setHours(h);</code></li>
<li class='green'><span class='hits'>5</span><code>        isNumber(min) &amp;&amp; date.setMinutes(min);</code></li>
<li class='green'><span class='hits'>5</span><code>        isNumber(s) &amp;&amp; date.setSeconds(s);</code></li>
<li class='green'><span class='hits'>5</span><code>        isNumber(ms) &amp;&amp; date.setMilliseconds(ms);</code></li>
<li class='green'><span class='hits'>5</span><code>        this.date = date;</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>Time.prototype.toJSON = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>Time.prototype.toString = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>DATE_METHODS.forEach(function (op) {</code></li>
<li class='green'><span class='hits'>45</span><code>    Time.prototype[op] = addDateMethod(op);</code></li>
<li class='green'><span class=''> </span><code>}, this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @constructor</code></li>
<li class='green'><span class=''> </span><code> * Creates a TimeStamp type to be used in queries that require a SQL timestamp datatype.</code></li>
<li class='green'><span class=''> </span><code> * All &lt;i&gt;Date&lt;/i&gt; methods ar included in the prototype of the TimeStamp type. toString and toJSON</code></li>
<li class='green'><span class=''> </span><code> * are overridden to return a ISO8601 format instead of the default &lt;i&gt;Date&lt;/i&gt; formatting.</code></li>
<li class='green'><span class=''> </span><code> * See {@link patioTime#timeStampToString} for formatting information.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * var timeStamp = patio.TimeStamp(2009, 10, 10, 10, 10, 10); //=&gt; '2009-11-10 10:10:10'</code></li>
<li class='green'><span class=''> </span><code> * JSON.stringify(timeStamp); //=&gt; '2009-11-10 10:10:10'</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [y=1970] the year</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [m=0] the month</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [d=1] the day</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [h=0] the hour</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [min=0] the minute/s</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [s=0] the second/s</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [ms=0] the millisecond/s, this paramater is not be used, but may depending on the adapter.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var TimeStamp = function (y, m, d, h, min, s, ms) {</code></li>
<li class='green'><span class='hits'>54</span><code>    var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>54</span><code>    if (args.length === 0) {</code></li>
<li class='green'><span class='hits'>1</span><code>        this.date = new Date();</code></li>
<li class='green'><span class='hits'>53</span><code>    } else if (isDate(y)) {</code></li>
<li class='green'><span class='hits'>49</span><code>        this.date = y;</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='green'><span class='hits'>4</span><code>        var date = new Date(1970, 0, 1, 0, 0, 0);</code></li>
<li class='green'><span class='hits'>4</span><code>        isNumber(y) &amp;&amp; date.setYear(y);</code></li>
<li class='green'><span class='hits'>4</span><code>        isNumber(m) &amp;&amp; date.setMonth(m);</code></li>
<li class='green'><span class='hits'>4</span><code>        isNumber(d) &amp;&amp; date.setDate(d);</code></li>
<li class='green'><span class='hits'>4</span><code>        isNumber(h) &amp;&amp; date.setHours(h);</code></li>
<li class='green'><span class='hits'>4</span><code>        isNumber(min) &amp;&amp; date.setMinutes(min);</code></li>
<li class='green'><span class='hits'>4</span><code>        isNumber(s) &amp;&amp; date.setSeconds(s);</code></li>
<li class='green'><span class='hits'>4</span><code>        isNumber(ms) &amp;&amp; date.setMilliseconds(ms);</code></li>
<li class='green'><span class='hits'>4</span><code>        this.date = date;</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>TimeStamp.prototype.toJSON = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>TimeStamp.prototype.toString = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>DATE_METHODS.forEach(function (op) {</code></li>
<li class='green'><span class='hits'>45</span><code>    TimeStamp.prototype[op] = addDateMethod(op);</code></li>
<li class='green'><span class=''> </span><code>}, this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @constructor</code></li>
<li class='green'><span class=''> </span><code> * Creates a DateTime type to be used in queries that require a SQL datetime datatype.</code></li>
<li class='green'><span class=''> </span><code> * All &lt;i&gt;Date&lt;/i&gt; methods ar included in the prototype of the DateTime type. toString and toJSON</code></li>
<li class='green'><span class=''> </span><code> * are overridden to return a ISO8601 formatted date string instead of the default &lt;i&gt;Date&lt;/i&gt; formatting.</code></li>
<li class='green'><span class=''> </span><code> * See {@link patioTime#dateTimeToString} for formatting information.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * var dateTime = patio.DateTime(2009, 10, 10, 10, 10, 10); //=&gt; '2009-11-10 10:10:10'</code></li>
<li class='green'><span class=''> </span><code> * JSON.stringify(dateTime); //=&gt; '2009-11-10 10:10:10'</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [y=1970] the year</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [m=0] the month</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [d=1] the day</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [h=0] the hour</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [min=0] the minute/s</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [s=0] the second/s</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} [ms=0] the millisecond/s, this paramater is not be used, but may depending on the adapter.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var DateTime = function (y, m, d, h, min, s, ms) {</code></li>
<li class='green'><span class='hits'>83</span><code>    var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>83</span><code>    if(args.length === 0){</code></li>
<li class='red'><span class='nohits'>0</span><code>        this.date = new Date();</code></li>
<li class='green'><span class='hits'>83</span><code>    }else if (isDate(y)) {</code></li>
<li class='green'><span class='hits'>77</span><code>        this.date = y;</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='green'><span class='hits'>6</span><code>        var date = new Date(1970, 0, 1, 0, 0, 0);</code></li>
<li class='green'><span class='hits'>6</span><code>        isNumber(y) &amp;&amp; date.setYear(y);</code></li>
<li class='green'><span class='hits'>6</span><code>        isNumber(m) &amp;&amp; date.setMonth(m);</code></li>
<li class='green'><span class='hits'>6</span><code>        isNumber(d) &amp;&amp; date.setDate(d);</code></li>
<li class='green'><span class='hits'>6</span><code>        isNumber(h) &amp;&amp; date.setHours(h);</code></li>
<li class='green'><span class='hits'>6</span><code>        isNumber(min) &amp;&amp; date.setMinutes(min);</code></li>
<li class='green'><span class='hits'>6</span><code>        isNumber(s) &amp;&amp; date.setSeconds(s);</code></li>
<li class='green'><span class='hits'>6</span><code>        isNumber(ms) &amp;&amp; date.setMilliseconds(ms);</code></li>
<li class='green'><span class='hits'>6</span><code>        this.date = date;</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>DateTime.prototype.toJSON = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>DateTime.prototype.toString = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return isUndefined(this.date) ? this.date : sql.patio.dateToString(this);</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>DATE_METHODS.forEach(function (op) {</code></li>
<li class='green'><span class='hits'>45</span><code>    DateTime.prototype[op] = addDateMethod(op);</code></li>
<li class='green'><span class=''> </span><code>}, this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Represents a SQL Float type, by default is converted to double precision</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} number the number to be represented as a float</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var Float = function (number) {</code></li>
<li class='red'><span class='nohits'>0</span><code>    this.number = number;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>Float.prototype.toJSON = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return this.number;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class</code></li>
<li class='green'><span class=''> </span><code> * Represents a SQL Decimal type, by default is converted to double precision</code></li>
<li class='green'><span class=''> </span><code> * @param {Number} number the number to be represented as a decimal</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var Decimal = function (number) {</code></li>
<li class='red'><span class='nohits'>0</span><code>    this.number = number;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>Decimal.prototype.toJSON = function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    return this.number;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var hashToArray = function (hash) {</code></li>
<li class='green'><span class='hits'>3</span><code>    var ret = [];</code></li>
<li class='green'><span class='hits'>3</span><code>    if (isHash(hash)) {</code></li>
<li class='green'><span class='hits'>3</span><code>        for (var i in hash) {</code></li>
<li class='green'><span class='hits'>3</span><code>            var k = sql.stringToIdentifier(i), v = hash[i];</code></li>
<li class='green'><span class='hits'>3</span><code>            v = isHash(v) ? hashToArray(v) : v;</code></li>
<li class='green'><span class='hits'>3</span><code>            ret.push([k , v]);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>3</span><code>    return ret;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @namespace  Collection of SQL related types, and expressions.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code> *  The {@link patio.sql} object</code></li>
<li class='green'><span class=''> </span><code> *  can be used directly to create {@link patio.sql.Expression}s, {@link patio.sql.Identifier}s, {@link patio.sql.SQLFunction}s,</code></li>
<li class='green'><span class=''> </span><code> *  and {@link patio.sql.QualifiedIdentifier}s.</code></li>
<li class='green'><span class=''> </span><code> * &lt;pre class='code'&gt;</code></li>
<li class='green'><span class=''> </span><code> *  var sql = patio.sql;</code></li>
<li class='green'><span class=''> </span><code> *  //creating an identifier</code></li>
<li class='green'><span class=''> </span><code> *  sql.a; //=&gt; a;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  //creating a qualified identifier</code></li>
<li class='green'><span class=''> </span><code> *  sql.table__column; //table.column;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  //BooleanExpression</code></li>
<li class='green'><span class=''> </span><code> *  sql.a.lt(sql.b); //=&gt; a &lt; 'b';</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  //SQL Functions</code></li>
<li class='green'><span class=''> </span><code> *  sql.sum(sql.a); //=&gt; sum(a)</code></li>
<li class='green'><span class=''> </span><code> *  sql.avg(sql.b); //=&gt; avg(b)</code></li>
<li class='green'><span class=''> </span><code> *  sql.a("b", 1); //=&gt; a(b, 1)</code></li>
<li class='green'><span class=''> </span><code> *  sql.myDatabasesObjectFunction(sql.a, sql.b, sql.c); //=&gt; myDatabasesObjectFunction(a, b, c);</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  //combined</code></li>
<li class='green'><span class=''> </span><code> *  sql.a.cast("boolean"); //=&gt; 'CAST(a AS boolean)'</code></li>
<li class='green'><span class=''> </span><code> *  sql.a.plus(sql.b).lt(sql.c.minus(3) //=&gt; ((a + b) &lt; (c - 3))</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * This is useful when combined with dataset filtering</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code> *  var ds = DB.from("t");</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter({a:[sql.b, sql.c]}).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT * FROM t WHERE (a IN (b, c))</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.select(sql["case"]({b:{c:1}}, false)).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT (CASE WHEN b THEN (c = 1) ELSE 'f' END) FROM t</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.select(sql.a).qualifyToFirstSource().sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt;  SELECT a FROM t</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.order(sql.a.desc(), sql.b.asc()).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt;  SELECT * FROM t ORDER BY a DESC, b ASC</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.select(sql.a.as("b")).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT a AS b FROM t</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter(sql["case"]({a:sql.b}, sql.c, sql.d)).sql</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT * FROM t WHERE (CASE d WHEN a THEN b ELSE c END)</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter(sql.a.cast("boolean")).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT * FROM t WHERE CAST(a AS boolean)</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter(sql.a("b", 1)).sql</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT * FROM t WHERE a(b, 1)</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter(sql.a.plus(sql.b).lt(sql.c.minus(3)).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT * FROM t WHERE ((a + b) &lt; (c - 3))</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter(sql.a.sqlSubscript(sql.b, 3)).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt; SELECT * FROM t WHERE a[b, 3]</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter('? &gt; ?', sql.a, 1).sql;</code></li>
<li class='green'><span class=''> </span><code> *     //=&gt; SELECT * FROM t WHERE (a &gt; 1);</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.filter('{a} &gt; {b}', {a:sql.c, b:1}).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt;SELECT * FROM t WHERE (c &gt; 1)</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  ds.select(sql.literal("'a'"))</code></li>
<li class='green'><span class=''> </span><code> *     .filter(sql.a(3))</code></li>
<li class='green'><span class=''> </span><code> *     .filter('blah')</code></li>
<li class='green'><span class=''> </span><code> *     .order(sql.literal(true))</code></li>
<li class='green'><span class=''> </span><code> *     .group(sql.literal('a &gt; ?', [1]))</code></li>
<li class='green'><span class=''> </span><code> *     .having(false).sql;</code></li>
<li class='green'><span class=''> </span><code> *      //=&gt;"SELECT 'a' FROM t WHERE (a(3) AND (blah)) GROUP BY a &gt; 1 HAVING 'f' ORDER BY true");</code></li>
<li class='green'><span class=''> </span><code> &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code> * @name sql</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var sql = {</code></li>
<li class='green'><span class=''> </span><code>    /**@lends patio.sql*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Returns a {@link patio.sql.Identifier}, {@link patio.sql.QualifiedIdentifier},</code></li>
<li class='green'><span class=''> </span><code>     * or {@link patio.sql.ALiasedExpression} depending on the format of the string</code></li>
<li class='green'><span class=''> </span><code>     * passed in.</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>     *      &lt;li&gt;For columns : table__column___alias.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>     *      &lt;li&gt;For tables : schema__table___alias.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>     * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>     * each portion of the identifier is optional. See example below</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @example</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * patio.sql.identifier("a") //= &gt; new patio.sql.Identifier("a");</code></li>
<li class='green'><span class=''> </span><code>     * patio.sql.identifier("table__column"); //=&gt; new patio.sql.QualifiedIdentifier(table, column);</code></li>
<li class='green'><span class=''> </span><code>     * patio.sql.identifier("table__column___alias");</code></li>
<li class='green'><span class=''> </span><code>     *      //=&gt; new patio.sql.AliasedExpression(new patio.sql.QualifiedIdentifier(table, column), alias);</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @param {String} name the name to covert to an an {@link patio.sql.Identifier}, {@link patio.sql.QualifiedIdentifier},</code></li>
<li class='green'><span class=''> </span><code>     * or {@link patio.sql.AliasedExpression}.</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @return  {patio.sql.Identifier|patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} an identifier generated based on the name string.</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    identifier:function (s) {</code></li>
<li class='green'><span class='hits'>1575</span><code>        return sql.stringToIdentifier(s);</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * @see patio.sql.identifier</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    stringToIdentifier:function (name) {</code></li>
<li class='green'><span class='hits'>11815</span><code>        !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>11815</span><code>        return new Dataset().stringToIdentifier(name);</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Creates a {@link patio.sql.LiteralString} or {@link patio.sql.PlaceHolderLiteralString}</code></li>
<li class='green'><span class=''> </span><code>     * depending on the arguments passed in. If a single string is passed in then</code></li>
<li class='green'><span class=''> </span><code>     * it is assumed to be a {@link patio.sql.LiteralString}. If more than one argument is</code></li>
<li class='green'><span class=''> </span><code>     * passed in then it is assumed to be a {@link patio.sql.PlaceHolderLiteralString}.</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @example</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * //a literal string that will be placed in an SQL query with out quoting.</code></li>
<li class='green'><span class=''> </span><code>     * patio.sql.literal("a"); //=&gt; new patio.sql.LiteralString('a');</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * //a placeholder string that will have ? replaced with the {@link patio.Dataset#literal} version of</code></li>
<li class='green'><span class=''> </span><code>     * //the arugment and replaced in the string.</code></li>
<li class='green'><span class=''> </span><code>     * patio.sql.literal("a = ?", 1)  //=&gt; a = 1</code></li>
<li class='green'><span class=''> </span><code>     * patio.sql.literal("a = ?", "b"); //=&gt; a = 'b'</code></li>
<li class='green'><span class=''> </span><code>     * patio.sql.literal("a = {a} AND b = {b}", {a : 1, b : 2}); //=&gt; a = 1 AND b = 2</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @param {String ...} s variable number of arguments where the first argument</code></li>
<li class='green'><span class=''> </span><code>     * is a string. If multiple arguments are passed it is a assumed to be a {@link patio.sql.PlaceHolderLiteralString}</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @return {patio.sql.LiteralString|patio.sql.PlaceHolderLiteralString} an expression that can be used as an argument</code></li>
<li class='green'><span class=''> </span><code>     * for {@link patio.Dataset} query methods.</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    literal:function (s) {</code></li>
<li class='green'><span class='hits'>458</span><code>        var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>458</span><code>        return args.length &gt; 1 ? PlaceHolderLiteralString.fromArgs(args) : new LiteralString(s);</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Returns a {@link patio.sql.CaseExpression}. See {@link patio.sql.CaseExpression} for argument types.</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @example</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * sql["case"]({a:sql.b}, sql.c, sql.d); //=&gt; (CASE t.d WHEN t.a THEN t.b ELSE t.c END)</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    "case":function (hash, /*args**/opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>        var args = argsToArray(arguments, 1);</code></li>
<li class='green'><span class='hits'>2</span><code>        return CaseExpression.fromArgs([hashToArray(hash)].concat(args));</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Creates a {@link patio.sql.StringExpression}</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * Return a {@link patio.sql.StringExpression} representing an SQL string made up of the</code></li>
<li class='green'><span class=''> </span><code>     * concatenation of this array's elements.  If an joiner is passed</code></li>
<li class='green'><span class=''> </span><code>     * it is used in between each element of the array in the SQL</code></li>
<li class='green'><span class=''> </span><code>     * concatenation.</code></li>
<li class='green'><span class=''> </span><code>     *</code></li>
<li class='green'><span class=''> </span><code>     * @example</code></li>
<li class='green'><span class=''> </span><code>     *   patio.sql.sqlStringJoin(["a"]); //=&gt; a</code></li>
<li class='green'><span class=''> </span><code>     *   //you can use sql.* as a shortcut to get an identifier</code></li>
<li class='green'><span class=''> </span><code>     *   patio.sql.sqlStringJoin([sql.identifier("a"), sql.b]);//=&gt; a || b</code></li>
<li class='green'><span class=''> </span><code>     *   patio.sql.sqlStringJoin([sql.a, 'b']) # SQL: a || 'b'</code></li>
<li class='green'><span class=''> </span><code>     *   patio.sql.sqlStringJoin(['a', sql.b], ' '); //=&gt; 'a' || ' ' || b</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    sqlStringJoin:function (arr, joiner) {</code></li>
<li class='green'><span class='hits'>6</span><code>        joiner = joiner || null;</code></li>
<li class='green'><span class='hits'>6</span><code>        var args;</code></li>
<li class='green'><span class='hits'>6</span><code>        arr = arr.map(function (a) {</code></li>
<li class='green'><span class='hits'>12</span><code>            return isInstanceOf(a, Expression, LiteralString, Boolean) || isNull(a) ? a : sql.stringToIdentifier(a)</code></li>
<li class='green'><span class=''> </span><code>        });</code></li>
<li class='green'><span class='hits'>6</span><code>        if (joiner) {</code></li>
<li class='green'><span class='hits'>4</span><code>            var newJoiner = [];</code></li>
<li class='green'><span class='hits'>4</span><code>            for (var i = 0; i &lt; arr.length; i++) {</code></li>
<li class='green'><span class='hits'>9</span><code>                newJoiner.push(joiner);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4</span><code>            args = array.flatten(array.zip(arr, newJoiner));</code></li>
<li class='green'><span class='hits'>4</span><code>            args.pop();</code></li>
<li class='green'><span class=''> </span><code>        } else {</code></li>
<li class='green'><span class='hits'>2</span><code>            args = arr;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class='hits'>6</span><code>        args = args.map(function (a) {</code></li>
<li class='green'><span class='hits'>17</span><code>            return isInstanceOf(a, Expression, LiteralString, Boolean) || isNull(a) ? a : "" + a;</code></li>
<li class='green'><span class=''> </span><code>        });</code></li>
<li class='green'><span class='hits'>6</span><code>        return StringExpression.fromArgs(["||"].concat(args));</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    Year:Year,</code></li>
<li class='green'><span class=''> </span><code>    TimeStamp:TimeStamp,</code></li>
<li class='green'><span class=''> </span><code>    Time:Time,</code></li>
<li class='green'><span class=''> </span><code>    DateTime:DateTime,</code></li>
<li class='green'><span class=''> </span><code>    Float:Float,</code></li>
<li class='green'><span class=''> </span><code>    Decimal:Decimal</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>sql.__defineGetter__("patio", function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>    !patio &amp;&amp; (patio = require("./index"));</code></li>
<li class='red'><span class='nohits'>0</span><code>    return patio;</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>exports.sql = methodMissing(sql, function (name) {</code></li>
<li class='green'><span class='hits'>975</span><code>    return virtualRow(name);</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var OPERTATOR_INVERSIONS = {</code></li>
<li class='green'><span class=''> </span><code>    AND:"OR",</code></li>
<li class='green'><span class=''> </span><code>    OR:"AND",</code></li>
<li class='green'><span class=''> </span><code>    GT:"lte",</code></li>
<li class='green'><span class=''> </span><code>    GTE:"lt",</code></li>
<li class='green'><span class=''> </span><code>    LT:"gte",</code></li>
<li class='green'><span class=''> </span><code>    LTE:"gt",</code></li>
<li class='green'><span class=''> </span><code>    EQ:"neq",</code></li>
<li class='green'><span class=''> </span><code>    NEQ:"eq",</code></li>
<li class='green'><span class=''> </span><code>    LIKE:'NOT LIKE',</code></li>
<li class='green'><span class=''> </span><code>    "NOT LIKE":"LIKE",</code></li>
<li class='green'><span class=''> </span><code>    '!~*':'~*',</code></li>
<li class='green'><span class=''> </span><code>    '~*':'!~*',</code></li>
<li class='green'><span class=''> </span><code>    "~":'!~',</code></li>
<li class='green'><span class=''> </span><code>    "IN":'NOTIN',</code></li>
<li class='green'><span class=''> </span><code>    "NOTIN":"IN",</code></li>
<li class='green'><span class=''> </span><code>    "IS":'IS NOT',</code></li>
<li class='green'><span class=''> </span><code>    "ISNOT":"IS",</code></li>
<li class='green'><span class=''> </span><code>    NOT:"NOOP",</code></li>
<li class='green'><span class=''> </span><code>    NOOP:"NOT",</code></li>
<li class='green'><span class=''> </span><code>    ILIKE:'NOT ILIKE',</code></li>
<li class='green'><span class=''> </span><code>    NOTILIKE:"ILIKE"</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>// Standard mathematical operators used in +NumericMethods+</code></li>
<li class='green'><span class='hits'>1</span><code>var MATHEMATICAL_OPERATORS = {PLUS:"+", MINUS:"-", DIVIDE:"/", MULTIPLY:"*"};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>// Bitwise mathematical operators used in +NumericMethods+</code></li>
<li class='green'><span class='hits'>1</span><code>var BITWISE_OPERATORS = {bitWiseAnd:"&amp;", bitWiseOr:"|", exclusiveOr:"^", leftShift:"&lt;&lt;", rightShift:"&gt;&gt;"};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var INEQUALITY_OPERATORS = {GT:"&gt;", GTE:"&gt;=", LT:"&lt;", LTE:"&lt;="};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//Hash of ruby operator symbols to SQL operators, used in +BooleanMethods+</code></li>
<li class='green'><span class='hits'>1</span><code>var BOOLEAN_OPERATORS = {AND:"AND", OR:"OR"};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//Operators that use IN/NOT IN for inclusion/exclusion</code></li>
<li class='green'><span class='hits'>1</span><code>var IN_OPERATORS = {IN:"IN", NOTIN:'NOT IN'};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//Operators that use IS, used for special casing to override literal true/false values</code></li>
<li class='green'><span class='hits'>1</span><code>var IS_OPERATORS = {IS:"IS", ISNOT:'IS NOT'};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//Operator symbols that take exactly two arguments</code></li>
<li class='green'><span class='hits'>1</span><code>var TWO_ARITY_OPERATORS = merge({</code></li>
<li class='green'><span class=''> </span><code>    EQ:'=',</code></li>
<li class='green'><span class=''> </span><code>    NEQ:'!=', LIKE:"LIKE",</code></li>
<li class='green'><span class=''> </span><code>    "NOT LIKE":'NOT LIKE',</code></li>
<li class='green'><span class=''> </span><code>    ILIKE:"ILIKE",</code></li>
<li class='green'><span class=''> </span><code>    "NOT ILIKE":'NOT ILIKE',</code></li>
<li class='green'><span class=''> </span><code>    "~":"~",</code></li>
<li class='green'><span class=''> </span><code>    '!~':"!~",</code></li>
<li class='green'><span class=''> </span><code>    '~*':"~*",</code></li>
<li class='green'><span class=''> </span><code>    '!~*':"!~*"}, INEQUALITY_OPERATORS, BITWISE_OPERATORS, IS_OPERATORS, IN_OPERATORS);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//Operator symbols that take one or more arguments</code></li>
<li class='green'><span class='hits'>1</span><code>var N_ARITY_OPERATORS = merge({"||":"||"}, BOOLEAN_OPERATORS, MATHEMATICAL_OPERATORS);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//Operator symbols that take only a single argument</code></li>
<li class='green'><span class='hits'>1</span><code>var ONE_ARITY_OPERATORS = {"NOT":"NOT", "NOOP":"NOOP"};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Mixin to provide alias methods to an expression.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name AliasMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var AliasMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.AliasMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Create an SQL alias {@link patio.sql.AliasedExpression} of the receiving column or expression</code></li>
<li class='green'><span class=''> </span><code>         *  to the given alias.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  sql.identifier("column").as("alias");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; "column" AS "alias"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} alias the alias to assign to the expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.AliasedExpression} the aliased expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        as:function (alias) {</code></li>
<li class='green'><span class='hits'>552</span><code>            return new AliasedExpression(this, alias);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "AliasMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var bitWiseMethod = function (op) {</code></li>
<li class='green'><span class='hits'>5</span><code>    return function (expression) {</code></li>
<li class='red'><span class='nohits'>0</span><code>        if (isInstanceOf(expression, StringExpression) || isInstanceOf(expression, BooleanExpression)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new ExpressionError("Cannot apply " + op + " to a non numeric expression");</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>        else {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return new BooleanExpression(op, this, expression);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Defines the bitwise methods: bitWiseAnd, bitWiseOr, exclusiveOr, leftShift, and rightShift.  These</code></li>
<li class='green'><span class=''> </span><code> * methods are only on {@link patio.sql.NumericExpression}</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *   sql.a.sqlNumber.bitWiseAnd("b"); //=&gt; "a" &amp; "b"</code></li>
<li class='green'><span class=''> </span><code> *   sql.a.sqlNumber.bitWiseOr("b") //=&gt; "a" | "b"</code></li>
<li class='green'><span class=''> </span><code> *   sql.a.sqlNumber.exclusiveOr("b") //=&gt; "a" ^ "b"</code></li>
<li class='green'><span class=''> </span><code> *   sql.a.sqlNumber.leftShift("b") // "a" &lt;&lt; "b"</code></li>
<li class='green'><span class=''> </span><code> *   sql.a.sqlNumber.rightShift("b") //=&gt; "a" &gt;&gt; "b"</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name BitWiseMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var BitWiseMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.BitWiseMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Bitwise and</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.sqlNumber.bitWiseAnd("b"); //=&gt; "a" &amp; "b"</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        bitWiseAnd:bitWiseMethod("bitWiseAnd"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Bitwise or</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.sqlNumber.bitWiseOr("b") //=&gt; "a" | "b"</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        bitWiseOr:bitWiseMethod("bitWiseOr"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Exclusive Or</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.sqlNumber.exclusiveOr("b") //=&gt; "a" ^ "b"</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        exclusiveOr:bitWiseMethod("exclusiveOr"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  Bitwise shift left</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  sql.a.sqlNumber.leftShift("b") // "a" &lt;&lt; "b"</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        leftShift:bitWiseMethod("leftShift"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Bitwise shift right</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.sqlNumber.rightShift("b") //=&gt; "a" &gt;&gt; "b"</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        rightShift:bitWiseMethod("rightShift")</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "BitWiseMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var booleanMethod = function (op) {</code></li>
<li class='green'><span class='hits'>2</span><code>    return function (expression) {</code></li>
<li class='green'><span class='hits'>7</span><code>        if (isInstanceOf(expression, StringExpression) || isInstanceOf(expression, NumericExpression)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new ExpressionError("Cannot apply " + op + " to a non boolean expression");</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>        else {</code></li>
<li class='green'><span class='hits'>7</span><code>            return new BooleanExpression(op, this, expression);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Defines boolean/logical AND (&amp;), OR (|) and NOT (~) operators</code></li>
<li class='green'><span class=''> </span><code> * that are defined on objects that can be used in a boolean context in SQL</code></li>
<li class='green'><span class=''> </span><code> * ({@link patio.sql.LiteralString}, and {@link patio.sql.GenericExpression}).</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> * sql.a.and(sql.b) //=&gt; "a" AND "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.or(sql.b) //=&gt; "a" OR "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.not() //=&gt; NOT "a"</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name BooleanMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var BooleanMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.BooleanMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @function</code></li>
<li class='green'><span class=''> </span><code>         * Logical AND</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.and(sql.b) //=&gt; "a" AND "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} a ANDed boolean expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        and:booleanMethod("and"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function</code></li>
<li class='green'><span class=''> </span><code>         * Logical OR</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.or(sql.b) //=&gt; "a" OR "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} a ORed boolean expression</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        or:booleanMethod("or"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logical NOT</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.not() //=&gt; NOT "a"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} a inverted boolean expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        not:function () {</code></li>
<li class='green'><span class='hits'>5</span><code>            return BooleanExpression.invert(this);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "BooleanMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Defines case methods</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name CastMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var CastMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.CastMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Cast the reciever to the given SQL type.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.cast("integer") //=&gt; CAST(a AS integer)</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.cast(String) //=&gt; CAST(a AS varchar(255))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.Cast} the casted expression</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        cast:function (type) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return new Cast(this, type);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Cast the reciever to the given SQL type (or the database's default Number type if none given.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.castNumeric() //=&gt; CAST(a AS integer)</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.castNumeric("double") //=&gt; CAST(a AS double precision)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param type the numeric type to cast to</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.NumericExpression} a casted numberic expression</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        castNumeric:function (type) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.cast(type || "integer").sqlNumber;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Cast the reciever to the given SQL type (or the database's default String type if none given),</code></li>
<li class='green'><span class=''> </span><code>         * and return the result as a {@link patio.sql.StringExpression}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  sql.a.castString() //=&gt; CAST(a AS varchar(255))</code></li>
<li class='green'><span class=''> </span><code>         *  sql.a.castString("text") //=&gt; CAST(a AS text)</code></li>
<li class='green'><span class=''> </span><code>         * @param type the string type to cast to</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.StringExpression} the casted string expression</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        castString:function (type) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.cast(type || String).sqlString;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "CastMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Provides methods to assist in assigning a SQL type to</code></li>
<li class='green'><span class=''> </span><code> * particular types, i.e. Boolean, Function, Number or String.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name ComplexExpressionMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> * @property {patio.sql.BooleanExpression} sqlBoolean Return a {@link patio.sql.BooleanExpression} representation of this expression type.</code></li>
<li class='green'><span class=''> </span><code> * @property {patio.sql.BooleanExpression} sqlFunction Return a {@link patio.sql.SQLFunction} representation of this expression type.</code></li>
<li class='green'><span class=''> </span><code> * @property {patio.sql.BooleanExpression} sqlNumber Return a {@link patio.sql.NumericExpression} representation of this expression type.</code></li>
<li class='green'><span class=''> </span><code> * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code> * sql.a.not("a") //=&gt; NOT "a"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.sqlNumber.not() //=&gt; ~"a"</code></li>
<li class='green'><span class=''> </span><code> * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code> * @property {patio.sql.BooleanExpression} sqlString  Return a {@link patio.sql.StringExpression} representation of this expression type.</code></li>
<li class='green'><span class=''> </span><code> * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code> * sql.a.plus(sql.b); //=&gt; "a" + "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.sqlString.concat(sql.b) //=&gt; "a" || "b"</code></li>
<li class='green'><span class=''> </span><code> * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var ComplexExpressionMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            sqlBoolean:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return new BooleanExpression("noop", this);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            sqlFunction:function () {</code></li>
<li class='green'><span class='hits'>13</span><code>                return new SQLFunction(this);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            sqlNumber:function () {</code></li>
<li class='green'><span class='hits'>50</span><code>                return new NumericExpression("noop", this);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            sqlString:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return new StringExpression("noop", this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "ComplexExpressionMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var inequalityMethod = function (op) {</code></li>
<li class='green'><span class='hits'>6</span><code>    return function (expression) {</code></li>
<li class='green'><span class='hits'>88</span><code>        if (isInstanceOf(expression, BooleanExpression)</code></li>
<li class='green'><span class=''> </span><code>            || isBoolean(expression)</code></li>
<li class='green'><span class=''> </span><code>            || isNull(expression)</code></li>
<li class='green'><span class=''> </span><code>            || (isHash(expression))</code></li>
<li class='green'><span class=''> </span><code>            || isArray(expression)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new ExpressionError("Cannot apply " + op + " to a boolean expression");</code></li>
<li class='green'><span class=''> </span><code>        } else {</code></li>
<li class='green'><span class='hits'>88</span><code>            return new BooleanExpression(op, this, expression);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin includes the inequality methods (&gt;, &lt;, &gt;=, &lt;=) that are defined on objects that can be</code></li>
<li class='green'><span class=''> </span><code> * used in a numeric or string context in SQL.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> * sql.a.gt("b")  //=&gt; a &gt; "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.lt("b")  //=&gt; a &gt; "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.gte("b") //=&gt; a &gt;= "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.lte("b") //=&gt; a &lt;= "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.eq("b") //=&gt; a = "b"</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name InequalityMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var InequalityMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.InequalityMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function Creates a gt {@link patio.sql.BooleanExpression} compared to this expression.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.gt("b")  //=&gt; a &gt; "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        gt:inequalityMethod("gt"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function Creates a gte {@link patio.sql.BooleanExpression} compared to this expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.gte("b")  //=&gt; a &gt;= "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        gte:inequalityMethod("gte"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function Creates a lt {@link patio.sql.BooleanExpression} compared to this expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.lt("b")  //=&gt; a &lt; "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        lt:inequalityMethod("lt"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function  Creates a lte {@link patio.sql.BooleanExpression} compared to this expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.lte("b")  //=&gt; a &lt;= "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        lte:inequalityMethod("lte"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function  Creates a eq {@link patio.sql.BooleanExpression} compared to this expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.eq("b")  //=&gt; a = "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        eq:inequalityMethod("eq"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        neq:inequalityMethod("neq"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Creates a boolean expression where the key is '&gt;=' value 1 and '&lt;=' value two.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.x.between([1,2]) =&gt; //=&gt; WHERE ((x &gt;= 1) AND (x &lt;= 10))</code></li>
<li class='green'><span class=''> </span><code>         * sql.x.between([1,2]).invert() =&gt; //=&gt; WHERE ((x &lt; 1) OR (x &gt; 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} items a two element array where the first element it the item to be gte and the second item lte.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} a boolean expression containing the between expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        between:function (items) {</code></li>
<li class='green'><span class='hits'>6</span><code>            return new BooleanExpression("AND", new BooleanExpression("gte", this, items[0]), new BooleanExpression("lte", this, items[1]))</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "InequalityMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin augments the default constructor for {@link patio.sql.ComplexExpression},</code></li>
<li class='green'><span class=''> </span><code> * so that attempting to use boolean input when initializing a {@link patio.sql.NumericExpression}</code></li>
<li class='green'><span class=''> </span><code> * or {@link patio.sql.StringExpression} results in an error. &lt;b&gt;It is not expected to be used directly.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name NoBooleanInputMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var NoBooleanInputMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (op) {</code></li>
<li class='green'><span class='hits'>22</span><code>            var args = argsToArray(arguments, 1);</code></li>
<li class='green'><span class='hits'>22</span><code>            args.forEach(function (expression) {</code></li>
<li class='green'><span class='hits'>26</span><code>                if ((isInstanceOf(expression, BooleanExpression))</code></li>
<li class='green'><span class=''> </span><code>                    || isBoolean(expression)</code></li>
<li class='green'><span class=''> </span><code>                    || isNull(expression)</code></li>
<li class='green'><span class=''> </span><code>                    || (isObject(expression) &amp;&amp; !isInstanceOf(expression, Expression, Dataset, LiteralString))</code></li>
<li class='green'><span class=''> </span><code>                    || isArray(expression)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ExpressionError("Cannot apply " + op + " to a boolean expression");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>22</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "NoBooleanInputMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var numericMethod = function (op) {</code></li>
<li class='green'><span class='hits'>4</span><code>    return function (expression) {</code></li>
<li class='green'><span class='hits'>12</span><code>        if (isInstanceOf(expression, BooleanExpression, StringExpression)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new ExpressionError("Cannot apply " + op + " to a non numeric expression");</code></li>
<li class='green'><span class=''> </span><code>        } else {</code></li>
<li class='green'><span class='hits'>12</span><code>            return new NumericExpression(op, this, expression);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin includes the standard mathematical methods (+, -, *, and /)</code></li>
<li class='green'><span class=''> </span><code> * that are defined on objects that can be used in a numeric context in SQL.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> * sql.a.plus(sql.b) //=&gt; "a" + "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.minus(sql.b) //=&gt; "a" - "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.multiply(sql.b) //=&gt; "a" * "b"</code></li>
<li class='green'><span class=''> </span><code> * sql.a.divide(sql.b) //=&gt; "a" / "b"</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name NumericMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var NumericMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.NumericMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function  Adds the provided expression to this expression and returns a {@link patio.sql.NumericExpression}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.plus(sql.b)  //=&gt; "a" + "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.NumericExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        plus:numericMethod("plus"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function  Subtracts the provided expression from this expression and returns a {@link patio.sql.NumericExpression}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.minus(sql.b)  //=&gt; "a" - "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.NumericExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        minus:numericMethod("minus"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function  Divides this expression by the  provided expression and returns a {@link patio.sql.NumericExpression}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.divide(sql.b)  //=&gt; "a" / "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.NumericExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        divide:numericMethod("divide"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @function  Divides this expression by the  provided expression and returns a {@link patio.sql.NumericExpression}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.multiply(sql.b)  //=&gt; "a" * "b"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.NumericExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        multiply:numericMethod("multiply")</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "NumericMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin provides ordering methods ("asc", "desc") to expression.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * sql.name.asc(); //=&gt; name ASC</code></li>
<li class='green'><span class=''> </span><code> * sql.price.desc(); //=&gt; price DESC</code></li>
<li class='green'><span class=''> </span><code> * sql.name.asc({nulls:"last"}); //=&gt; name ASC NULLS LAST</code></li>
<li class='green'><span class=''> </span><code> * sql.price.desc({nulls:"first"}); //=&gt; price DESC NULLS FIRST</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name OrderedMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var OrderedMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.OrderedMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Mark the receiving SQL column as sorting in an ascending fashion (generally a no-op).</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.name.asc(); //=&gt; name ASC</code></li>
<li class='green'><span class=''> </span><code>         * sql.name.asc({nulls:"last"}); //=&gt; name ASC NULLS LAST</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] options to use when sorting</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [options.nulls = null] Set to "first" to use NULLS FIRST (so NULL values are ordered</code></li>
<li class='green'><span class=''> </span><code>         *           before other values), or "last" to use NULLS LAST (so NULL values are ordered after other values).</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.OrderedExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        asc:function (options) {</code></li>
<li class='green'><span class='hits'>7</span><code>            return new OrderedExpression(this, false, options);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Mark the receiving SQL column as sorting in a descending fashion.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.price.desc(); //=&gt; price DESC</code></li>
<li class='green'><span class=''> </span><code>         * sql.price.desc({nulls:"first"}); //=&gt; price DESC NULLS FIRST</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options] options to use when sorting</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [options.nulls = null] Set to "first" to use NULLS FIRST (so NULL values are ordered</code></li>
<li class='green'><span class=''> </span><code>         *           before other values), or "last" to use NULLS LAST (so NULL values are ordered after other values).</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.OrderedExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        desc:function (options) {</code></li>
<li class='green'><span class='hits'>26</span><code>            return new OrderedExpression(this, true, options);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "OrderedMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin provides methods related to qualifying expression.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * sql.column.qualify("table") //=&gt; "table"."column"</code></li>
<li class='green'><span class=''> </span><code> * sql.table.qualify("schema") //=&gt; "schema"."table"</code></li>
<li class='green'><span class=''> </span><code> * sql.column.qualify("table").qualify("schema") //=&gt; "schema"."table"."column"</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name QualifyingMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var QualifyingMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.QualifyingMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Qualify the receiver with the given qualifier (table for column/schema for table).</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.column.qualify("table") //=&gt; "table"."column"</code></li>
<li class='green'><span class=''> </span><code>         * sql.table.qualify("schema") //=&gt; "schema"."table"</code></li>
<li class='green'><span class=''> </span><code>         * sql.column.qualify("table").qualify("schema") //=&gt; "schema"."table"."column"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} qualifier table/schema to qualify this expression to.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.QualifiedIdentifier}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        qualify:function (qualifier) {</code></li>
<li class='green'><span class='hits'>576</span><code>            return new QualifiedIdentifier(qualifier, this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Use to create a .* expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.table.all() //=&gt; "table".*</code></li>
<li class='green'><span class=''> </span><code>         * sql.table.qualify("schema").all() //=&gt; "schema"."table".*</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.ColumnAll}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        all:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>            return new ColumnAll(this);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "QualifyingMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin provides SQL string methods such as (like and iLike).</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * sql.a.like("A%"); //=&gt; "a" LIKE 'A%'</code></li>
<li class='green'><span class=''> </span><code> * sql.a.iLike("A%"); //=&gt; "a" LIKE 'A%'</code></li>
<li class='green'><span class=''> </span><code> * sql.a.like(/^a/); //=&gt;  "a" ~* '^a'</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name StringMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var StringMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.StringMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Create a {@link patio.sql.BooleanExpression} case insensitive pattern match of the receiver</code></li>
<li class='green'><span class=''> </span><code>         * with the given patterns.  See {@link patio.sql.StringExpression#like}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.iLike("A%"); //=&gt; "a" LIKE 'A%'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ilike:function (expression) {</code></li>
<li class='green'><span class='hits'>310</span><code>            expression = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>310</span><code>            return StringExpression.like.apply(StringExpression, [this].concat(expression).concat([</code></li>
<li class='green'><span class=''> </span><code>                {caseInsensitive:true}</code></li>
<li class='green'><span class=''> </span><code>            ]));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Create a {@link patio.sql.BooleanExpression} case sensitive (if the database supports it) pattern match of the receiver with</code></li>
<li class='green'><span class=''> </span><code>         * the given patterns.  See {@link patio.sql.StringExpression#like}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.like(/^a/); //=&gt;  "a" ~* '^a'</code></li>
<li class='green'><span class=''> </span><code>         * sql.a.like("A%"); //=&gt; "a" LIKE 'A%'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param expression</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        like:function (expression) {</code></li>
<li class='green'><span class='hits'>11</span><code>            expression = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>11</span><code>            return StringExpression.like.apply(StringExpression, [this].concat(expression));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "StringMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin provides string concatenation methods ("concat");</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * sql.x.sqlString.concat("y"); //=&gt; "x" || "y"</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name StringConcatenationMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var StringConcatenationMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.StringConcatenationMethods.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return a {@link patio.sql.StringExpression} representing the concatenation of this expression</code></li>
<li class='green'><span class=''> </span><code>         * with the given argument.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * sql.x.sqlString.concat("y"); //=&gt; "x" || "y"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param expression expression to concatenate this expression with.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        concat:function (expression) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return new StringExpression("||", this, expression);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "StringConcatenationMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This mixin provides the ability to access elements within a SQL array.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> * sql.array.sqlSubscript(1) //=&gt; array[1]</code></li>
<li class='green'><span class=''> </span><code> * sql.array.sqlSubscript(1, 2) //=&gt; array[1, 2]</code></li>
<li class='green'><span class=''> </span><code> * sql.array.sqlSubscript([1, 2]) //=&gt; array[1, 2]</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name SubscriptMethods</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var SubscriptMethods = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return a {@link patio.sql.Subscript} with the given arguments, representing an</code></li>
<li class='green'><span class=''> </span><code>         * SQL array access.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * sql.array.sqlSubscript(1) //=&gt; array[1]</code></li>
<li class='green'><span class=''> </span><code>         * sql.array.sqlSubscript(1, 2) //=&gt; array[1, 2]</code></li>
<li class='green'><span class=''> </span><code>         * sql.array.sqlSubscript([1, 2]) //=&gt; array[1, 2]</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param subscript</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        sqlSubscript:function (subscript) {</code></li>
<li class='green'><span class='hits'>75</span><code>            var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>75</span><code>            return new SubScript(this, flatten(args));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "SubScriptMethods");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This is the parent of all expressions.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name Expression</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var Expression = define(null, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.Expression.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns the string representation of this expression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} ds the dataset that will be used to SQL-ify this expression.</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} a string literal version of this expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        sqlLiteral:function (ds) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.toString(ds);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.Expression*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This is a helper method that will take in an array of arguments and return an expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * QualifiedIdentifier.fromArgs(["table", "column"]);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*[]} args array of arguments to pass into the constructor of the function.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.Expression} an expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fromArgs:function (args) {</code></li>
<li class='green'><span class='hits'>2284</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>2284</span><code>            try {</code></li>
<li class='green'><span class='hits'>2284</span><code>                ret = new this();</code></li>
<li class='green'><span class=''> </span><code>            } catch (ignore) {</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2284</span><code>            this.apply(ret, args);</code></li>
<li class='green'><span class='hits'>2284</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Helper to determine if something is a condition specifier. Returns true if the object</code></li>
<li class='green'><span class=''> </span><code>         * is a Hash or is an array of two element arrays.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * Expression.isConditionSpecifier({a : "b"}); //=&gt; true</code></li>
<li class='green'><span class=''> </span><code>         * Expression.isConditionSpecifier("a"); //=&gt; false</code></li>
<li class='green'><span class=''> </span><code>         * Expression.isConditionSpecifier([["a", "b"], ["c", "d"]]); //=&gt; true</code></li>
<li class='green'><span class=''> </span><code>         * Expression.isConditionSpecifier([["a", "b", "e"], ["c", "d"]]); //=&gt; false</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} obj object to test if it is a condition specifier</code></li>
<li class='green'><span class=''> </span><code>         * @return {Boolean} true if the object is a Hash or is an array of two element arrays.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isConditionSpecifier:function (obj) {</code></li>
<li class='green'><span class='hits'>22172</span><code>            return isHash(obj) || (isArray(obj) &amp;&amp; obj.length &amp;&amp; obj.every(function (i) {</code></li>
<li class='green'><span class='hits'>9547</span><code>                return isArray(i) &amp;&amp; i.length === 2;</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "Expression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Base class for all GenericExpressions</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.Expression</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.AliasMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.BooleanMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.CastMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.ComplexExpressionMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.InequalityMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.NumericMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.OrderedMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.StringMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.SubscriptMethods</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name GenericExpression</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var GenericExpression = define([Expression, AliasMethods, BooleanMethods, CastMethods, ComplexExpressionMethods, InequalityMethods, NumericMethods, OrderedMethods, StringMethods, SubscriptMethods]).as(sql, "GenericExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var AliasedExpression = define(Expression, {</code></li>
<li class='green'><span class=''> </span><code>        instance:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.sql.AliasedExpression.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * This class reperesents an Aliased Expression</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @constructs</code></li>
<li class='green'><span class=''> </span><code>             * @augments patio.sql.Expression</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @param expression  the expression to alias.</code></li>
<li class='green'><span class=''> </span><code>             * @param alias the alias to alias the expression to.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @property expression the expression being aliased</code></li>
<li class='green'><span class=''> </span><code>             * @property alias the alias of the expression</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            constructor:function (expression, alias) {</code></li>
<li class='green'><span class='hits'>910</span><code>                this.expression = expression;</code></li>
<li class='green'><span class='hits'>910</span><code>                this.alias = alias;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Converts the aliased expression to a string</code></li>
<li class='green'><span class=''> </span><code>             * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>             * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @return String the SQL alias fragment.</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            toString:function (ds) {</code></li>
<li class='green'><span class='hits'>842</span><code>                !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>842</span><code>                ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>842</span><code>                return ds.aliasedExpressionSql(this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>).as(sql, "AliasedExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var CaseExpression = define(GenericExpression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.CaseExpression.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Create an object with the given conditions and</code></li>
<li class='green'><span class=''> </span><code>         * default value.  An expression can be provided to</code></li>
<li class='green'><span class=''> </span><code>         * test each condition against, instead of having</code></li>
<li class='green'><span class=''> </span><code>         * all conditions represent their own boolean expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         * @param {Array|Object} conditions conditions to create the case expression from</code></li>
<li class='green'><span class=''> </span><code>         * @param def default value</code></li>
<li class='green'><span class=''> </span><code>         * @param expression expression to create the CASE expression from</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {Boolean} hasExpression returns true if this case expression has a expression</code></li>
<li class='green'><span class=''> </span><code>         * @property conditions the conditions of the {@link patio.sql.CaseExpression}.</code></li>
<li class='green'><span class=''> </span><code>         * @property def the default value of the {@link patio.sql.CaseExpression}.</code></li>
<li class='green'><span class=''> </span><code>         * @property expression the expression of the {@link patio.sql.CaseExpression}.</code></li>
<li class='green'><span class=''> </span><code>         * @property {Boolean} noExpression true if this {@link patio.sql.CaseExpression}'s expression is undefined.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (conditions, def, expression) {</code></li>
<li class='green'><span class='hits'>8</span><code>            if (Expression.isConditionSpecifier(conditions)) {</code></li>
<li class='green'><span class='hits'>4</span><code>                this.conditions = toArray(conditions);</code></li>
<li class='green'><span class='hits'>4</span><code>                this.def = def;</code></li>
<li class='green'><span class='hits'>4</span><code>                this.expression = expression;</code></li>
<li class='green'><span class='hits'>4</span><code>                this.noExpression = isUndefined(expression);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the case expression to a string</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL case expression fragment.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>2</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>2</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>2</span><code>            return ds.caseExpressionSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            hasExpression:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                return !this.noExpression;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "CaseExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Cast = define(GenericExpression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.Cast*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents a cast of an SQL expression to a specific type.</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param expr the expression to CAST.</code></li>
<li class='green'><span class=''> </span><code>         * @param type the  type to CAST the expression to.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property expr the expression to CAST.</code></li>
<li class='green'><span class=''> </span><code>         * @property type the  type to CAST the expression to.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (expr, type) {</code></li>
<li class='green'><span class='hits'>3</span><code>            this.expr = expr;</code></li>
<li class='green'><span class='hits'>3</span><code>            this.type = type;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the cast expression to a string</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL cast expression fragment.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>2</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>2</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>2</span><code>            return ds.castSql(this.expr, this.type);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "Cast");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var ColumnAll = define(Expression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.ColumnAll.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents all columns in a given table, table.* in SQL</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.Expression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param table the table this expression is for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property table the table this all column expression represents.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (table) {</code></li>
<li class='green'><span class='hits'>20</span><code>            this.table = table;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the ColumnAll expression to a string</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL columnAll expression fragment.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>19</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>19</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>19</span><code>            return ds.columnAllSql(this);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "ColumnAll");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var ComplexExpression = define([Expression, AliasMethods, CastMethods, OrderedMethods, SubscriptMethods], {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.ComplexExpression.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents a complex SQL expression, with a given operator and one</code></li>
<li class='green'><span class=''> </span><code>         * or more attributes (which may also be ComplexExpressions, forming</code></li>
<li class='green'><span class=''> </span><code>         * a tree).</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * This is an abstract class that is not that useful by itself.  The</code></li>
<li class='green'><span class=''> </span><code>         * subclasses @link patio.sql.BooleanExpression},</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.sql.NumericExpression} and {@link patio.sql.StringExpression} should</code></li>
<li class='green'><span class=''> </span><code>         * be used instead of this class directly.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.Expression</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.AliasMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.CastMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.OrderedMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.SubscriptMethods</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.sql.ExpressionError} if the operator doesn't allow boolean input and a boolean argument is given.</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.sql.ExpressionError} if the wrong number of arguments for a given operator is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {...} op The operator and arguments for this object to the ones given.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     Convert all args that are hashes or arrays of two element arrays to {@link patio.sql.BooleanExpression}s,</code></li>
<li class='green'><span class=''> </span><code>         *          other than the second arg for an IN/NOT IN operator.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (op) {</code></li>
<li class='green'><span class='hits'>7723</span><code>            if (op) {</code></li>
<li class='green'><span class='hits'>6968</span><code>                var args = argsToArray(arguments,1 );</code></li>
<li class='green'><span class=''> </span><code>                //make a copy of the args</code></li>
<li class='green'><span class='hits'>6968</span><code>                var origArgs = args.slice(0);</code></li>
<li class='green'><span class='hits'>6968</span><code>                args.forEach(function (a, i) {</code></li>
<li class='green'><span class='hits'>14152</span><code>                    if (Expression.isConditionSpecifier(a)) {</code></li>
<li class='green'><span class='hits'>6</span><code>                        args[i] = BooleanExpression.fromValuePairs(a);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>6968</span><code>                op = op.toUpperCase();</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>6968</span><code>                if (N_ARITY_OPERATORS.hasOwnProperty(op)) {</code></li>
<li class='green'><span class='hits'>1132</span><code>                    if (args.length &lt; 1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        throw new ExpressionError("The " + op + " operator requires at least 1 argument")</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1132</span><code>                    var oldArgs = args.slice(0);</code></li>
<li class='green'><span class='hits'>1132</span><code>                    args = [];</code></li>
<li class='green'><span class='hits'>1132</span><code>                    oldArgs.forEach(function (a) {</code></li>
<li class='green'><span class='hits'>2543</span><code>                        a instanceof ComplexExpression &amp;&amp; a.op == op ? args = args.concat(a.args) : args.push(a);</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>5836</span><code>                } else if (TWO_ARITY_OPERATORS.hasOwnProperty(op)) {</code></li>
<li class='green'><span class='hits'>5773</span><code>                    if (args.length != 2) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        throw new ExpressionError("The " + op + " operator requires precisely 2 arguments");</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                    //With IN/NOT IN, even if the second argument is an array of two element arrays,</code></li>
<li class='green'><span class=''> </span><code>                    //don't convert it into a boolean expression, since it's definitely being used</code></li>
<li class='green'><span class=''> </span><code>                    //as a value list.</code></li>
<li class='green'><span class='hits'>5773</span><code>                    if (IN_OPERATORS[op]) {</code></li>
<li class='green'><span class='hits'>23</span><code>                        args[1] = origArgs[1]</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>63</span><code>                } else if (ONE_ARITY_OPERATORS.hasOwnProperty(op)) {</code></li>
<li class='green'><span class='hits'>63</span><code>                    if (args.length != 1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        throw new ExpressionError("The " + op + " operator requires only one argument");</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new ExpressionError("Invalid operator " + op);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>6968</span><code>                this.op = op;</code></li>
<li class='green'><span class='hits'>6968</span><code>                this.args = args;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the ComplexExpression to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.ComplexExpression}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>6565</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>6565</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>6565</span><code>            return ds.complexExpressionSql(this.op, this.args);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.ComplexExpression*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Hash of operator inversions</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {</code></li>
<li class='green'><span class=''> </span><code>         *      AND:"OR",</code></li>
<li class='green'><span class=''> </span><code>         *      OR:"AND",</code></li>
<li class='green'><span class=''> </span><code>         *      GT:"lte",</code></li>
<li class='green'><span class=''> </span><code>         *      GTE:"lt",</code></li>
<li class='green'><span class=''> </span><code>         *      LT:"gte",</code></li>
<li class='green'><span class=''> </span><code>         *      LTE:"gt",</code></li>
<li class='green'><span class=''> </span><code>         *      EQ:"neq",</code></li>
<li class='green'><span class=''> </span><code>         *      NEQ:"eq",</code></li>
<li class='green'><span class=''> </span><code>         *      LIKE:'NOT LIKE',</code></li>
<li class='green'><span class=''> </span><code>         *      "NOT LIKE":"LIKE",</code></li>
<li class='green'><span class=''> </span><code>         *      '!~*':'~*',</code></li>
<li class='green'><span class=''> </span><code>         *      '~*':'!~*',</code></li>
<li class='green'><span class=''> </span><code>         *      "~":'!~',</code></li>
<li class='green'><span class=''> </span><code>         *      "IN":'NOTIN',</code></li>
<li class='green'><span class=''> </span><code>         *      "NOTIN":"IN",</code></li>
<li class='green'><span class=''> </span><code>         *      "IS":'IS NOT',</code></li>
<li class='green'><span class=''> </span><code>         *      "ISNOT":"IS",</code></li>
<li class='green'><span class=''> </span><code>         *      NOT:"NOOP",</code></li>
<li class='green'><span class=''> </span><code>         *      NOOP:"NOT",</code></li>
<li class='green'><span class=''> </span><code>         *      ILIKE:'NOT ILIKE',</code></li>
<li class='green'><span class=''> </span><code>         *      NOTILIKE:"ILIKE"</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        OPERATOR_INVERSIONS:OPERTATOR_INVERSIONS,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default mathematical operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {PLUS:"+", MINUS:"-", DIVIDE:"/", MULTIPLY:"*"}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        MATHEMATICAL_OPERATORS:MATHEMATICAL_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default bitwise operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {bitWiseAnd:"&amp;", bitWiseOr:"|", exclusiveOr:"^", leftShift:"&lt;&lt;", rightShift:"&gt;&gt;"}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        BITWISE_OPERATORS:BITWISE_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default inequality operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {GT:"&gt;",GTE:"&gt;=",LT:"&lt;",LTE:"&lt;="}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        INEQUALITY_OPERATORS:INEQUALITY_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default boolean operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {AND:"AND",OR:"OR"}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        BOOLEAN_OPERATORS:BOOLEAN_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default IN operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {IN:"IN",NOTIN:'NOT IN'}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        IN_OPERATORS:IN_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default IS operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {IS:"IS", ISNOT:'IS NOT'}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        IS_OPERATORS:IS_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default two arity operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {</code></li>
<li class='green'><span class=''> </span><code>         *      EQ:'=',</code></li>
<li class='green'><span class=''> </span><code>         *      NEQ:'!=', LIKE:"LIKE",</code></li>
<li class='green'><span class=''> </span><code>         *      "NOT LIKE":'NOT LIKE',</code></li>
<li class='green'><span class=''> </span><code>         *      ILIKE:"ILIKE",</code></li>
<li class='green'><span class=''> </span><code>         *      "NOT ILIKE":'NOT ILIKE',</code></li>
<li class='green'><span class=''> </span><code>         *      "~":"~",</code></li>
<li class='green'><span class=''> </span><code>         *      '!~':"!~",</code></li>
<li class='green'><span class=''> </span><code>         *      '~*':"~*",</code></li>
<li class='green'><span class=''> </span><code>         *      '!~*':"!~*",</code></li>
<li class='green'><span class=''> </span><code>         *      GT:"&gt;",</code></li>
<li class='green'><span class=''> </span><code>         *      GTE:"&gt;=",</code></li>
<li class='green'><span class=''> </span><code>         *      LT:"&lt;",</code></li>
<li class='green'><span class=''> </span><code>         *      LTE:"&lt;=",</code></li>
<li class='green'><span class=''> </span><code>         *      bitWiseAnd:"&amp;",</code></li>
<li class='green'><span class=''> </span><code>         *      bitWiseOr:"|",</code></li>
<li class='green'><span class=''> </span><code>         *      exclusiveOr:"^",</code></li>
<li class='green'><span class=''> </span><code>         *      leftShift:"&lt;&lt;",</code></li>
<li class='green'><span class=''> </span><code>         *      rightShift:"&gt;&gt;",</code></li>
<li class='green'><span class=''> </span><code>         *      IS:"IS",</code></li>
<li class='green'><span class=''> </span><code>         *      ISNOT:'IS NOT',</code></li>
<li class='green'><span class=''> </span><code>         *      IN:"IN",</code></li>
<li class='green'><span class=''> </span><code>         *      NOTIN:'NOT IN'</code></li>
<li class='green'><span class=''> </span><code>         *  }</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        TWO_ARITY_OPERATORS:TWO_ARITY_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default N(multi) arity operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {</code></li>
<li class='green'><span class=''> </span><code>         *      "||":"||",</code></li>
<li class='green'><span class=''> </span><code>         *      AND:"AND",</code></li>
<li class='green'><span class=''> </span><code>         *      OR:"OR",</code></li>
<li class='green'><span class=''> </span><code>         *      PLUS:"+",</code></li>
<li class='green'><span class=''> </span><code>         *      MINUS:"-",</code></li>
<li class='green'><span class=''> </span><code>         *      DIVIDE:"/", MULTIPLY:"*"</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        N_ARITY_OPERATORS:N_ARITY_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default ONE operators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {</code></li>
<li class='green'><span class=''> </span><code>         *      "NOT":"NOT",</code></li>
<li class='green'><span class=''> </span><code>         *      "NOOP":"NOOP"</code></li>
<li class='green'><span class=''> </span><code>         *  }</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ONE_ARITY_OPERATORS:ONE_ARITY_OPERATORS</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "ComplexExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Subclass of {@link patio.sql.ComplexExpression} where the expression results</code></li>
<li class='green'><span class=''> </span><code> * in a boolean value in SQL.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.ComplexExpression</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.BooleanMethods</code></li>
<li class='green'><span class=''> </span><code> * @name BooleanExpression</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var BooleanExpression = define([ComplexExpression, BooleanMethods], {</code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.BooleanExpression*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Invert the expression, if possible.  If the expression cannot</code></li>
<li class='green'><span class=''> </span><code>         * be inverted, it throws an {@link patio.error.ExpressionError}.  An inverted expression should match</code></li>
<li class='green'><span class=''> </span><code>         * everything that the uninverted expression did not match, and vice-versa, except for possible issues with</code></li>
<li class='green'><span class=''> </span><code>         * SQL NULL (i.e. 1 == NULL is NULL and 1 != NULL is also NULL).</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   BooleanExpression.invert(sql.a) //=&gt; NOT "a"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.sql.BooleanExpression} expression</code></li>
<li class='green'><span class=''> </span><code>         * the expression to invert.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} the inverted expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        invert:function (expression) {</code></li>
<li class='green'><span class='hits'>95</span><code>            if (isInstanceOf(expression, BooleanExpression)) {</code></li>
<li class='green'><span class='hits'>90</span><code>                var op = expression.op, newArgs;</code></li>
<li class='green'><span class='hits'>90</span><code>                if (op == "AND" || op == "OR") {</code></li>
<li class='green'><span class='hits'>3</span><code>                    newArgs = [OPERTATOR_INVERSIONS[op]].concat(expression.args.map(function (arg) {</code></li>
<li class='green'><span class='hits'>6</span><code>                        return BooleanExpression.invert(arg);</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class='hits'>3</span><code>                    return BooleanExpression.fromArgs(newArgs);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>87</span><code>                    newArgs = [OPERTATOR_INVERSIONS[op]].concat(expression.args);</code></li>
<li class='green'><span class='hits'>87</span><code>                    return BooleanExpression.fromArgs(newArgs);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>5</span><code>            } else if (isInstanceOf(expression, StringExpression) || isInstanceOf(expression, NumericExpression)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ExpressionError(format("Cannot invert %4j", [expression]));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>5</span><code>                return new BooleanExpression("NOT", expression);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Take pairs of values (e.g. a hash or array of two element arrays)</code></li>
<li class='green'><span class=''> </span><code>         * and converts it to a {@link patio.sql.BooleanExpression}.  The operator and args</code></li>
<li class='green'><span class=''> </span><code>         * used depends on the case of the right (2nd) argument:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class='code'&gt;</code></li>
<li class='green'><span class=''> </span><code>         * BooleanExpression.fromValuePairs({a : [1,2,3]}) //=&gt; a IN (1,2,3)</code></li>
<li class='green'><span class=''> </span><code>         * BooleanExpression.fromValuePairs({a : true}); // a IS TRUE;</code></li>
<li class='green'><span class=''> </span><code>         * BooleanExpression.fromValuePairs({a : /^A/i}); // a *~ '^A'</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If multiple arguments are given, they are joined with the op given (AND</code></li>
<li class='green'><span class=''> </span><code>         * by default, OR possible).  If negate is set to true,</code></li>
<li class='green'><span class=''> </span><code>         * all subexpressions are inverted before used.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class='code'&gt;</code></li>
<li class='green'><span class=''> </span><code>         * BooleanExpression.fromValuePairs({a : [1,2,3], b : true}) //=&gt; a IN (1,2,3) AND b IS TRUE</code></li>
<li class='green'><span class=''> </span><code>         * BooleanExpression.fromValuePairs({a : [1,2,3], b : true}, "OR") //=&gt; a IN (1,2,3) OR b IS TRUE</code></li>
<li class='green'><span class=''> </span><code>         * BooleanExpression.fromValuePairs({a : [1,2,3], b : true}, "OR", true) //=&gt; a NOT IN (1,2,3) AND b IS NOT TRUE</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} a object to convert to a {@link patio.sql.BooleanExpression}</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [op="AND"] Boolean operator to join each subexpression with.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     BooleanExpression.fromValuePairs({a : [1,2,3], b : true}, "OR") //=&gt; a IN (1,2,3) OR b IS TRUE</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [negate=false] set to try to invert the {@link patio.sql.BooleanExpression}.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         * BooleanExpression.fromValuePairs({a : [1,2,3], b : true}, "OR", true) //=&gt; a NOT IN (1,2,3) AND b IS NOT TRUE</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} expression composed of sub expressions built from the hash.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fromValuePairs:function (a, op, negate) {</code></li>
<li class='green'><span class='hits'>7645</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>7645</span><code>            op = op || "AND", negate = negate || false;</code></li>
<li class='green'><span class='hits'>7645</span><code>            var pairArr = [];</code></li>
<li class='green'><span class='hits'>7645</span><code>            var isArr = isArray(a) &amp;&amp; Expression.isConditionSpecifier(a);</code></li>
<li class='green'><span class='hits'>7645</span><code>            if (isHash(a)) {</code></li>
<li class='green'><span class='hits'>3419</span><code>                pairArr.push(this.__filterObject(a));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>4226</span><code>                for (var k in a) {</code></li>
<li class='green'><span class='hits'>5039</span><code>                    var v = isArr ? a[k][1] : a[k], ret;</code></li>
<li class='green'><span class='hits'>5039</span><code>                    k = isArr ? a[k][0] : k;</code></li>
<li class='green'><span class='hits'>5039</span><code>                    if (isArray(v) || isInstanceOf(v, Dataset)) {</code></li>
<li class='green'><span class='hits'>17</span><code>                        k = isArray(k) ? k.map(function (i) {</code></li>
<li class='green'><span class='hits'>12</span><code>                            return isString(i) ? sql.stringToIdentifier(i) : i</code></li>
<li class='green'><span class=''> </span><code>                        }) : isString(k) ? sql.stringToIdentifier(k) : k;</code></li>
<li class='green'><span class='hits'>17</span><code>                        ret = new BooleanExpression("IN", k, v);</code></li>
<li class='green'><span class='hits'>5022</span><code>                    } else if (isInstanceOf(v, NegativeBooleanConstant)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret = new BooleanExpression("ISNOT", k, v.constant);</code></li>
<li class='green'><span class='hits'>5022</span><code>                    } else if (isInstanceOf(v, BooleanConstant)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret = new BooleanExpression("IS", k, v.constant);</code></li>
<li class='green'><span class='hits'>5022</span><code>                    } else if (isNull(v) || isBoolean(v)) {</code></li>
<li class='green'><span class='hits'>207</span><code>                        ret = new BooleanExpression("IS", k, v);</code></li>
<li class='green'><span class='hits'>4815</span><code>                    } else if (isHash(v)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret = BooleanExpression.__filterObject(v, k);</code></li>
<li class='green'><span class='hits'>4815</span><code>                    } else if (isRegExp(v)) {</code></li>
<li class='green'><span class='hits'>69</span><code>                        ret = StringExpression.like(sql.stringToIdentifier(k), v);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>4746</span><code>                        ret = new BooleanExpression("EQ", sql.stringToIdentifier(k), v);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>5039</span><code>                    negate &amp;&amp; (ret = BooleanExpression.invert(ret));</code></li>
<li class='green'><span class='hits'>5039</span><code>                    pairArr.push(ret);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>            //if We just have one then return the first otherwise create a new Boolean expression</code></li>
<li class='green'><span class='hits'>7645</span><code>            return pairArr.length == 1 ? pairArr[0] : BooleanExpression.fromArgs([op].concat(pairArr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * This builds an expression from a hash</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({a : 1}) //=&gt; WHERE (a = 1)</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({x : {gt : 1}}) //=&gt; WHERE (x &gt; 1)</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({x : {gt : 1}, a : 1}) //=&gt; WHERE ((x &gt; 1) AND (a = 1))</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({x : {like : "name"}}) //=&gt; WHERE (x LIKE 'name')</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({x : {iLike : "name"}}) //=&gt; WHERE (x LIKE 'name')</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({x : {between : [1,10]}}) //=&gt; WHERE ((x &gt;= 1) AND (x &lt;= 10))</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({x : {notBetween : [1,10]}}) //=&gt; WHERE ((x &lt; 1) OR (x &gt; 10))</code></li>
<li class='green'><span class=''> </span><code>         *  Dataset._filterObject({x : {neq : 1}}) //=&gt; WHERE (x != 1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} expr the expression we need to create an expression out of</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [key=null] the key that the hash corresponds to</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.Expression} an expression to use in the filter</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __filterObject:function (expr, key) {</code></li>
<li class='green'><span class='hits'>3536</span><code>            var pairs = [], opts, newKey;</code></li>
<li class='green'><span class='hits'>3536</span><code>            var twoArityOperators = this.TWO_ARITY_OPERATORS;</code></li>
<li class='green'><span class='hits'>3536</span><code>            for (var k in expr) {</code></li>
<li class='green'><span class='hits'>3575</span><code>                var v = expr[k];</code></li>
<li class='green'><span class='hits'>3575</span><code>                if (isHash(v)) { //its a hash too filter it too!</code></li>
<li class='green'><span class='hits'>115</span><code>                    pairs.push(this.__filterObject(v, k));</code></li>
<li class='green'><span class='hits'>3460</span><code>                } else if (key &amp;&amp; (twoArityOperators[k.toUpperCase()] || k.match(/between/i))) {</code></li>
<li class='green'><span class=''> </span><code>                    //its a two arrity operator (e.g. '=', '&gt;')</code></li>
<li class='green'><span class='hits'>118</span><code>                    newKey = isString(key) ? key.split(",") : [key];</code></li>
<li class='green'><span class='hits'>118</span><code>                    if (newKey.length &gt; 1) {</code></li>
<li class='green'><span class=''> </span><code>                        //this represents a hash where the key represents two columns</code></li>
<li class='green'><span class=''> </span><code>                        //(e.g. {"col1,col2" : 1}) =&gt; WHERE (col1 = 1 AND col2 = 1)</code></li>
<li class='green'><span class='hits'>1</span><code>                        pairs = pairs.concat(newKey.map(function (k) {</code></li>
<li class='green'><span class=''> </span><code>                            //filter each column with the expression</code></li>
<li class='green'><span class='hits'>2</span><code>                            return this.__filterObject(expr, k);</code></li>
<li class='green'><span class=''> </span><code>                        }, this));</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>117</span><code>                        newKey = [sql.stringToIdentifier(newKey[0])];</code></li>
<li class='green'><span class='hits'>117</span><code>                        if (k.match(/^like$/)) {</code></li>
<li class='green'><span class=''> </span><code>                            //its a like clause {col : {like : "hello"}}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>3</span><code>                            pairs.push(StringExpression.like.apply(StringExpression, (newKey.concat(isArray(v) ? v : [v]))));</code></li>
<li class='green'><span class='hits'>114</span><code>                        } else if (k.match(/^iLike$/)) {</code></li>
<li class='green'><span class=''> </span><code>                            //its a like clause {col : {iLike : "hello"}}</code></li>
<li class='green'><span class='hits'>2</span><code>                            pairs.push(StringExpression.like.apply(StringExpression, (newKey.concat(isArray(v) ? v : [v]).concat({caseInsensitive:true}))));</code></li>
<li class='green'><span class='hits'>112</span><code>                        } else if (k.match(/between/i)) {</code></li>
<li class='green'><span class=''> </span><code>                            //its a like clause {col : {between : [1,10]}}</code></li>
<li class='green'><span class='hits'>6</span><code>                            var between = sql.stringToIdentifier(newKey[0]).between(v);</code></li>
<li class='green'><span class='hits'>6</span><code>                            k == "notBetween" &amp;&amp; (between = between.not());</code></li>
<li class='green'><span class='hits'>6</span><code>                            pairs.push(between);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class=''> </span><code>                            //otherwise is just a boolean expressio</code></li>
<li class='green'><span class=''> </span><code>                            //it its not a valid operator then we</code></li>
<li class='green'><span class=''> </span><code>                            //BooleanExpression with throw an error</code></li>
<li class='green'><span class='hits'>106</span><code>                            pairs.push(new BooleanExpression(k, newKey[0], v));</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class=''> </span><code>                    //we're not a twoarity operator</code></li>
<li class='green'><span class=''> </span><code>                    //so we create a boolean expression out of it</code></li>
<li class='green'><span class='hits'>3342</span><code>                    newKey = k.split(",");</code></li>
<li class='green'><span class='hits'>3342</span><code>                    if (newKey.length == 1) {</code></li>
<li class='green'><span class='hits'>3336</span><code>                        newKey = sql.stringToIdentifier(newKey[0]);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>3342</span><code>                    opts = [</code></li>
<li class='green'><span class=''> </span><code>                        [newKey, v]</code></li>
<li class='green'><span class=''> </span><code>                    ];</code></li>
<li class='green'><span class='hits'>3342</span><code>                    pairs.push(BooleanExpression.fromValuePairs(opts));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>            //if the total of pairs is one then we just return the first element</code></li>
<li class='green'><span class=''> </span><code>            //otherwise we join them all with an AND</code></li>
<li class='green'><span class='hits'>3536</span><code>            return pairs.length == 1 ? pairs[0] : BooleanExpression.fromArgs(["AND"].concat(pairs));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "BooleanExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Constant = define(GenericExpression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.Constant.prototype*/</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents constants or psuedo-constants (e.g.'CURRENT_DATE) in SQL.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} constant &lt;b&gt;READ ONLY&lt;/b&gt; the contant.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (constant) {</code></li>
<li class='green'><span class='hits'>18</span><code>            this.__constant = constant;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.Constant} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.Constant}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>6</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>6</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>6</span><code>            return ds.constantSql(this.__constant);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            constant:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__constant;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "Constant");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Represents boolean constants such as NULL, NOTNULL, TRUE, and FALSE.</code></li>
<li class='green'><span class=''> </span><code> * @auments patio.sql.Constant</code></li>
<li class='green'><span class=''> </span><code> * @name BooleanConstant</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var BooleanConstant = define(Constant, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.BooleanConstant.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.BooleanConstant} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.BooleanConstant}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>10</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>10</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>10</span><code>            return ds.booleanConstantSql(this.__constant);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "BooleanConstant");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * Represents inverse boolean constants (currently only NOTNULL). A</code></li>
<li class='green'><span class=''> </span><code> * special class to allow for special behavior.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.BooleanConstant</code></li>
<li class='green'><span class=''> </span><code> * @name NegativeBooleanConstant</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var NegativeBooleanConstant = define(BooleanConstant, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.NegativeBooleanConstant.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.NegativeBooleanConstant} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.NegativeBooleanConstant}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>2</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>2</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>2</span><code>            return ds.negativeBooleanConstantSql(this.__constant);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "NegativeBooleanConstant");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @namespace Holds default generic constants that can be referenced.  These</code></li>
<li class='green'><span class=''> </span><code> * are included in {@link patio}</code></li>
<li class='green'><span class=''> </span><code> * @name Constants</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>sql.Constants = {</code></li>
<li class='green'><span class=''> </span><code>    /**@lends patio.sql.Constants*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for CURRENT DATE</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.Constant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    CURRENT_DATE:new Constant("CURRENT_DATE"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for CURRENT TIME</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.Constant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    CURRENT_TIME:new Constant("CURRENT_TIME"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for CURRENT TIMESTAMP</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.Constant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    CURRENT_TIMESTAMP:new Constant("CURRENT_TIMESTAMP"),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for TRUE</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.BooleanConstant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    SQLTRUE:new BooleanConstant(1),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for TRUE</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.BooleanConstant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    TRUE:new BooleanConstant(1),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for FALSE.</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.BooleanConstant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    SQLFALSE:new BooleanConstant(0),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for FALSE</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.BooleanConstant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    FALSE:new BooleanConstant(0),</code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for NULL</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.BooleanConstant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    NULL:new BooleanConstant(null),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    /**</code></li>
<li class='green'><span class=''> </span><code>     * Constant for NOT NULL</code></li>
<li class='green'><span class=''> </span><code>     * @type patio.sql.NegativeBooleanConstant</code></li>
<li class='green'><span class=''> </span><code>     */</code></li>
<li class='green'><span class=''> </span><code>    NOTNULL:new NegativeBooleanConstant(null)</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Constants = sql.Constants</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Identifier = define([GenericExpression, QualifyingMethods], {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.Identifier.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents an identifier (column or table). Can be used</code></li>
<li class='green'><span class=''> </span><code>         * to specify a String with multiple underscores that should not be</code></li>
<li class='green'><span class=''> </span><code>         * split, or for creating an implicit identifier without using a String.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.QualifyingMethods</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String}value the identifier.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} value &lt;b&gt;READ ONLY&lt;/b&gt; the column or table this identifier represents.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (value) {</code></li>
<li class='green'><span class='hits'>16572</span><code>            this.__value = value;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.Identifier} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.Identifier}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>21953</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>21953</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>21953</span><code>            return ds.quoteIdentifier(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            value:function () {</code></li>
<li class='green'><span class='hits'>25183</span><code>                return this.__value;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "Identifier");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var JoinClause = define(Expression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.JoinClause.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents an SQL JOIN clause, used for joining tables.</code></li>
<li class='green'><span class=''> </span><code>         * Created by {@link patio.Dataset} join methods.</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.Expression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} joinType the type of join this JoinClause should use</code></li>
<li class='green'><span class=''> </span><code>         * @param table the table to join with</code></li>
<li class='green'><span class=''> </span><code>         * @param tableAlias the alias to use for this join clause</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} joinType &lt;b&gt;READ ONLY&lt;/b&gt; the type of join this JoinClause should use</code></li>
<li class='green'><span class=''> </span><code>         * @property table &lt;b&gt;READ ONLY&lt;/b&gt; the table to join with</code></li>
<li class='green'><span class=''> </span><code>         * @property joinType &lt;b&gt;READ ONLY&lt;/b&gt; the alias to use for this join clause</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (joinType, table, tableAlias) {</code></li>
<li class='green'><span class='hits'>791</span><code>            this.__joinType = joinType;</code></li>
<li class='green'><span class='hits'>791</span><code>            this.__table = table;</code></li>
<li class='green'><span class='hits'>791</span><code>            this.__tableAlias = tableAlias || null;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.JoinClause} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.JoinClause}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>17</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>17</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>17</span><code>            return ds.joinClauseSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            joinType:function () {</code></li>
<li class='green'><span class='hits'>933</span><code>                return this.__joinType;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            table:function () {</code></li>
<li class='green'><span class='hits'>934</span><code>                return this.__table;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            tableAlias:function () {</code></li>
<li class='green'><span class='hits'>932</span><code>                return this.__tableAlias;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "JoinClause");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var JoinOnClause = define(JoinClause, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.JoinOnClause.prototype*/</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents an SQL JOIN clause with ON conditions. Created by {@link patio.Dataset} join methods.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.sql.JoinClause} for other argument parameters.</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.JoinClause</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param on the expression to filter with. See {@link patio.Dataset#filter}</code></li>
<li class='green'><span class=''> </span><code>         * @property on &lt;b&gt;READ ONLY&lt;/b&gt; the filter to use with joining the datasets.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (on, joinType, table, tableAlias) {</code></li>
<li class='green'><span class='hits'>761</span><code>            this.__on = on;</code></li>
<li class='green'><span class='hits'>761</span><code>            this._super(arguments, [joinType, table, tableAlias]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.JoinOnClause} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.JoinOnClause}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>813</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>813</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>813</span><code>            return ds.joinOnClauseSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            on:function () {</code></li>
<li class='green'><span class='hits'>813</span><code>                return this.__on;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "JoinOnClause");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var JoinUsingClause = define(JoinClause, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.JoinUsingClause.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents an SQL JOIN clause with USING conditions.</code></li>
<li class='green'><span class=''> </span><code>         * Created by {@link patio.Dataset} join methods.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.sql.JoinClause} for other argument parameters.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.JoinClause</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param using the column/s to use when joining.</code></li>
<li class='green'><span class=''> </span><code>         * @property using &lt;b&gt;READ ONLY&lt;/b&gt; the column/s to use when joining.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (using, joinType, table, tableAlias) {</code></li>
<li class='green'><span class='hits'>8</span><code>            this.__using = using.map(function (u) {</code></li>
<li class='green'><span class='hits'>9</span><code>                return isString(u) ? new Identifier(u) : u;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>8</span><code>            this._super(arguments, [joinType, table, tableAlias]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.JoinUsingClause} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.JoinUsingClause}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>101</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>101</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>101</span><code>            return ds.joinUsingClauseSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            using:function () {</code></li>
<li class='green'><span class='hits'>101</span><code>                return this.__using;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "JoinUsingClause");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var PlaceHolderLiteralString = define(GenericExpression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.PlaceHolderLiteralString.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents a literal string with placeholders and arguments.</code></li>
<li class='green'><span class=''> </span><code>         * This is necessary to ensure delayed literalization of the arguments</code></li>
<li class='green'><span class=''> </span><code>         * required for the prepared statement support and for database-specific</code></li>
<li class='green'><span class=''> </span><code>         * literalization.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} str the string that contains placeholders.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Array} args array of arguments that will be literalized using {@link patio.Dataset#literal}, and</code></li>
<li class='green'><span class=''> </span><code>         * replaced in the string.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [parens=false] set to true to wrap the string in parens.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} str &lt;b&gt;READ ONLY&lt;/b&gt; the string that contains placeholders.</code></li>
<li class='green'><span class=''> </span><code>         * @property {Array} args &lt;b&gt;READ ONLY&lt;/b&gt; array of arguments that will be literalized using {@link patio.Dataset#literal}, and</code></li>
<li class='green'><span class=''> </span><code>         * replaced in the string.</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} parens &lt;b&gt;READ ONLY&lt;/b&gt; set to true to wrap the string in parens.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (str, args, parens) {</code></li>
<li class='green'><span class='hits'>55</span><code>            parens = parens || false;</code></li>
<li class='green'><span class='hits'>55</span><code>            var v;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.__str = str;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.__args = isArray(args) &amp;&amp; args.length == 1 &amp;&amp; isHash((v = args[0])) ? v : args;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.__parens = parens;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.PlaceHolderLiteralString} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.PlaceHolderLiteralString}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>55</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>55</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>55</span><code>            return ds.placeholderLiteralStringSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            str:function () {</code></li>
<li class='green'><span class='hits'>58</span><code>                return this.__str;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            args:function () {</code></li>
<li class='green'><span class='hits'>58</span><code>                return this.__args;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            parens:function () {</code></li>
<li class='green'><span class='hits'>58</span><code>                return this.__parens;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "PlaceHolderLiteralString");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var SQLFunction = define(GenericExpression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.SQLFunction.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents an SQL function call.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {...} f variable number of arguments where the first argument is the name</code></li>
<li class='green'><span class=''> </span><code>         * of the SQL function to invoke. The rest of the arguments will be literalized through</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.Dataset#literal} and placed into the SQL function call.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} f &lt;b&gt;READ ONLY&lt;/b&gt; the SQL function to call.</code></li>
<li class='green'><span class=''> </span><code>         * @property {Array} args &lt;b&gt;READ ONLY&lt;/b&gt; args  arguments will be literalized through</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.Dataset#literal} and placed into the SQL function call.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (f) {</code></li>
<li class='green'><span class='hits'>1109</span><code>            var args = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>1109</span><code>            this.__f = isInstanceOf(f, Identifier) ? f.value : f, this.__args = args.map(function (a) {</code></li>
<li class='green'><span class='hits'>773</span><code>                return isString(a) ? sql.stringToIdentifier(a) : a;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.SQLFunction} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.SQLFunction}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>565</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>565</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>565</span><code>            return ds.functionSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            f:function () {</code></li>
<li class='green'><span class='hits'>567</span><code>                return this.__f;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            args:function () {</code></li>
<li class='green'><span class='hits'>567</span><code>                return this.__args;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "SQLFunction");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Subclass of {@link patio.sql.ComplexExpression} where the expression results</code></li>
<li class='green'><span class=''> </span><code> * in a numeric value in SQL.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name NumericExpression</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.ComplexExpression</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.BitWiseMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.NumericMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.InequalityMethods</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var NumericExpression = define([ComplexExpression, BitWiseMethods, NumericMethods, InequalityMethods]).as(sql, "NumericExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var OrderedExpression = define(Expression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.OrderedExpression.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents a column/expression to order the result set by.</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.Expression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param expression the expression to order</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean}[descending=true] set to false to order ASC</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|Object} [opts=null] additional options</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;String: if value is "first" the null values will be first, if "last" then null values</code></li>
<li class='green'><span class=''> </span><code>         *     will be last&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;Object: will pull the nulls property off of the object use use the same rules as if it</code></li>
<li class='green'><span class=''> </span><code>         *     were a string&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @property expression &lt;b&gt;READ ONLY&lt;/b&gt; the expression to order.</code></li>
<li class='green'><span class=''> </span><code>         * @property {Boolean} [descending=true] &lt;b&gt;READ ONLY&lt;/b&gt; true if decending, false otherwise.</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} [nulls=null] if value is "first" the null values will be first, if "last" then null values</code></li>
<li class='green'><span class=''> </span><code>         *     will be last</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (expression, descending, opts) {</code></li>
<li class='green'><span class='hits'>92</span><code>            descending = isBoolean(descending) ? descending : true;</code></li>
<li class='green'><span class='hits'>92</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>92</span><code>            this.__expression = expression;</code></li>
<li class='green'><span class='hits'>92</span><code>            this.__descending = descending;</code></li>
<li class='green'><span class='hits'>92</span><code>            var nulls = isString(opts) ? opts : opts.nulls;</code></li>
<li class='green'><span class='hits'>92</span><code>            this.__nulls = isString(nulls) ? nulls.toLowerCase() : null;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.OrderedExpression} a copy that is ordered ASC</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        asc:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return new OrderedExpression(this.__expression, false, {nulls:this.__nulls});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.OrderedExpression} Return a copy that is ordered DESC</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        desc:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return new OrderedExpression(this.__expression, true, {nulls:this.__nulls});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * * @return {patio.sql.OrderedExpression} an inverted expression, changing ASC to DESC and NULLS FIRST to NULLS LAST.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        invert:function () {</code></li>
<li class='green'><span class='hits'>17</span><code>            return new OrderedExpression(this.__expression, !this.__descending, {nulls:this._static.INVERT_NULLS[this.__nulls] || this.__nulls});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.OrderedExpression} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.OrderedExpression}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>73</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>73</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>73</span><code>            return ds.orderedExpressionSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            expression:function () {</code></li>
<li class='green'><span class='hits'>75</span><code>                return this.__expression;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            descending:function () {</code></li>
<li class='green'><span class='hits'>75</span><code>                return this.__descending;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            nulls:function () {</code></li>
<li class='green'><span class='hits'>82</span><code>                return this.__nulls;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.OrderedExpression*/</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Hash that contains the inversions for "first" and "last".</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         * @default {first:"last", last:"first"}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        INVERT_NULLS:{first:"last", last:"first"}</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "OrderedExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var QualifiedIdentifier = define([GenericExpression, QualifyingMethods], {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.QualifiedIdentifier.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents a qualified identifier (column with table or table with schema).</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.QualifyingMethods</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param table the table or schema to qualify the column or table to.</code></li>
<li class='green'><span class=''> </span><code>         * @param column the column or table to qualify.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property table &lt;b&gt;READ ONLY&lt;/b&gt; the table or schema to qualify the column or table to.</code></li>
<li class='green'><span class=''> </span><code>         * @property column &lt;b&gt;READ ONLY&lt;/b&gt; he column or table to qualify.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (table, column) {</code></li>
<li class='green'><span class='hits'>4121</span><code>            this.__table = table;</code></li>
<li class='green'><span class='hits'>4121</span><code>            this.__column = column;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.QualifiedIdentifier} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.QualifiedIdentifier}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>4202</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>4202</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>4202</span><code>            return ds.qualifiedIdentifierSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            table:function () {</code></li>
<li class='green'><span class='hits'>4224</span><code>                return this.__table;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            column:function () {</code></li>
<li class='green'><span class='hits'>4229</span><code>                return this.__column;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "QualifiedIdentifier");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var likeElement = function (re) {</code></li>
<li class='green'><span class='hits'>875</span><code>    var ret;</code></li>
<li class='green'><span class='hits'>875</span><code>    if (isRegExp(re)) {</code></li>
<li class='green'><span class='hits'>80</span><code>        ret = [("" + re).replace(/^\/|\/$|\/[i|m|g]*$/g, ""), true, re.ignoreCase]</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='green'><span class='hits'>795</span><code>        ret = [re, false, false];</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>875</span><code>    return ret;</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Subclass of {@link patio.sql.ComplexExpression} where the expression results</code></li>
<li class='green'><span class=''> </span><code> * in a text/string/varchar value in SQL.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.ComplexExpression</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.StringMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.StringConcatenationMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.InequalityMethods</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.sql.NoBooleanInputMethods</code></li>
<li class='green'><span class=''> </span><code> * @name StringExpression</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.sql</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var StringExpression = define([ComplexExpression, StringMethods, StringConcatenationMethods, InequalityMethods, NoBooleanInputMethods], {</code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.StringExpression*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;Creates a SQL pattern match expression. left (l) is the SQL string we</code></li>
<li class='green'><span class=''> </span><code>         * are matching against, and ces are the patterns we are matching.</code></li>
<li class='green'><span class=''> </span><code>         * The match succeeds if any of the patterns match (SQL OR).&lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;If a regular expression is used as a pattern, an SQL regular expression will be</code></li>
<li class='green'><span class=''> </span><code>         * used, which is currently only supported on MySQL and PostgreSQL.  Be aware</code></li>
<li class='green'><span class=''> </span><code>         * that MySQL and PostgreSQL regular expression syntax is similar to javascript</code></li>
<li class='green'><span class=''> </span><code>         * regular expression syntax, but it not exactly the same, especially for</code></li>
<li class='green'><span class=''> </span><code>         * advanced regular expression features.  Patio just uses the source of the</code></li>
<li class='green'><span class=''> </span><code>         * regular expression verbatim as the SQL regular expression string.&lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;If any other object is used as a regular expression, the SQL LIKE operator will</code></li>
<li class='green'><span class=''> </span><code>         * be used, and should be supported by most databases.&lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;The pattern match will be case insensitive if the last argument is a hash</code></li>
<li class='green'><span class=''> </span><code>         * with a key of caseInsensitive that is not false or null. Also,</code></li>
<li class='green'><span class=''> </span><code>         * if a case insensitive regular expression is used (//i), that particular</code></li>
<li class='green'><span class=''> </span><code>         * pattern which will always be case insensitive.&lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   StringExpression.like(sql.a, 'a%') //=&gt; "a" LIKE 'a%'</code></li>
<li class='green'><span class=''> </span><code>         *   StringExpression.like(sql.a, 'a%', {caseInsensitive : true}) //=&gt; "a" ILIKE 'a%'</code></li>
<li class='green'><span class=''> </span><code>         *   StringExpression.like(sql.a, 'a%', /^a/i) //=&gt; "a" LIKE 'a%' OR "a" ~* '^a'</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        like:function (l) {</code></li>
<li class='green'><span class='hits'>437</span><code>            var args = argsToArray(arguments, 1);</code></li>
<li class='green'><span class='hits'>437</span><code>            var params = likeElement(l);</code></li>
<li class='green'><span class='hits'>437</span><code>            var likeMap = this.likeMap;</code></li>
<li class='green'><span class='hits'>437</span><code>            var lh = params[0], lre = params[1], lci = params[2];</code></li>
<li class='green'><span class='hits'>437</span><code>            var last = args[args.length - 1];</code></li>
<li class='green'><span class='hits'>437</span><code>            lci = (isHash(last) ? args.pop() : {})["caseInsensitive"] ? true : lci;</code></li>
<li class='green'><span class='hits'>437</span><code>            args = args.map(function (ce) {</code></li>
<li class='green'><span class='hits'>438</span><code>                var r, rre, rci;</code></li>
<li class='green'><span class='hits'>438</span><code>                var ceArr = likeElement(ce);</code></li>
<li class='green'><span class='hits'>438</span><code>                r = ceArr[0], rre = ceArr[1], rci = ceArr[2];</code></li>
<li class='green'><span class='hits'>438</span><code>                return new BooleanExpression(likeMap["" + (lre || rre) + (lci || rci)], l, r)</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>437</span><code>            return args.length == 1 ? args[0] : BooleanExpression.fromArgs(["OR"].concat(args));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Like map used to by {@link patio.sql.StringExpression.like} to create the</code></li>
<li class='green'><span class=''> </span><code>         * LIKE expression.</code></li>
<li class='green'><span class=''> </span><code>         * @type Object</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        likeMap:{"truetrue":'~*', "truefalse":"~", "falsetrue":"ILIKE", "falsefalse":"LIKE"}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "StringExpression");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var SubScript = define(GenericExpression, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.SubScript.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents an SQL array access, with multiple possible arguments.</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.GenericExpression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param arrCol the SQL array column</code></li>
<li class='green'><span class=''> </span><code>         * @param sub The array of subscripts to use (should be an array of numbers)</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (arrCol, sub) {</code></li>
<li class='green'><span class=''> </span><code>            //The SQL array column</code></li>
<li class='green'><span class='hits'>76</span><code>            this.__arrCol = arrCol;</code></li>
<li class='green'><span class=''> </span><code>            //The array of subscripts to use (should be an array of numbers)</code></li>
<li class='green'><span class='hits'>76</span><code>            this.__sub = sub;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Create a new {@link patio.sql.Subscript} appending the given subscript(s)</code></li>
<li class='green'><span class=''> </span><code>         * the the current array of subscripts.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        addSub:function (sub) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return new SubScript(this.__arrCol, this.__sub.concat(sub));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts the {@link patio.sql.SubScript} to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} [ds] dataset used to created the SQL fragment, if</code></li>
<li class='green'><span class=''> </span><code>         * the dataset is ommited then the default {@link patio.Dataset} implementation is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return String the SQL version of the {@link patio.sql.SubScript}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toString:function (ds) {</code></li>
<li class='green'><span class='hits'>76</span><code>            !Dataset &amp;&amp; (Dataset = require("./dataset"));</code></li>
<li class='green'><span class='hits'>76</span><code>            ds = ds || new Dataset();</code></li>
<li class='green'><span class='hits'>76</span><code>            return ds.subscriptSql(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            f:function () {</code></li>
<li class='green'><span class='hits'>77</span><code>                return this.__arrCol;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            sub:function () {</code></li>
<li class='green'><span class='hits'>77</span><code>                return this.__sub;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "SubScript");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var STRING_METHODS = ["charAt", "charCodeAt", "concat", "indexOf", "lastIndexOf", "localeCompare", "match", "quote",</code></li>
<li class='green'><span class=''> </span><code>    "replace", "search", "slice", "split", "substr", "substring", "toLocaleLowerCase", "toLocaleUpperCase", "toLowerCase",</code></li>
<li class='green'><span class=''> </span><code>    "toSource", "toString", "toUpperCase", "trim", "trimLeft", "trimRight", "valueOf"];</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var addStringMethod = function (op) {</code></li>
<li class='green'><span class='hits'>24</span><code>    return function () {</code></li>
<li class='green'><span class='hits'>4356</span><code>        return this.__str[op].apply(this.__str, arguments);</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var LiteralString = define([OrderedMethods, ComplexExpressionMethods, BooleanMethods, NumericMethods, StringMethods, InequalityMethods, AliasMethods], {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.sql.LiteralString*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Represents a string that should be placed into a SQL query literally.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;This class has all methods that a normal javascript String has.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.OrderedMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.ComplexExpressionMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.BooleanMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.NumericMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.StringMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.InequalityMethods</code></li>
<li class='green'><span class=''> </span><code>         * @augments patio.sql.AliasMethods</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} str the literal string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (str) {</code></li>
<li class='green'><span class='hits'>3410</span><code>            this.__str = str;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(sql, "LiteralString");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>STRING_METHODS.forEach(function (op) {</code></li>
<li class='green'><span class='hits'>24</span><code>    LiteralString.prototype[op] = addStringMethod(op);</code></li>
<li class='green'><span class=''> </span><code>}, this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="database/query.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/query.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>92.31</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>1004</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>273</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>21</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/query.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isPromiseLike = comb.isPromiseLike,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    Queue = comb.collections.Queue,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("../errors"),</code></li>
<li class='green'><span class=''> </span><code>    NotImplemented = errors.NotImplemented;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Database = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The method name to invoke on a connection. The method name</code></li>
<li class='green'><span class=''> </span><code>         * should be overrode by an adapter if the method to execute</code></li>
<li class='green'><span class=''> </span><code>         * a query is different for the adapter specific connection class.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        connectionExecuteMethod:"execute",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The &lt;b&gt;BEGIN&lt;/b&gt; SQL fragment used to signify the start of a transaciton.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SQL_BEGIN:'BEGIN',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The &lt;b&gt;COMMIT&lt;/b&gt; SQL fragment used to signify the end of a transaction and the final commit.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SQL_COMMIT:'COMMIT',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The &lt;b&gt;RELEASE SAVEPOINT&lt;/b&gt; SQL fragment used by trasactions when using save points.</code></li>
<li class='green'><span class=''> </span><code>         * The adapter should override this SQL fragment if the adapters SQL is different.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;This fragment will not be used if {@link patio.Database#supportsSavepoints} is false.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SQL_RELEASE_SAVEPOINT:'RELEASE SAVEPOINT autopoint_%d',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The &lt;b&gt;ROLLBACK&lt;/b&gt; SQL fragment used to rollback a database transaction.</code></li>
<li class='green'><span class=''> </span><code>         * This should be overrode by adapters if the SQL for the adapters</code></li>
<li class='green'><span class=''> </span><code>         * database is different.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SQL_ROLLBACK:'ROLLBACK',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The &lt;b&gt;ROLLBACK TO SAVEPOINT&lt;/b&gt; SQL fragment used to rollback a database transaction</code></li>
<li class='green'><span class=''> </span><code>         * to a particular save point.</code></li>
<li class='green'><span class=''> </span><code>         * This should be overrode by adapters if the SQL for the adapters</code></li>
<li class='green'><span class=''> </span><code>         * database is different.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;This fragment will not be used if {@link patio.Database#supportsSavepoints} is false.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SQL_ROLLBACK_TO_SAVEPOINT:'ROLLBACK TO SAVEPOINT autopoint_%d',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The &lt;b&gt;SAVEPOINT&lt;/b&gt; SQL fragment used for creating a save point in a</code></li>
<li class='green'><span class=''> </span><code>         * database transaction.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;This fragment will not be used if {@link patio.Database#supportsSavepoints} is false.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SQL_SAVEPOINT:'SAVEPOINT autopoint_%d',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Object containing different database transaction isolation levels.</code></li>
<li class='green'><span class=''> </span><code>         * This object is used to look up the proper SQL when starting a new transaction</code></li>
<li class='green'><span class=''> </span><code>         * and setting the isolation level in the options.</code></li>
<li class='green'><span class=''> </span><code>         * @field</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        TRANSACTION_ISOLATION_LEVELS:{</code></li>
<li class='green'><span class=''> </span><code>            uncommitted:'READ UNCOMMITTED',</code></li>
<li class='green'><span class=''> </span><code>            committed:'READ COMMITTED',</code></li>
<li class='green'><span class=''> </span><code>            repeatable:'REPEATABLE READ',</code></li>
<li class='green'><span class=''> </span><code>            serializable:'SERIALIZABLE'</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        POSTGRES_DEFAULT_RE:/^(?:B?('.*')::[^']+|\((-?\d+(?:\.\d+)?)\))$/,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        MSSQL_DEFAULT_RE:/^(?:\(N?('.*')\)|\(\((-?\d+(?:\.\d+)?)\)\))$/,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        MYSQL_TIMESTAMP_RE:/^CURRENT_(?:DATE|TIMESTAMP)?$/,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        STRING_DEFAULT_RE:/^'(.*)'$/,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        POSTGRES_TIME_PATTERN:"HH:mm:ss",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        POSTGRES_DATE_TIME_PATTERN:"yyyy-MM-dd HH:mm:ss.SSZ",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __transactions:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>122</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__transactions = [];</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__transactionQueue = new Queue();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Executes the given SQL on the database. This method should be implemented by adapters.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;This method should not be called directly by user code.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        execute:function (sql, options, cb, conn) {</code></li>
<li class='green'><span class='hits'>1</span><code>            throw new NotImplemented("execute should be implemented by adapter");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return a Promise that is resolved with an object containing index information.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     The keys are index names. Values are objects with two keys, columns and unique.  The value of columns</code></li>
<li class='green'><span class=''> </span><code>         *     is an array of column names.  The value of unique is true or false</code></li>
<li class='green'><span class=''> </span><code>         *     depending on if the index is unique.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;Should not include the primary key index, functional indexes, or partial indexes.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.indexes("artists").then(function(indexes){</code></li>
<li class='green'><span class=''> </span><code>         *     //e.g. indexes === {artists_name_ukey : {columns : [name], unique : true}};</code></li>
<li class='green'><span class=''> </span><code>         *   })</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        indexes:function (table, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            throw new NotImplemented("indexes should be overridden by adapters");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Proxy for {@link patio.Dataset#get}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        get:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            return this.dataset.get.apply(this.dataset, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         * //todo implement prepared statements</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Call the prepared statement with the given name with the given object</code></li>
<li class='green'><span class=''> </span><code>         * of arguments.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").filter({id : 1}).prepare("first", "sa");</code></li>
<li class='green'><span class=''> </span><code>         *   DB.call("sa") //=&gt; SELECT * FROM items WHERE id = 1</code></li>
<li class='green'><span class=''> </span><code>         *   */</code></li>
<li class='green'><span class=''> </span><code>        call:function (psName, hash) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            hash = hash || {};</code></li>
<li class='red'><span class='nohits'>0</span><code>            this.preparedStatements[psName](hash);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Method that should be used when submitting any DDL (Data DefinitionLanguage) SQL,</code></li>
<li class='green'><span class=''> </span><code>         * such as {@link patio.Database#createTable}. By default, calls {@link patio.Database#executeDui}.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;This method should not be called directly by user code.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        executeDdl:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>620</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>620</span><code>            return this.executeDui(sql, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Method that should be used when issuing a DELETE, UPDATE, or INSERT</code></li>
<li class='green'><span class=''> </span><code>         * statement.  By default, calls {@link patio.Database#execute}.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;This method should not be called directly by user code.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        executeDui:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>3144</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>3144</span><code>            return this.execute(sql, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Method that should be used when issuing a INSERT</code></li>
<li class='green'><span class=''> </span><code>         * statement.  By default, calls {@link patio.Database#executeDui}.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;This method should not be called directly by user code.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        executeInsert:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>1315</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>1315</span><code>            return this.executeDui(sql, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Runs the supplied SQL statement string on the database server..</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.run("SET some_server_variable = 42")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} sql the SQL to run.</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved with the result of the query.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        run:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>43</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>43</span><code>            return this.executeDdl(sql, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Parse the schema from the database.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.schema("artists").then(function(schema){</code></li>
<li class='green'><span class=''> </span><code>         *     //example schema</code></li>
<li class='green'><span class=''> </span><code>         *     {</code></li>
<li class='green'><span class=''> </span><code>         *      id :  {</code></li>
<li class='green'><span class=''> </span><code>         *          type : "integer",</code></li>
<li class='green'><span class=''> </span><code>         *          primaryKey : true,</code></li>
<li class='green'><span class=''> </span><code>         *          "default" : "nextval('artist_id_seq'::regclass)",</code></li>
<li class='green'><span class=''> </span><code>         *          jsDefault : null,</code></li>
<li class='green'><span class=''> </span><code>         *          dbType : "integer",</code></li>
<li class='green'><span class=''> </span><code>         *          allowNull : false</code></li>
<li class='green'><span class=''> </span><code>         *       },</code></li>
<li class='green'><span class=''> </span><code>         *      name : {</code></li>
<li class='green'><span class=''> </span><code>         *          type : "string",</code></li>
<li class='green'><span class=''> </span><code>         *          primaryKey : false,</code></li>
<li class='green'><span class=''> </span><code>         *          "default" : null,</code></li>
<li class='green'><span class=''> </span><code>         *          jsDefault  : null,</code></li>
<li class='green'><span class=''> </span><code>         *          dbType : "text",</code></li>
<li class='green'><span class=''> </span><code>         *          allowNull : false</code></li>
<li class='green'><span class=''> </span><code>         *       }</code></li>
<li class='green'><span class=''> </span><code>         *     }</code></li>
<li class='green'><span class=''> </span><code>         *   })</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier|patio.sql.QualifiedIdentifier} table the table to get the schema for.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts=null] Additinal options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {boolean} [opts.reload=false] Set to true to ignore any cached results.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [opts.schema] An explicit schema to use.  It may also be implicitly provided</code></li>
<li class='green'><span class=''> </span><code>         *            via the table name.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} Returns a Promise that is resolved with the schema for the given table as an object</code></li>
<li class='green'><span class=''> </span><code>         * where the key is the column name and the value is and object containg column information. The default</code></li>
<li class='green'><span class=''> </span><code>         * column information returned.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;allowNull : Whether NULL is an allowed value for the column.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;dbType : The database type for the column, as a database specific string.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;"default" : The database default for the column, as a database specific string.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;primaryKey : Whether the columns is a primary key column.  If this column is not present,</code></li>
<li class='green'><span class=''> </span><code>         *                 it means that primary key information is unavailable, not that the column</code></li>
<li class='green'><span class=''> </span><code>         *                 is not a primary key.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;jsDefault : The database default for the column, as a javascript object.  In many cases, complex</code></li>
<li class='green'><span class=''> </span><code>         *                  database defaults cannot be parsed into javascript objects.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;type : A string specifying the type, such as "integer" or "string".&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        schema:function (table, opts) {</code></li>
<li class='green'><span class='hits'>115</span><code>            if (!isFunction(this.schemaParseTable)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new Error("Schema parsing is not implemented on this database");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>115</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>115</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>115</span><code>            var schemaParts = this.__schemaAndTable(table);</code></li>
<li class='green'><span class='hits'>115</span><code>            var sch = schemaParts[0], tableName = schemaParts[1];</code></li>
<li class='green'><span class='hits'>115</span><code>            var quotedName = this.__quoteSchemaTable(table);</code></li>
<li class='green'><span class='hits'>115</span><code>            opts = sch &amp;&amp; !opts.schema ? merge({schema:sch}, opts) : opts;</code></li>
<li class='green'><span class='hits'>115</span><code>            if (opts.reload) {</code></li>
<li class='green'><span class='hits'>1</span><code>                delete this.schemas[quotedName];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>115</span><code>            if (this.schemas[quotedName]) {</code></li>
<li class='green'><span class='hits'>35</span><code>                ret.callback(this.schemas[quotedName]);</code></li>
<li class='green'><span class='hits'>35</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>80</span><code>                this.schemaParseTable(tableName, opts).then(hitch(this, function (cols) {</code></li>
<li class='green'><span class='hits'>80</span><code>                    var schema = {};</code></li>
<li class='green'><span class='hits'>80</span><code>                    if (!cols || cols.length === 0) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret.errback("Error parsing schema, no columns returns, table probably doesnt exist");</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>80</span><code>                        cols.forEach(function (c) {</code></li>
<li class='green'><span class='hits'>413</span><code>                            var name = c[0];</code></li>
<li class='green'><span class='hits'>413</span><code>                            c = c[1];</code></li>
<li class='green'><span class='hits'>413</span><code>                            c.jsDefault = this.__columnSchemaToJsDefault(c["default"], c.type);</code></li>
<li class='green'><span class='hits'>413</span><code>                            schema[name] = c;</code></li>
<li class='green'><span class=''> </span><code>                        }, this);</code></li>
<li class='green'><span class='hits'>80</span><code>                        this.schemas[quotedName] = schema;</code></li>
<li class='green'><span class='hits'>80</span><code>                        ret.callback(schema);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }), ret);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>80</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Remove the cached schema for the given table name</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.schema("artists").then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      DB.removeCachedSchema("artists");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier|patio.sql.QualifiedIdentifier} the table to remove from this</code></li>
<li class='green'><span class=''> </span><code>         * databases cached schemas.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        removeCachedSchema:function (table) {</code></li>
<li class='green'><span class='hits'>509</span><code>            if (this.schemas &amp;&amp; !isEmpty(this.schemas)) {</code></li>
<li class='green'><span class='hits'>205</span><code>                delete this.schemas[this.__quoteSchemaTable(table)];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Determine if a table exists.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * comb.executeInOrder(DB, function(DB){</code></li>
<li class='green'><span class=''> </span><code>         *    return {</code></li>
<li class='green'><span class=''> </span><code>         *          table1Exists : DB.tableExists("table1"),</code></li>
<li class='green'><span class=''> </span><code>         *          table2Exists : DB.tableExists("table2")</code></li>
<li class='green'><span class=''> </span><code>         *    };</code></li>
<li class='green'><span class=''> </span><code>         * }).then(function(ret){</code></li>
<li class='green'><span class=''> </span><code>         *      //ret.table1Exists === true</code></li>
<li class='green'><span class=''> </span><code>         *      //ret.table2Exists === false</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier|patio.sql.QualifiedIdentifier} the table to remove from this</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise resolved with a boolean indicating if the table exists.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        tableExists:function (table, cb) {</code></li>
<li class='green'><span class='hits'>2</span><code>            var ret = new Promise().classic(cb);</code></li>
<li class='green'><span class='hits'>2</span><code>            this.from(table).first().then(function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret.callback(true);</code></li>
<li class='green'><span class=''> </span><code>            }, function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret.callback(false);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>2</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise with a list of tables names in this database. This method</code></li>
<li class='green'><span class=''> </span><code>         * should be implemented by the adapter.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.tables().then(function(tables){</code></li>
<li class='green'><span class=''> </span><code>         *    //e.g. tables === ["table1", "table2", "table3"];</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved with a list of tablenames.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        tables:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            throw new NotImplemented("tables should be implemented by the adapter");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Starts a database transaction.  When a database transaction is used,</code></li>
<li class='green'><span class=''> </span><code>         * either all statements are successful or none of the statements are</code></li>
<li class='green'><span class=''> </span><code>         * successful.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;Note&lt;/b&gt; that MySQL MyISAM tables do not support transactions.&lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         * //normal transaction</code></li>
<li class='green'><span class=''> </span><code>         * DB.transaction(function() {</code></li>
<li class='green'><span class=''> </span><code>         *      return comb.when(</code></li>
<li class='green'><span class=''> </span><code>         *          this.execute('DROP TABLE test;'),</code></li>
<li class='green'><span class=''> </span><code>         *          this.execute('DROP TABLE test2;')</code></li>
<li class='green'><span class=''> </span><code>         *      );</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //transaction with a save point.</code></li>
<li class='green'><span class=''> </span><code>         * DB.transaction(function() {</code></li>
<li class='green'><span class=''> </span><code>         *      return this.transaction({savepoint : true}, function() {</code></li>
<li class='green'><span class=''> </span><code>         *         return comb.when(</code></li>
<li class='green'><span class=''> </span><code>         *              this.execute('DROP TABLE test;'),</code></li>
<li class='green'><span class=''> </span><code>         *              this.execute('DROP TABLE test2;')</code></li>
<li class='green'><span class=''> </span><code>         *         );</code></li>
<li class='green'><span class=''> </span><code>         *      });</code></li>
<li class='green'><span class=''> </span><code>         *});</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Using a promise.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         * var ds = db.from("user");</code></li>
<li class='green'><span class=''> </span><code>         * db.transaction(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      return ds.insert({</code></li>
<li class='green'><span class=''> </span><code>         *              firstName:"Jane",</code></li>
<li class='green'><span class=''> </span><code>         *              lastName:"Gorgenson",</code></li>
<li class='green'><span class=''> </span><code>         *              password:"password",</code></li>
<li class='green'><span class=''> </span><code>         *              dateOfBirth:new Date(1956, 1, 3)</code></li>
<li class='green'><span class=''> </span><code>         *          }).chain(function(){</code></li>
<li class='green'><span class=''> </span><code>         *              return ds.forEach(function(user){</code></li>
<li class='green'><span class=''> </span><code>         *                  return ds.where({id:user.id}).update({firstName:user.firstName + 1});</code></li>
<li class='green'><span class=''> </span><code>         *              });</code></li>
<li class='green'><span class=''> </span><code>         *      });</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Using the done method</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         * var ds = db.from("user");</code></li>
<li class='green'><span class=''> </span><code>         * db.transaction(function(db, done){</code></li>
<li class='green'><span class=''> </span><code>         *      ds.insert({</code></li>
<li class='green'><span class=''> </span><code>         *          firstName:"Jane",</code></li>
<li class='green'><span class=''> </span><code>         *          lastName:"Gorgenson",</code></li>
<li class='green'><span class=''> </span><code>         *          password:"password",</code></li>
<li class='green'><span class=''> </span><code>         *          dateOfBirth:new Date(1956, 1, 3)</code></li>
<li class='green'><span class=''> </span><code>         *      }).chain(function(){</code></li>
<li class='green'><span class=''> </span><code>         *          ds.forEach(function(user){</code></li>
<li class='green'><span class=''> </span><code>         *             return ds.where({id:user.id}).update({firstName:user.firstName + 1});</code></li>
<li class='green'><span class=''> </span><code>         *          }).classic(done)</code></li>
<li class='green'><span class=''> </span><code>         *      });</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         * //WITH ISOLATION LEVELS</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * db.supportsTransactionIsolationLevels = true;</code></li>
<li class='green'><span class=''> </span><code>         * //BEGIN</code></li>
<li class='green'><span class=''> </span><code>         * //SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</code></li>
<li class='green'><span class=''> </span><code>         * //DROP TABLE test1'</code></li>
<li class='green'><span class=''> </span><code>         * //COMMIT</code></li>
<li class='green'><span class=''> </span><code>         * DB.transaction({isolation:"uncommited"}, function(d) {</code></li>
<li class='green'><span class=''> </span><code>         *     return d.run("DROP TABLE test1");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //BEGIN</code></li>
<li class='green'><span class=''> </span><code>         * //SET TRANSACTION ISOLATION LEVEL READ COMMITTED</code></li>
<li class='green'><span class=''> </span><code>         * //DROP TABLE test1</code></li>
<li class='green'><span class=''> </span><code>         * //COMMIT</code></li>
<li class='green'><span class=''> </span><code>         *  DB.transaction({isolation:"committed"}, function(d) {</code></li>
<li class='green'><span class=''> </span><code>         *      return d.run("DROP TABLE test1");</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //BEGIN</code></li>
<li class='green'><span class=''> </span><code>         * //SET TRANSACTION ISOLATION LEVEL REPEATABLE READ'</code></li>
<li class='green'><span class=''> </span><code>         * //DROP TABLE test1</code></li>
<li class='green'><span class=''> </span><code>         * //COMMIT</code></li>
<li class='green'><span class=''> </span><code>         *  DB.transaction({isolation:"repeatable"}, function(d) {</code></li>
<li class='green'><span class=''> </span><code>         *      return d.run("DROP TABLE test1");</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //BEGIN</code></li>
<li class='green'><span class=''> </span><code>         * //SET TRANSACTION ISOLATION LEVEL SERIALIZABLE</code></li>
<li class='green'><span class=''> </span><code>         * //DROP TABLE test1</code></li>
<li class='green'><span class=''> </span><code>         * //COMMIT</code></li>
<li class='green'><span class=''> </span><code>         *  DB.transaction({isolation:"serializable"}, function(d) {</code></li>
<li class='green'><span class=''> </span><code>         *      return d.run("DROP TABLE test1");</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //With an Error</code></li>
<li class='green'><span class=''> </span><code>         * //BEGIN</code></li>
<li class='green'><span class=''> </span><code>         * //DROP TABLE test</code></li>
<li class='green'><span class=''> </span><code>         * //ROLLBACK</code></li>
<li class='green'><span class=''> </span><code>         * DB.transaction(function(d) {</code></li>
<li class='green'><span class=''> </span><code>         *      d.execute('DROP TABLE test');</code></li>
<li class='green'><span class=''> </span><code>         *      throw "Error";</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * ```</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts={}] options to use when performing the transaction.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.isolation] The transaction isolation level to use for this transaction,</code></li>
<li class='green'><span class=''> </span><code>         *               should be "uncommitted", "committed", "repeatable", or "serializable",</code></li>
<li class='green'><span class=''> </span><code>         *               used if given and the database/adapter supports customizable</code></li>
<li class='green'><span class=''> </span><code>         *               transaction isolation levels.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.prepare] A string to use as the transaction identifier for a</code></li>
<li class='green'><span class=''> </span><code>         *             prepared transaction (two-phase commit), if the database/adapter</code></li>
<li class='green'><span class=''> </span><code>         *             supports prepared transactions.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.savepoint] Whether to create a new savepoint for this transaction,</code></li>
<li class='green'><span class=''> </span><code>         *               only respected if the database/adapter supports savepoints.  By</code></li>
<li class='green'><span class=''> </span><code>         *               default patio will reuse an existing transaction, so if you want to</code></li>
<li class='green'><span class=''> </span><code>         *               use a savepoint you must use this option.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} cb a function used to perform the transaction. This function is</code></li>
<li class='green'><span class=''> </span><code>         * called in the scope of the database by default so one can use this. The funciton is also</code></li>
<li class='green'><span class=''> </span><code>         * called with the database as the first argument, and a function to be called when the tranaction is complete.</code></li>
<li class='green'><span class=''> </span><code>         * If you return a promise from the transaction block then you do not need to call the done cb.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the transaction is complete.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        transaction:function (opts, cb) {</code></li>
<li class='green'><span class='hits'>1038</span><code>            if (isFunction(opts)) {</code></li>
<li class='green'><span class='hits'>137</span><code>                cb = opts;</code></li>
<li class='green'><span class='hits'>137</span><code>                opts = {};</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>901</span><code>                opts = opts || {};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1038</span><code>            if (!this.__alreadyInTransaction) {</code></li>
<li class='green'><span class='hits'>947</span><code>                this.__alreadyInTransaction = true;</code></li>
<li class='green'><span class='hits'>947</span><code>                return this.__transaction(null, opts, cb);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>91</span><code>                var ret = new Promise();</code></li>
<li class='green'><span class='hits'>91</span><code>                var transaction = hitch(this, function () {</code></li>
<li class='green'><span class='hits'>91</span><code>                    this.__transaction(null, opts, cb).then(ret);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>91</span><code>                this.__transactionQueue.enqueue(transaction);</code></li>
<li class='green'><span class='hits'>91</span><code>                return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __transactionProxy:function (cb, conn) {</code></li>
<li class='green'><span class='hits'>1043</span><code>            var promises = [];</code></li>
<li class='green'><span class='hits'>1043</span><code>            var repl = [];</code></li>
<li class='green'><span class=''> </span><code>            //set up our proxy methos</code></li>
<li class='green'><span class='hits'>1043</span><code>            ["transaction", "execute"].forEach(function (n) {</code></li>
<li class='green'><span class='hits'>2086</span><code>                var orig = this[n];</code></li>
<li class='green'><span class='hits'>2086</span><code>                repl.push({name:n, orig:orig});</code></li>
<li class='green'><span class='hits'>2086</span><code>                this[n] = function (arg1, arg2) {</code></li>
<li class='green'><span class='hits'>6673</span><code>                    var ret;</code></li>
<li class='green'><span class='hits'>6673</span><code>                    try {</code></li>
<li class='green'><span class='hits'>6673</span><code>                        if (n === "transaction") {</code></li>
<li class='green'><span class=''> </span><code>                            //if its a transaction with no options then we just create a promise from what ever is returned</code></li>
<li class='green'><span class='hits'>2045</span><code>                            if (isFunction(arg1)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                                ret = when(arg1.apply(this, [this]));</code></li>
<li class='green'><span class=''> </span><code>                            } else {</code></li>
<li class='green'><span class='hits'>2042</span><code>                                if (this.supportsSavepoints &amp;&amp; !isUndefinedOrNull(arg1.savepoint)) {</code></li>
<li class='green'><span class=''> </span><code>                                    //if we support save points there is a save point option then we</code></li>
<li class='green'><span class=''> </span><code>                                    //use __transaction again with the previous connection</code></li>
<li class='green'><span class='hits'>5</span><code>                                    ret = this.__transaction(conn, arg1, arg2);</code></li>
<li class='green'><span class=''> </span><code>                                } else {</code></li>
<li class='green'><span class=''> </span><code>                                    //other wise use the function passed in to get the returned promise</code></li>
<li class='green'><span class='hits'>2037</span><code>                                    ret = when(arg2.apply(this, [this]));</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>4628</span><code>                            ret = orig.apply(this, argsToArray(arguments).concat(conn));</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    } catch (e) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        ret = new Promise().errback(e);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>6673</span><code>                    promises.push(when(ret));</code></li>
<li class='green'><span class='hits'>6673</span><code>                    return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>                };</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>1043</span><code>            try {</code></li>
<li class='green'><span class='hits'>1043</span><code>                var transactionP = new comb.Promise();</code></li>
<li class='green'><span class='hits'>1043</span><code>                var cbRet = cb.apply(this, [this, transactionP.resolve.bind(transactionP)]);</code></li>
<li class='green'><span class='hits'>1036</span><code>                if (cbRet &amp;&amp; isPromiseLike(cbRet, Promise)) {</code></li>
<li class='green'><span class='hits'>1033</span><code>                    promises.push(cbRet);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                    promises.push(transactionP);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } catch (e) {</code></li>
<li class='green'><span class='hits'>7</span><code>                promises.push(new Promise().errback(e));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1043</span><code>            if (promises.length === 0) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                promises.push(new Promise().callback());</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1043</span><code>            return new PromiseList(promises).both(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>1043</span><code>                repl.forEach(function (o) {</code></li>
<li class='green'><span class='hits'>2086</span><code>                    this[o.name] = o.orig;</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            })).promise();</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getConnection:function () {</code></li>
<li class='green'><span class='hits'>2587</span><code>            return this.pool.getConnection();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _returnConnection:function (conn) {</code></li>
<li class='green'><span class='hits'>6036</span><code>            if (!this.alreadyInTransaction(conn)) {</code></li>
<li class='green'><span class='hits'>1549</span><code>                this.pool.returnConnection(conn);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __transaction:function (conn, opts, cb) {</code></li>
<li class='green'><span class='hits'>1043</span><code>            var promise = new Promise();</code></li>
<li class='green'><span class='hits'>1043</span><code>            try {</code></li>
<li class='green'><span class='hits'>1043</span><code>                var connPromise = conn ? new Promise().callback(conn) : this._getConnection().addCallback(hitch(this, function (conn) {</code></li>
<li class='green'><span class=''> </span><code>                    //add the connection to the transactions</code></li>
<li class='green'><span class='hits'>1038</span><code>                    this.__transactions.push(conn);</code></li>
<li class='green'><span class=''> </span><code>                    //reset transaction depth to 0, this is used for keeping track of save points.</code></li>
<li class='green'><span class='hits'>1038</span><code>                    conn.__transactionDepth = 0;</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class='hits'>1043</span><code>                connPromise.then(hitch(this, function (conn) {</code></li>
<li class='green'><span class='hits'>1043</span><code>                    this.__beginTransaction(conn, opts).chain(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>1043</span><code>                        this.__transactionProxy(cb, conn).chain(hitch(this, function (res) {</code></li>
<li class='green'><span class='hits'>989</span><code>                            this.__commitTransaction(conn).chain(hitch(this, "__transactionComplete", promise, "callback", conn), hitch(this, "__transactionComplete", promise, "errback", conn));</code></li>
<li class='green'><span class=''> </span><code>                        }), hitch(this, "__rollback", promise, conn));</code></li>
<li class='green'><span class=''> </span><code>                    }), hitch(this, "__transactionComplete", promise, "errback", conn));</code></li>
<li class='green'><span class=''> </span><code>                }), hitch(this, "__transactionComplete", promise, "errback"));</code></li>
<li class='green'><span class=''> </span><code>            } catch (e) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                this.logError(e);</code></li>
<li class='red'><span class='nohits'>0</span><code>                promise.errback(e);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1043</span><code>            return promise.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __transactionComplete:function (promise, type, conn) {</code></li>
<li class='green'><span class='hits'>989</span><code>            this.__finishTransactionAndCheckForMore(conn);</code></li>
<li class='green'><span class='hits'>989</span><code>            promise[type].apply(promise, argsToArray(arguments).slice(3));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __rollback:function (promise, conn, err) {</code></li>
<li class='green'><span class='hits'>54</span><code>            this.__rollbackTransaction(conn, null, err).both(hitch(this, "__finishTransactionAndCheckForMore", conn)).then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>54</span><code>                if (conn.__transactionDepth &lt;= 1) {</code></li>
<li class='green'><span class='hits'>54</span><code>                    this.__transactionError(err, promise);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    promise.errback(err);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __transactionError:function (err, promise) {</code></li>
<li class='green'><span class='hits'>54</span><code>            if (isArray(err)) {</code></li>
<li class='green'><span class='hits'>54</span><code>                for (var i in err) {</code></li>
<li class='green'><span class='hits'>54</span><code>                    if (i in err) {</code></li>
<li class='green'><span class='hits'>54</span><code>                        var e = err[i];</code></li>
<li class='green'><span class='hits'>54</span><code>                        if (isArray(e) &amp;&amp; e.length === 2) {</code></li>
<li class='green'><span class='hits'>54</span><code>                            var realE = e[1];</code></li>
<li class='green'><span class='hits'>54</span><code>                            if (realE !== "ROLLBACK") {</code></li>
<li class='green'><span class='hits'>53</span><code>                                promise.errback(new Error(realE));</code></li>
<li class='green'><span class='hits'>53</span><code>                                break;</code></li>
<li class='green'><span class=''> </span><code>                            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                                promise.callback();</code></li>
<li class='green'><span class='hits'>1</span><code>                                break;</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            promise.errback(new Error(e));</code></li>
<li class='red'><span class='nohits'>0</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (err !== "ROLLBACK") {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new Error(err);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __finishTransactionAndCheckForMore:function (conn) {</code></li>
<li class='green'><span class='hits'>1043</span><code>            if (this.alreadyInTransaction(conn)) {</code></li>
<li class='green'><span class='hits'>1043</span><code>                if (!this.supportsSavepoints || ((conn.__transactionDepth -= 1) &lt;= 0)) {</code></li>
<li class='green'><span class='hits'>1038</span><code>                    if (conn) {</code></li>
<li class='green'><span class='hits'>1038</span><code>                        this.pool.returnConnection(conn);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1038</span><code>                    var index, transactions = this.__transactions;</code></li>
<li class='green'><span class='hits'>1038</span><code>                    if ((index = transactions.indexOf(conn)) &gt; -1) {</code></li>
<li class='green'><span class='hits'>1038</span><code>                        transactions.splice(index, 1);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1038</span><code>                    if (!this.__transactionQueue.isEmpty) {</code></li>
<li class='green'><span class='hits'>91</span><code>                        this.__transactionQueue.dequeue()();</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>947</span><code>                        this.__alreadyInTransaction = false;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //SQL to start a new savepoint</code></li>
<li class='green'><span class=''> </span><code>        __beginSavepointSql:function (depth) {</code></li>
<li class='green'><span class='hits'>5</span><code>            return format(this._static.SQL_SAVEPOINT, depth);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Start a new database connection on the given connection</code></li>
<li class='green'><span class=''> </span><code>        __beginNewTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>1029</span><code>            return this.__logConnectionExecute(conn, this.beginTransactionSql).chain(hitch(this, "__setTransactionIsolation", conn, opts))</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Start a new database transaction or a new savepoint on the given connection.</code></li>
<li class='green'><span class=''> </span><code>        __beginTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>1043</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>1043</span><code>            if (this.supportsSavepoints) {</code></li>
<li class='green'><span class='hits'>918</span><code>                if (conn.__transactionDepth &gt; 0) {</code></li>
<li class='green'><span class='hits'>5</span><code>                    ret = this.__logConnectionExecute(conn, this.__beginSavepointSql(conn.__transactionDepth));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>913</span><code>                    ret = this.__beginNewTransaction(conn, opts);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>918</span><code>                conn.__transactionDepth += 1;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>125</span><code>                ret = this.__beginNewTransaction(conn, opts);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1043</span><code>            return  ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // SQL to commit a savepoint</code></li>
<li class='green'><span class=''> </span><code>        __commitSavepointSql:function (depth) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return format(this.SQL_RELEASE_SAVEPOINT, depth);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Commit the active transaction on the connection</code></li>
<li class='green'><span class=''> </span><code>        __commitTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>986</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>986</span><code>            if (this.supportsSavepoints) {</code></li>
<li class='green'><span class='hits'>870</span><code>                var depth = conn.__transactionDepth;</code></li>
<li class='green'><span class='hits'>870</span><code>                var sql = null;</code></li>
<li class='green'><span class='hits'>870</span><code>                if (depth &gt; 1) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    sql = this.__commitSavepointSql(depth - 1);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>867</span><code>                    this.__commiting = true;</code></li>
<li class='green'><span class='hits'>867</span><code>                    sql = this.commitTransactionSql;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>870</span><code>                return this.__logConnectionExecute(conn, (sql));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>116</span><code>                this.__commiting = true;</code></li>
<li class='green'><span class='hits'>116</span><code>                return this.__logConnectionExecute(conn, this.commitTransactionSql);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //SQL to rollback to a savepoint</code></li>
<li class='green'><span class=''> </span><code>        __rollbackSavepointSql:function (depth) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return format(this.SQL_ROLLBACK_TO_SAVEPOINT, depth);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Rollback the active transaction on the connection</code></li>
<li class='green'><span class=''> </span><code>        __rollbackTransaction:function (conn, opts, err) {</code></li>
<li class='green'><span class='hits'>54</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>54</span><code>            if (this.supportsSavepoints) {</code></li>
<li class='green'><span class='hits'>46</span><code>                var sql, depth = conn.__transactionDepth;</code></li>
<li class='green'><span class='hits'>46</span><code>                if (depth &gt; 1) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    sql = this.__rollbackSavepointSql(depth - 1);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>45</span><code>                    this.__commiting = true;</code></li>
<li class='green'><span class='hits'>45</span><code>                    sql = this.rollbackTransactionSql;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>46</span><code>                return this.__logConnectionExecute(conn, sql);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>8</span><code>                this.__commiting = false;</code></li>
<li class='green'><span class='hits'>8</span><code>                return this.__logConnectionExecute(conn, this.rollbackTransactionSql);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Set the transaction isolation level on the given connection</code></li>
<li class='green'><span class=''> </span><code>        __setTransactionIsolation:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>1038</span><code>            var level;</code></li>
<li class='green'><span class='hits'>1038</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>1038</span><code>            if (this.supportsTransactionIsolationLevels &amp;&amp; !isUndefinedOrNull(level = isUndefinedOrNull(opts.isolation) ? this.transactionIsolationLevel : opts.isolation)) {</code></li>
<li class='green'><span class='hits'>8</span><code>                return this.__logConnectionExecute(conn, this.__setTransactionIsolationSql(level)).then(ret);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1030</span><code>                ret.callback();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1030</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // SQL to set the transaction isolation level</code></li>
<li class='green'><span class=''> </span><code>        __setTransactionIsolationSql:function (level) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return format("SET TRANSACTION ISOLATION LEVEL %s", this.TRANSACTION_ISOLATION_LEVELS[level]);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Convert the given default, which should be a database specific string, into</code></li>
<li class='green'><span class=''> </span><code>        //a javascript object.</code></li>
<li class='green'><span class=''> </span><code>        __columnSchemaToJsDefault:function (def, type) {</code></li>
<li class='green'><span class='hits'>465</span><code>            if (isNull(def) || isUndefined(def)) {</code></li>
<li class='green'><span class='hits'>348</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>117</span><code>            var origDefault = def, m, datePattern, dateTimePattern, timeStampPattern, timePattern;</code></li>
<li class='green'><span class='hits'>117</span><code>            if (this.type === "postgres" &amp;&amp; (m = def.match(this.POSTGRES_DEFAULT_RE)) !== null) {</code></li>
<li class='green'><span class='hits'>9</span><code>                def = m[1] || m[2];</code></li>
<li class='green'><span class='hits'>9</span><code>                dateTimePattern = this.POSTGRES_DATE_TIME_PATTERN;</code></li>
<li class='green'><span class='hits'>9</span><code>                timePattern = this.POSTGRES_TIME_PATTERN;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>117</span><code>            if (this.type === "mssql" &amp;&amp; (m = def.match(this.MSSQL_DEFAULT_RE)) !== null) {</code></li>
<li class='green'><span class='hits'>4</span><code>                def = m[1] || m[2];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>117</span><code>            if (["string", "blob", "date", "datetime", "year", "timestamp", "time", "enum"].indexOf(type) !== -1) {</code></li>
<li class='green'><span class='hits'>32</span><code>                if (this.type === "mysql") {</code></li>
<li class='green'><span class='hits'>12</span><code>                    if (["date", "datetime", "time", "timestamp"].indexOf(type) !== -1 &amp;&amp; def.match(this.MYSQL_TIMESTAMP_RE)) {</code></li>
<li class='green'><span class='hits'>4</span><code>                        return null;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>8</span><code>                    origDefault = def = "'" + def + "'".replace("\\", "\\\\");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>28</span><code>                if (!(m = def.match(this.STRING_DEFAULT_RE))) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    return null;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>26</span><code>                def = m[1].replace("''", "'");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>111</span><code>            var ret = null;</code></li>
<li class='green'><span class='hits'>111</span><code>            try {</code></li>
<li class='green'><span class='hits'>111</span><code>                switch (type) {</code></li>
<li class='green'><span class=''> </span><code>                    case "boolean":</code></li>
<li class='green'><span class='hits'>6</span><code>                        if (def.match(/[f0]/i)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                            ret = false;</code></li>
<li class='green'><span class='hits'>3</span><code>                        } else if (def.match(/[t1]/i)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                            ret = true;</code></li>
<li class='red'><span class='nohits'>0</span><code>                        } else if (isBoolean(def)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            ret = def;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>6</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case "blob":</code></li>
<li class='green'><span class='hits'>1</span><code>                        ret = new Buffer(def);</code></li>
<li class='green'><span class='hits'>1</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case "string":</code></li>
<li class='green'><span class=''> </span><code>                    case "enum":</code></li>
<li class='green'><span class='hits'>13</span><code>                        ret = def;</code></li>
<li class='green'><span class='hits'>13</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case  "integer":</code></li>
<li class='green'><span class='hits'>65</span><code>                        ret = parseInt(def, 10);</code></li>
<li class='green'><span class='hits'>65</span><code>                        if (isNaN(ret)) {</code></li>
<li class='green'><span class='hits'>58</span><code>                            ret = null;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>65</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case  "float":</code></li>
<li class='green'><span class=''> </span><code>                    case  "decimal":</code></li>
<li class='green'><span class='hits'>11</span><code>                        ret = parseFloat(def, 10);</code></li>
<li class='green'><span class='hits'>11</span><code>                        if (isNaN(ret)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            ret = null;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>11</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case "year" :</code></li>
<li class='green'><span class='hits'>1</span><code>                        ret = this.patio.stringToYear(def);</code></li>
<li class='green'><span class='hits'>1</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case "date":</code></li>
<li class='green'><span class='hits'>3</span><code>                        ret = this.patio.stringToDate(def, datePattern);</code></li>
<li class='green'><span class='hits'>3</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case "timestamp":</code></li>
<li class='green'><span class='hits'>1</span><code>                        ret = this.patio.stringToTimeStamp(def, timeStampPattern);</code></li>
<li class='green'><span class='hits'>1</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case "datetime":</code></li>
<li class='green'><span class='hits'>4</span><code>                        ret = this.patio.stringToDateTime(def, dateTimePattern);</code></li>
<li class='green'><span class='hits'>4</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    case "time":</code></li>
<li class='green'><span class='hits'>3</span><code>                        ret = this.patio.stringToTime(def, timePattern);</code></li>
<li class='green'><span class='hits'>3</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } catch (e) {</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>111</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Match the database's column type to a javascript type via a</code></li>
<li class='green'><span class=''> </span><code>         * regular expression, and return the javascript type as a string</code></li>
<li class='green'><span class=''> </span><code>         * such as "integer" or "string".</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        schemaColumnType:function (dbType) {</code></li>
<li class='green'><span class='hits'>412</span><code>            var ret = null, m;</code></li>
<li class='green'><span class='hits'>412</span><code>            if (dbType.match(/^interval$/i)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = "interval";</code></li>
<li class='green'><span class='hits'>412</span><code>            } else if (dbType.match(/^(character( varying)?|n?(var)?char)/i)) {</code></li>
<li class='green'><span class='hits'>207</span><code>                ret = "string";</code></li>
<li class='green'><span class='hits'>205</span><code>            } else if (dbType.match(/^int(eger)?|(big|small|tiny)int/i)) {</code></li>
<li class='green'><span class='hits'>130</span><code>                ret = "integer";</code></li>
<li class='green'><span class='hits'>75</span><code>            } else if (dbType.match(/^date$/i)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = "date";</code></li>
<li class='green'><span class='hits'>74</span><code>            } else if (dbType.match(/^year/i)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = "year";</code></li>
<li class='green'><span class='hits'>74</span><code>            } else if (dbType.match(/^((small)?datetime|timestamp( with(out)? time zone)?)$/i)) {</code></li>
<li class='green'><span class='hits'>8</span><code>                ret = "datetime";</code></li>
<li class='green'><span class='hits'>66</span><code>            } else if (dbType.match(/^time( with(out)? timezone)?$/i)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = "time";</code></li>
<li class='green'><span class='hits'>66</span><code>            } else if (dbType.match(/^(bit|boolean)$/i)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = "boolean";</code></li>
<li class='green'><span class='hits'>66</span><code>            } else if (dbType.match(/^(real|float|double( precision)?)$/i)) {</code></li>
<li class='green'><span class='hits'>12</span><code>                ret = "float";</code></li>
<li class='green'><span class='hits'>54</span><code>            } else if ((m = dbType.match(/^(?:(?:(?:num(?:ber|eric)?|decimal|double)(?:\(\d+,\s*(\d+)\))?)|(?:small)?money)/i))) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = m[1] &amp;&amp; m[1] === '0' ? "integer" : "decimal";</code></li>
<li class='green'><span class='hits'>52</span><code>            } else if (dbType.match(/n?text/i)) {</code></li>
<li class='green'><span class='hits'>37</span><code>                ret = "text";</code></li>
<li class='green'><span class='hits'>15</span><code>            } else if (dbType.match(/bytea|[bc]lob|image|(var)?binary/i)) {</code></li>
<li class='green'><span class='hits'>13</span><code>                ret = "blob";</code></li>
<li class='green'><span class='hits'>2</span><code>            } else if (dbType.match(/^enum/i)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = "enum";</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (dbType.match(/^set/i)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = "set";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>412</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns true if this DATABASE is currently in a transaction.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param opts</code></li>
<li class='green'><span class=''> </span><code>         * @return {Boolean} true if this dabase is currently in a transaction.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        alreadyInTransaction:function (conn, opts) {</code></li>
<li class='green'><span class='hits'>7079</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>7079</span><code>            return this.__transactions.indexOf(conn) !== -1 &amp;&amp; (!this.supportsSavepoints || !opts.savepoint);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * SQL to BEGIN a transaction.</code></li>
<li class='green'><span class=''> </span><code>             * See {@link patio.Database#SQL_BEGIN} for default,</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            beginTransactionSql:function () {</code></li>
<li class='green'><span class='hits'>1038</span><code>                return this.SQL_BEGIN;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * SQL to COMMIT a transaction.</code></li>
<li class='green'><span class=''> </span><code>             * See {@link patio.Database#SQL_COMMIT} for default,</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            commitTransactionSql:function () {</code></li>
<li class='green'><span class='hits'>983</span><code>                return this.SQL_COMMIT;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * SQL to ROLLBACK a transaction.</code></li>
<li class='green'><span class=''> </span><code>             * See {@link patio.Database#SQL_ROLLBACK} for default,</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            rollbackTransactionSql:function () {</code></li>
<li class='green'><span class='hits'>53</span><code>                return this.SQL_ROLLBACK;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Return a function for the dataset's {@link patio.Dataset#outputIdentifierMethod}.</code></li>
<li class='green'><span class=''> </span><code>             * Used in metadata parsing to make sure the returned information is in the</code></li>
<li class='green'><span class=''> </span><code>             * correct format.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Function</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            outputIdentifierFunc:function () {</code></li>
<li class='green'><span class='hits'>83</span><code>                return hitch(this.dataset, this.dataset.outputIdentifier);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Return a function for the dataset's {@link patio.Dataset#inputIdentifierMethod}.</code></li>
<li class='green'><span class=''> </span><code>             * Used in metadata parsing to make sure the returned information is in the</code></li>
<li class='green'><span class=''> </span><code>             * correct format.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Function</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            inputIdentifierFunc:function () {</code></li>
<li class='green'><span class='hits'>153</span><code>                return hitch(this.dataset, this.dataset.inputIdentifier);</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Return a dataset that uses the default identifier input and output methods</code></li>
<li class='green'><span class=''> </span><code>             * for this database.  Used when parsing metadata so that column are</code></li>
<li class='green'><span class=''> </span><code>             * returned as expected.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type patio.Dataset</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            metadataDataset:function () {</code></li>
<li class='green'><span class='hits'>83</span><code>                if (this.__metadataDataset) {</code></li>
<li class='green'><span class='hits'>48</span><code>                    return this.__metadataDataset;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>35</span><code>                var ds = this.dataset;</code></li>
<li class='green'><span class='hits'>35</span><code>                ds.identifierInputMethod = this.identifierInputMethod;</code></li>
<li class='green'><span class='hits'>35</span><code>                ds.identifierOutputMethod = this.identifierOutputMethod;</code></li>
<li class='green'><span class='hits'>35</span><code>                this.__metadataDataset = ds;</code></li>
<li class='green'><span class='hits'>35</span><code>                return ds;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        SQL_BEGIN:'BEGIN',</code></li>
<li class='green'><span class=''> </span><code>        SQL_COMMIT:'COMMIT',</code></li>
<li class='green'><span class=''> </span><code>        SQL_RELEASE_SAVEPOINT:'RELEASE SAVEPOINT autopoint_%d',</code></li>
<li class='green'><span class=''> </span><code>        SQL_ROLLBACK:'ROLLBACK',</code></li>
<li class='green'><span class=''> </span><code>        SQL_ROLLBACK_TO_SAVEPOINT:'ROLLBACK TO SAVEPOINT autopoint_%d',</code></li>
<li class='green'><span class=''> </span><code>        SQL_SAVEPOINT:'SAVEPOINT autopoint_%d',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        TRANSACTION_BEGIN:'Transaction.begin',</code></li>
<li class='green'><span class=''> </span><code>        TRANSACTION_COMMIT:'Transaction.commit',</code></li>
<li class='green'><span class=''> </span><code>        TRANSACTION_ROLLBACK:'Transaction.rollback',</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        TRANSACTION_ISOLATION_LEVELS:{</code></li>
<li class='green'><span class=''> </span><code>            uncommitted:'READ UNCOMMITTED',</code></li>
<li class='green'><span class=''> </span><code>            committed:'READ COMMITTED',</code></li>
<li class='green'><span class=''> </span><code>            repeatable:'REPEATABLE READ',</code></li>
<li class='green'><span class=''> </span><code>            serializable:'SERIALIZABLE'</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        POSTGRES_DEFAULT_RE:/^(?:B?('.*')::[^']+|\((-?\d+(?:\.\d+)?)\))$/,</code></li>
<li class='green'><span class=''> </span><code>        MSSQL_DEFAULT_RE:/^(?:\(N?('.*')\)|\(\((-?\d+(?:\.\d+)?)\)\))$/,</code></li>
<li class='green'><span class=''> </span><code>        MYSQL_TIMESTAMP_RE:/^CURRENT_(?:DATE|TIMESTAMP)?$/,</code></li>
<li class='green'><span class=''> </span><code>        STRING_DEFAULT_RE:/^'(.*)'$/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="migration.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>migration.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>92.70</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>543</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>233</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>17</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="migration.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("./errors"),</code></li>
<li class='green'><span class=''> </span><code>    MigrationError = errors.MigrationError,</code></li>
<li class='green'><span class=''> </span><code>    NotImplemented = errors.NotImplemented(),</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    isNumber = comb.isNumber,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    fs = require("fs"),</code></li>
<li class='green'><span class=''> </span><code>    path = require("path"),</code></li>
<li class='green'><span class=''> </span><code>    baseName = path.basename,</code></li>
<li class='green'><span class=''> </span><code>    asyncArray = comb.async.array;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Migrator = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.migrations.Migrator.prototype*/</code></li>
<li class='green'><span class=''> </span><code>        column:null,</code></li>
<li class='green'><span class=''> </span><code>        db:null,</code></li>
<li class='green'><span class=''> </span><code>        directory:null,</code></li>
<li class='green'><span class=''> </span><code>        ds:null,</code></li>
<li class='green'><span class=''> </span><code>        files:null,</code></li>
<li class='green'><span class=''> </span><code>        table:null,</code></li>
<li class='green'><span class=''> </span><code>        target:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Abstract Migrator class. This class should be be instantiated directly.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Database} db the database to migrate</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} directory directory that the migration files reside in</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts={}] optional parameters.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.column] the column in the table that version information should be stored.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.table] the table that version information should be stored.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number} [opts.target] the target migration(i.e the migration to migrate up/down to).</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.current] the version that the database is currently at if the current version</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function (db, directory, opts) {</code></li>
<li class='green'><span class='hits'>31</span><code>            this.db = db;</code></li>
<li class='green'><span class='hits'>31</span><code>            this.directory = directory;</code></li>
<li class='green'><span class='hits'>31</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>31</span><code>            this.table = opts.table || this._static.DEFAULT_SCHEMA_TABLE;</code></li>
<li class='green'><span class='hits'>31</span><code>            this.column = opts.column || this._static.DEFAULT_SCHEMA_COLUMN;</code></li>
<li class='green'><span class='hits'>31</span><code>            this._opts = opts;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Runs the migration and returns a promise.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        run:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new NotImplemented("patio.migrations.Migrator#run");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getFileNames:function () {</code></li>
<li class='green'><span class='hits'>49</span><code>            if (!this.__files) {</code></li>
<li class='green'><span class='hits'>30</span><code>                return this._static.getFileNames(this.directory).addCallback(hitch(this, function (files) {</code></li>
<li class='green'><span class='hits'>30</span><code>                    this.__files = files;</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>19</span><code>                return new Promise().callback(this.__files).promise();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getMigrationVersionFromFile:function (filename) {</code></li>
<li class='green'><span class='hits'>483</span><code>            return parseInt(path.basename(filename).split(this._static.MIGRATION_SPLITTER)[0], 10);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.migrations.Migrator*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        MIGRATION_FILE_PATTERN:/^\d+\..+\.js$/i,</code></li>
<li class='green'><span class=''> </span><code>        MIGRATION_SPLITTER:'.',</code></li>
<li class='green'><span class=''> </span><code>        MINIMUM_TIMESTAMP:20000101,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getFileNames:function (directory) {</code></li>
<li class='green'><span class='hits'>61</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>61</span><code>            fs.readdir(directory, hitch(this, function (err, files) {</code></li>
<li class='green'><span class='hits'>61</span><code>                if (err) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret.errback(err);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>61</span><code>                    files = files.filter(function (file) {</code></li>
<li class='green'><span class='hits'>297</span><code>                        return file.match(this.MIGRATION_FILE_PATTERN) !== null;</code></li>
<li class='green'><span class=''> </span><code>                    }, this).map(function (file) {</code></li>
<li class='green'><span class='hits'>297</span><code>                            return path.resolve(directory, file);</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class='hits'>61</span><code>                    files.sort();</code></li>
<li class='green'><span class='hits'>61</span><code>                    ret.callback(files);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class='hits'>61</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Migrates the database using migration files found in the supplied directory.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio#migrate}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var DB = patio.connect("my://connection/string");</code></li>
<li class='green'><span class=''> </span><code>         * patio. migrate(DB, __dirname + "/timestamp_migration").then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     console.log("done migrating!");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio. migrate(DB, __dirname + "/timestamp_migration", {target : 0}).then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     console.log("done migrating down!");</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Database} db the database to migrate</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} directory directory that the migration files reside in</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts={}] optional parameters.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.column] the column in the table that version information should be stored.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.table] the table that version information should be stored.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number} [opts.target] the target migration(i.e the migration to migrate up/down to).</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.current] the version that the database is currently at if the current version</code></li>
<li class='green'><span class=''> </span><code>         * is not provided it is retrieved from the database.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise} a promise that is resolved once the migration is complete.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        run:function (db, directory, opts, cb) {</code></li>
<li class='green'><span class='hits'>31</span><code>            if (isFunction(opts)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                cb = opts;</code></li>
<li class='red'><span class='nohits'>0</span><code>                opts = {};</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>31</span><code>                opts = opts || {};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>31</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>31</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>31</span><code>            return this.__getMigrator(directory).chain(function (migrator) {</code></li>
<li class='green'><span class='hits'>31</span><code>                return new migrator(db, directory, opts).run();</code></li>
<li class='green'><span class=''> </span><code>            }).classic(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Choose the Migrator subclass to use.  Uses the TimestampMigrator</code></li>
<li class='green'><span class=''> </span><code>        // // if the version number appears to be a unix time integer for a year</code></li>
<li class='green'><span class=''> </span><code>        // after 2005, otherwise uses the IntegerMigrator.</code></li>
<li class='green'><span class=''> </span><code>        __getMigrator:function (directory) {</code></li>
<li class='green'><span class='hits'>31</span><code>            var retClass = IntegerMigrator, ret = new Promise();</code></li>
<li class='green'><span class='hits'>31</span><code>            this.getFileNames(directory).then(function (files) {</code></li>
<li class='green'><span class='hits'>31</span><code>                var l = files.length;</code></li>
<li class='green'><span class='hits'>31</span><code>                if (l) {</code></li>
<li class='green'><span class='hits'>31</span><code>                    for (var i = 0; i &lt; l; i++) {</code></li>
<li class='green'><span class='hits'>81</span><code>                        var file = files[i];</code></li>
<li class='green'><span class='hits'>81</span><code>                        if (parseInt(path.basename(file).split(this.MIGRATION_SPLITTER)[0], 10) &gt; this.MINIMUM_TIMESTAMP) {</code></li>
<li class='green'><span class='hits'>18</span><code>                            retClass = TimestampMigrator;</code></li>
<li class='green'><span class='hits'>18</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>31</span><code>                ret.callback(retClass);</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this), ret);</code></li>
<li class='green'><span class='hits'>31</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Migrator that uses the file format {migrationName}.{version}.js, where version starts at 0.</code></li>
<li class='green'><span class=''> </span><code> * &lt;b&gt;Missing migrations are not allowed&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.migrations.Migrator</code></li>
<li class='green'><span class=''> </span><code> * @name IntegerMigrator</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.migrations</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var IntegerMigrator = define(Migrator, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.migrations.IntegerMigrator.prototype*/</code></li>
<li class='green'><span class=''> </span><code>        current:null,</code></li>
<li class='green'><span class=''> </span><code>        direction:null,</code></li>
<li class='green'><span class=''> </span><code>        migrations:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _migrationFiles:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        run:function () {</code></li>
<li class='green'><span class='hits'>13</span><code>            var ret = new Promise(), DB = this.db;</code></li>
<li class='green'><span class='hits'>13</span><code>            return serial([this._getLatestMigrationVersion.bind(this), this._getCurrentMigrationVersion.bind(this)]).chain(function (res) {</code></li>
<li class='green'><span class='hits'>11</span><code>                var target = res[0], current = res[1];</code></li>
<li class='green'><span class='hits'>11</span><code>                if (current !== target) {</code></li>
<li class='green'><span class='hits'>10</span><code>                    var direction = this.direction = current &lt; target ? "up" : "down", isUp = direction === "up", version = 0;</code></li>
<li class='green'><span class='hits'>10</span><code>                    return this._getMigrations(current, target, direction).chain(function (migrations) {</code></li>
<li class='green'><span class='hits'>10</span><code>                        return asyncArray(migrations).forEach(function (curr) {</code></li>
<li class='green'><span class='hits'>41</span><code>                            var migration = curr[0];</code></li>
<li class='green'><span class='hits'>41</span><code>                            version = curr[1];</code></li>
<li class='green'><span class='hits'>41</span><code>                            var now = new Date();</code></li>
<li class='green'><span class='hits'>41</span><code>                            var lv = isUp ? version : version - 1;</code></li>
<li class='green'><span class='hits'>41</span><code>                            DB.logInfo("Begin applying migration version %d, direction: %s", lv, direction);</code></li>
<li class='green'><span class='hits'>41</span><code>                            return DB.transaction(hitch(this, function (db) {</code></li>
<li class='green'><span class='hits'>41</span><code>                                if (!isFunction(migration[direction])) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                                    return this._setMigrationVersion(lv);</code></li>
<li class='green'><span class=''> </span><code>                                } else {</code></li>
<li class='green'><span class='hits'>41</span><code>                                    var nextP = new Promise();</code></li>
<li class='green'><span class='hits'>41</span><code>                                    var dirP = migration[direction].apply(DB, [DB, nextP.resolve.bind(nextP)]);</code></li>
<li class='green'><span class='hits'>41</span><code>                                    return (comb.isPromiseLike(dirP) ? dirP : nextP).chain(comb(this._setMigrationVersion).bindIgnore(this, lv));</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            })).chain(function () {</code></li>
<li class='green'><span class='hits'>41</span><code>                                    DB.logInfo("Finished applying migration version %d, direction: %s, took % 4dms seconds", lv, direction, new Date() - now);</code></li>
<li class='green'><span class=''> </span><code>                                });</code></li>
<li class='green'><span class=''> </span><code>                        }, this, 1).chain(function () {</code></li>
<li class='green'><span class='hits'>10</span><code>                                return version;</code></li>
<li class='green'><span class=''> </span><code>                            });</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                    return target;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getMigrations:function (current, target, direction) {</code></li>
<li class='green'><span class='hits'>10</span><code>            var ret = new Promise(), isUp = direction === "up", migrations = [];</code></li>
<li class='green'><span class='hits'>10</span><code>            return when(this._getMigrationFiles()).chain(function (files) {</code></li>
<li class='green'><span class='hits'>10</span><code>                if ((isUp ? target : current - 1) &lt; files.length) {</code></li>
<li class='green'><span class='hits'>10</span><code>                    if (isUp) {</code></li>
<li class='green'><span class='hits'>8</span><code>                        current++;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>10</span><code>                    for (; isUp ? current &lt;= target : current &gt; target; isUp ? current++ : current--) {</code></li>
<li class='green'><span class='hits'>41</span><code>                        migrations.push([require(files[current]), current]);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new MigrationError("Invalid target " + target);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>10</span><code>                return migrations;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getMigrationFiles:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!this._migrationFiles) {</code></li>
<li class='green'><span class='hits'>12</span><code>                var retFiles = [];</code></li>
<li class='green'><span class='hits'>12</span><code>                return this.getFileNames().chain(hitch(this, function (files) {</code></li>
<li class='green'><span class='hits'>12</span><code>                    var l = files.length;</code></li>
<li class='green'><span class='hits'>12</span><code>                    if (l) {</code></li>
<li class='green'><span class='hits'>12</span><code>                        for (var i = 0; i &lt; l; i++) {</code></li>
<li class='green'><span class='hits'>54</span><code>                            var file = files[i];</code></li>
<li class='green'><span class='hits'>54</span><code>                            var version = this.getMigrationVersionFromFile(file);</code></li>
<li class='green'><span class='hits'>54</span><code>                            if (isUndefined(retFiles[version])) {</code></li>
<li class='green'><span class='hits'>53</span><code>                                retFiles[version] = file;</code></li>
<li class='green'><span class=''> </span><code>                            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                                throw new MigrationError("Duplicate migration number " + version);</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>11</span><code>                        if (isUndefined(retFiles[0])) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            retFiles.shift();</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>11</span><code>                        for (var j = 0; j &lt; l; j++) {</code></li>
<li class='green'><span class='hits'>52</span><code>                            if (isUndefined(retFiles[j])) {</code></li>
<li class='green'><span class='hits'>1</span><code>                                throw new MigrationError("Missing migration for " + j);</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>10</span><code>                    this._migrationFiles = retFiles;</code></li>
<li class='green'><span class='hits'>10</span><code>                    return retFiles;</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>6</span><code>                return when(this._migrationFiles);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getLatestMigrationVersion:function () {</code></li>
<li class='green'><span class='hits'>13</span><code>            if (!isUndefined(this._opts.target)) {</code></li>
<li class='green'><span class='hits'>5</span><code>                return when(this._opts.target);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>8</span><code>                return this._getMigrationFiles().chain(hitch(this, function (files) {</code></li>
<li class='green'><span class='hits'>6</span><code>                    var l = files[files.length - 1];</code></li>
<li class='green'><span class='hits'>6</span><code>                    return l ? this.getMigrationVersionFromFile(path.basename(l)) : null;</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getCurrentMigrationVersion:function () {</code></li>
<li class='green'><span class='hits'>11</span><code>            if (!isUndefined(this._opts.current)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                return when(this._opts.current);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>9</span><code>                return when(this._getSchemaDataset()).chain(hitch(this, function (ds) {</code></li>
<li class='green'><span class='hits'>9</span><code>                    return ds.get(this.column);</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _setMigrationVersion:function (version) {</code></li>
<li class='green'><span class='hits'>41</span><code>            var c = this.column;</code></li>
<li class='green'><span class='hits'>41</span><code>            return this._getSchemaDataset().chain(function (ds) {</code></li>
<li class='green'><span class='hits'>41</span><code>                var item = {};</code></li>
<li class='green'><span class='hits'>41</span><code>                item[c] = version;</code></li>
<li class='green'><span class='hits'>41</span><code>                return ds.update(item).chainBoth();</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _getSchemaDataset:function () {</code></li>
<li class='green'><span class='hits'>50</span><code>            var c = this.column, table = this.table;</code></li>
<li class='green'><span class='hits'>50</span><code>            if (!this.__schemaDataset) {</code></li>
<li class='green'><span class='hits'>11</span><code>                var ds = this.db.from(table);</code></li>
<li class='green'><span class='hits'>11</span><code>                return this.__createOrAlterMigrationTable().chain(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>11</span><code>                    return ds.isEmpty().chain(hitch(this, function (empty) {</code></li>
<li class='green'><span class='hits'>11</span><code>                        if (empty) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            var item = {};</code></li>
<li class='red'><span class='nohits'>0</span><code>                            item[c] = -1;</code></li>
<li class='red'><span class='nohits'>0</span><code>                            this.__schemaDataset = ds;</code></li>
<li class='red'><span class='nohits'>0</span><code>                            return ds.insert(item).chain(ds);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>11</span><code>                            return ds.count().chain(hitch(this, function (count) {</code></li>
<li class='green'><span class='hits'>11</span><code>                                if (count &gt; 1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                                    throw new Error("More than one row in migrator table");</code></li>
<li class='green'><span class=''> </span><code>                                } else {</code></li>
<li class='green'><span class='hits'>11</span><code>                                    this.__schemaDataset = ds;</code></li>
<li class='green'><span class='hits'>11</span><code>                                    return ds;</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }));</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>39</span><code>                return when(this.__schemaDataset);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __createOrAlterMigrationTable:function () {</code></li>
<li class='green'><span class='hits'>11</span><code>            var c = this.column, table = this.table, db = this.db;</code></li>
<li class='green'><span class='hits'>11</span><code>            var ds = this.db.from(table);</code></li>
<li class='green'><span class='hits'>11</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>11</span><code>            return db.tableExists(table).chain(hitch(this, function (exists) {</code></li>
<li class='green'><span class='hits'>11</span><code>                if (!exists) {</code></li>
<li class='green'><span class='hits'>7</span><code>                    return db.createTable(table, function () {</code></li>
<li class='green'><span class='hits'>7</span><code>                        this.column(c, "integer", {"default":-1, allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>4</span><code>                    return ds.columns.chain(function (columns) {</code></li>
<li class='green'><span class='hits'>4</span><code>                        if (columns.indexOf(c) === -1) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            db.addColumn(table, c, "integer", {"default":-1, allowNull:false});</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_SCHEMA_COLUMN:"version",</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_SCHEMA_TABLE:"schema_info"</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "IntegerMigrator");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Migrator that uses the file format {migrationName}.{timestamp}.js, where the timestamp</code></li>
<li class='green'><span class=''> </span><code> * can be anything greater than 20000101.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name TimestampMigrator</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.migrations.Migrator</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.migrations</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>var TimestampMigrator = define(Migrator, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function (db, directory, opts) {</code></li>
<li class='green'><span class='hits'>18</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>18</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>18</span><code>            this.target = opts.target;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        run:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>            var ret = new Promise(), DB = this.db, column = this.column;</code></li>
<li class='green'><span class='hits'>18</span><code>            return serial([this.__getMigrationFiles.bind(this), this._getSchemaDataset.bind(this)]).chain(function (res) {</code></li>
<li class='green'><span class='hits'>18</span><code>                var migrations = res[0], ds = res[1];</code></li>
<li class='green'><span class='hits'>18</span><code>                return asyncArray(migrations).forEach(function (curr) {</code></li>
<li class='green'><span class='hits'>70</span><code>                    var file = curr[0], migration = curr[1], direction = curr[2];</code></li>
<li class='green'><span class='hits'>70</span><code>                    var now = new Date();</code></li>
<li class='green'><span class='hits'>70</span><code>                    DB.logInfo("Begin applying migration file %s, direction: %s", file, direction);</code></li>
<li class='green'><span class='hits'>70</span><code>                    return DB.transaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>70</span><code>                        var fileLowerCase = file.toLowerCase();</code></li>
<li class='green'><span class='hits'>70</span><code>                        var query = {};</code></li>
<li class='green'><span class='hits'>70</span><code>                        query[column] = fileLowerCase;</code></li>
<li class='green'><span class='hits'>70</span><code>                        if (!isFunction(migration[direction])) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            return (direction === "up" ? ds.insert(query) : ds.filter(query).remove());</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>70</span><code>                            var nextP = new Promise();</code></li>
<li class='green'><span class='hits'>70</span><code>                            var dirP = migration[direction].apply(DB, [DB, nextP.resolve.bind(nextP)]);</code></li>
<li class='green'><span class='hits'>68</span><code>                            return (comb.isPromiseLike(dirP) ? dirP : nextP).chain(function () {</code></li>
<li class='green'><span class='hits'>68</span><code>                                return (direction === "up" ? ds.insert(query) : ds.filter(query).remove());</code></li>
<li class='green'><span class=''> </span><code>                            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    })).chain(function () {</code></li>
<li class='green'><span class='hits'>68</span><code>                            DB.logInfo("Finished applying migration file %s, direction: %s, took % 4dms seconds", file, direction, new Date() - now);</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class=''> </span><code>                }, this, 1);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getFileNames:function () {</code></li>
<li class='green'><span class='hits'>37</span><code>            return asyncArray(this._super(arguments)).sort(function (f1, f2) {</code></li>
<li class='green'><span class='hits'>184</span><code>                var ret = this.getMigrationVersionFromFile(f1) - this.getMigrationVersionFromFile(f2);</code></li>
<li class='green'><span class='hits'>184</span><code>                if (ret === 0) {</code></li>
<li class='green'><span class='hits'>4</span><code>                    var b1 = baseName(f1, ".js").split("."),</code></li>
<li class='green'><span class=''> </span><code>                        b2 = baseName(f2, ".js").split(".");</code></li>
<li class='green'><span class='hits'>4</span><code>                    b1 = b1[b1.length - 1];</code></li>
<li class='green'><span class='hits'>4</span><code>                    b2 = b2[b2.length - 1];</code></li>
<li class='green'><span class='hits'>4</span><code>                    ret = b1 &gt; b1 ? 1 : b1 &lt; b2 ? -1 : 0;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>184</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __getAppliedMigrations:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!this.__appliedMigrations) {</code></li>
<li class='green'><span class='hits'>18</span><code>                return this._getSchemaDataset().chain(hitch(this, function (ds) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    return when(ds.selectOrderMap(this.column), this.getFileNames()).chain(hitch(this, function (res) {</code></li>
<li class='green'><span class='hits'>18</span><code>                        var appliedMigrations = res[0], files = res[1].map(function (f) {</code></li>
<li class='green'><span class='hits'>92</span><code>                            return path.basename(f).toLowerCase();</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class='hits'>18</span><code>                        var l = appliedMigrations.length;</code></li>
<li class='green'><span class='hits'>18</span><code>                        if (l) {</code></li>
<li class='green'><span class='hits'>9</span><code>                            for (var i = 0; i &lt; l; i++) {</code></li>
<li class='green'><span class='hits'>39</span><code>                                if (files.indexOf(appliedMigrations[i]) == -1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                                    throw new MigrationError("Applied migrations file not found in directory " + appliedMigrations[i]);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class='hits'>9</span><code>                            this.__appliedMigrations = appliedMigrations;</code></li>
<li class='green'><span class='hits'>9</span><code>                            return appliedMigrations;</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>9</span><code>                            this.__appliedMigrations = [];</code></li>
<li class='green'><span class='hits'>9</span><code>                            return appliedMigrations;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return when(this.__appliedMigrations);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __getMigrationFiles:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>            var upMigrations = [], downMigrations = [], target = this.target;</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!this.__migrationFiles) {</code></li>
<li class='green'><span class='hits'>18</span><code>                return when(this.getFileNames(), this.__getAppliedMigrations()).chain(hitch(this, function (res) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    var files = res[0], appliedMigrations = res[1];</code></li>
<li class='green'><span class='hits'>18</span><code>                    var l = files.length;</code></li>
<li class='green'><span class='hits'>18</span><code>                    if (l &gt; 0) {</code></li>
<li class='green'><span class='hits'>18</span><code>                        for (var i = 0; i &lt; l; i++) {</code></li>
<li class='green'><span class='hits'>92</span><code>                            var file = files[i], f = path.basename(file), fLowerCase = f.toLowerCase(), index = appliedMigrations.indexOf(fLowerCase);</code></li>
<li class='green'><span class='hits'>92</span><code>                            if (!isUndefined(target)) {</code></li>
<li class='green'><span class='hits'>48</span><code>                                var version = this.getMigrationVersionFromFile(f);</code></li>
<li class='green'><span class='hits'>48</span><code>                                if (version &gt; target || (version === 0 &amp;&amp; target === version)) {</code></li>
<li class='green'><span class='hits'>35</span><code>                                    if (index !== -1) {</code></li>
<li class='green'><span class='hits'>26</span><code>                                        downMigrations.push([f, require(file), "down"]);</code></li>
<li class='green'><span class=''> </span><code>                                    }</code></li>
<li class='green'><span class='hits'>13</span><code>                                } else if (index === -1) {</code></li>
<li class='green'><span class='hits'>9</span><code>                                    upMigrations.push([f, require(file), "up"]);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class='hits'>44</span><code>                            } else if (index === -1) {</code></li>
<li class='green'><span class='hits'>35</span><code>                                upMigrations.push([f, require(file), "up"]);</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>18</span><code>                        this.__migrationFiles = upMigrations.concat(downMigrations.reverse());</code></li>
<li class='green'><span class='hits'>18</span><code>                        return this.__migrationFiles;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return when(this.__migrationFiles);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Returns the dataset for the schema_migrations table. If no such table</code></li>
<li class='green'><span class=''> </span><code>        // exists, it is automatically created.</code></li>
<li class='green'><span class=''> </span><code>        _getSchemaDataset:function () {</code></li>
<li class='green'><span class='hits'>36</span><code>            if (!this.__schemaDataset) {</code></li>
<li class='green'><span class='hits'>18</span><code>                var ds = this.db.from(this.table);</code></li>
<li class='green'><span class='hits'>18</span><code>                return this.__createTable().chain(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>18</span><code>                    return (this.__schemaDataset = ds);</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>18</span><code>                return when(this.__schemaDataset);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __convertSchemaInfo:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            var ret = new Promise(), c = this.column;</code></li>
<li class='green'><span class='hits'>1</span><code>            var ds = this.db.from(this.table);</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.db.from(IntegerMigrator.DEFAULT_SCHEMA_TABLE).get(IntegerMigrator.DEFAULT_SCHEMA_COLUMN).chain(hitch(this, function (version) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.getFileNames().chain(hitch(this, function (files) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    var l = files.length, inserts = [];</code></li>
<li class='green'><span class='hits'>1</span><code>                    if (l &gt; 0) {</code></li>
<li class='green'><span class='hits'>1</span><code>                        for (var i = 0; i &lt; l; i++) {</code></li>
<li class='green'><span class='hits'>7</span><code>                            var f = path.basename(files[i]);</code></li>
<li class='green'><span class='hits'>7</span><code>                            if (this.getMigrationVersionFromFile(f) &lt;= version) {</code></li>
<li class='green'><span class='hits'>5</span><code>                                var insert = {};</code></li>
<li class='green'><span class='hits'>5</span><code>                                insert[c] = f;</code></li>
<li class='green'><span class='hits'>5</span><code>                                inserts.push(ds.insert(insert));</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1</span><code>                    return when(inserts);</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __createTable:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>            var c = this.column, table = this.table, db = this.db, intMigrationTable = IntegerMigrator.DEFAULT_SCHEMA_TABLE;</code></li>
<li class='green'><span class='hits'>18</span><code>            var ds = this.db.from(table);</code></li>
<li class='green'><span class='hits'>18</span><code>            return when(db.tableExists(table), db.tableExists(intMigrationTable)).chain(hitch(this, function (res) {</code></li>
<li class='green'><span class='hits'>18</span><code>                var exists = res[0], intMigratorExists = res[1];</code></li>
<li class='green'><span class='hits'>18</span><code>                if (!exists) {</code></li>
<li class='green'><span class='hits'>10</span><code>                    return db.createTable(table,function () {</code></li>
<li class='green'><span class='hits'>10</span><code>                        this.column(c, String, {primaryKey:true});</code></li>
<li class='green'><span class=''> </span><code>                    }).chain(function () {</code></li>
<li class='green'><span class='hits'>10</span><code>                        if (intMigratorExists) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            return db.from(intMigrationTable).all().chain(hitch(this, function (versions) {</code></li>
<li class='green'><span class='hits'>1</span><code>                                var version;</code></li>
<li class='green'><span class='hits'>1</span><code>                                if (versions.length === 1 &amp;&amp; (version = versions[0]) &amp;&amp; isNumber(version[Object.keys(version)[0]])) {</code></li>
<li class='green'><span class='hits'>1</span><code>                                    return this.__convertSchemaInfo();</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }));</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>8</span><code>                    return ds.columns.chain(hitch(this, function (columns) {</code></li>
<li class='green'><span class='hits'>8</span><code>                        if (columns.indexOf(c) === -1) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            throw new MigrationError(format("Migration table %s does not contain column %s", table, c));</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_SCHEMA_COLUMN:"filename",</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_SCHEMA_TABLE:"schema_migrations"</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "TimestampMigrator");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>exports.run = function () {</code></li>
<li class='green'><span class='hits'>31</span><code>    return Migrator.run.apply(Migrator, arguments);</code></li>
<li class='green'><span class=''> </span><code>};</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="dataset/sql.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>dataset/sql.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>92.86</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>1685</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>504</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>36</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="dataset/sql.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    toArray = array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    intersect = array.intersect,</code></li>
<li class='green'><span class=''> </span><code>    compact = array.compact,</code></li>
<li class='green'><span class=''> </span><code>    string = comb.string,</code></li>
<li class='green'><span class=''> </span><code>    format = string.format,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isNumber = comb.isNumber,</code></li>
<li class='green'><span class=''> </span><code>    isDate = comb.isDate,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isObject = comb.isObject,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    Expression = sql.Expression,</code></li>
<li class='green'><span class=''> </span><code>    ComplexExpression = sql.ComplexExpression,</code></li>
<li class='green'><span class=''> </span><code>    AliasedExpression = sql.AliasedExpression,</code></li>
<li class='green'><span class=''> </span><code>    Identifier = sql.Identifier,</code></li>
<li class='green'><span class=''> </span><code>    QualifiedIdentifier = sql.QualifiedIdentifier,</code></li>
<li class='green'><span class=''> </span><code>    OrderedExpression = sql.OrderedExpression,</code></li>
<li class='green'><span class=''> </span><code>    CaseExpression = sql.CaseExpression,</code></li>
<li class='green'><span class=''> </span><code>    SubScript = sql.SubScript,</code></li>
<li class='green'><span class=''> </span><code>    NumericExpression = sql.NumericExpression,</code></li>
<li class='green'><span class=''> </span><code>    ColumnAll = sql.ColumnAll,</code></li>
<li class='green'><span class=''> </span><code>    Cast = sql.Cast,</code></li>
<li class='green'><span class=''> </span><code>    StringExpression = sql.StringExpression,</code></li>
<li class='green'><span class=''> </span><code>    BooleanExpression = sql.BooleanExpression,</code></li>
<li class='green'><span class=''> </span><code>    SQLFunction = sql.SQLFunction,</code></li>
<li class='green'><span class=''> </span><code>    LiteralString = sql.LiteralString,</code></li>
<li class='green'><span class=''> </span><code>    PlaceHolderLiteralString = sql.PlaceHolderLiteralString,</code></li>
<li class='green'><span class=''> </span><code>    QueryError = require("../errors").QueryError, patio;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Dataset;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var clauseMethods = function (type, clauses) {</code></li>
<li class='green'><span class='hits'>13</span><code>    if (isString(clauses)) {</code></li>
<li class='green'><span class='hits'>13</span><code>        clauses = clauses.split(" ");</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class='hits'>13</span><code>    return clauses.map(function (clause) {</code></li>
<li class='green'><span class='hits'>84</span><code>        return ["_", type, clause.charAt(0).toUpperCase(), clause.substr(1), "Sql"].join("")</code></li>
<li class='green'><span class=''> </span><code>    });</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Dataset mixin that provides functions to the {@link patio.dataset.Dataset} to</code></li>
<li class='green'><span class=''> </span><code>         * create SELECT, UPDATE, CREATE, and DELETE SQL statements, based off of the the</code></li>
<li class='green'><span class=''> </span><code>         * methods invoked in the {@link patio.dataset._Query}</code></li>
<li class='green'><span class=''> </span><code>         * mixin. This class should not be used directly by</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @memberOf patio.dataset</code></li>
<li class='green'><span class=''> </span><code>         * @name _Query</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} sql Readonly property that returns a SELECT statement.</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} deleteSql DELETE SQL query string.  See {@link patio.dataset._Actions#delete}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *       dataset.filter(function(){</code></li>
<li class='green'><span class=''> </span><code>         *           return this.price.gte(100);</code></li>
<li class='green'><span class=''> </span><code>         *       }).deleteSql;</code></li>
<li class='green'><span class=''> </span><code>         *           // =&gt; "DELETE FROM items WHERE (price &gt;= 100)"</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} selectSql  Returns a SELECT SQL query string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *       DB.from("items").selectSql;</code></li>
<li class='green'><span class=''> </span><code>         *              //=&gt; "SELECT * FROM items"</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} truncateSql Returns a TRUNCATE SQL query string.  See {@link patio.dataset._Actions#truncate}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *       DB.from("items").truncateSql();</code></li>
<li class='green'><span class=''> </span><code>         *              //=&gt; 'TRUNCATE items'</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @property {String} exists  Returns an EXISTS clause for the dataset as a {@link patio.sql.LiteralString}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *       var ds = DB.from("test");</code></li>
<li class='green'><span class=''> </span><code>         *       ds.filter(ds.filter(sql.price.lt(100))).exists()).sql;</code></li>
<li class='green'><span class=''> </span><code>         *              //=&gt; 'SELECT * FROM test WHERE (EXISTS (SELECT * FROM test WHERE (price &lt; 100)))'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class=''> </span><code>            //We initialize these here because otherwise</code></li>
<li class='green'><span class=''> </span><code>            //the will be blank because of recursive dependencies.</code></li>
<li class='green'><span class='hits'>28667</span><code>            !patio &amp;&amp; (patio = require("../index"));</code></li>
<li class='green'><span class='hits'>28667</span><code>            !Dataset &amp;&amp; (Dataset = patio.Dataset);</code></li>
<li class='green'><span class='hits'>28667</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns an INSERT SQL query string.  See {@link patio.dataset._Actions#insert}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insertSql({a : 1});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO items (a) VALUES (1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var ds = DB.from("test");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //default values</code></li>
<li class='green'><span class=''> </span><code>         * ds.insertSql();</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO test DEFAULT VALUES</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //with hash</code></li>
<li class='green'><span class=''> </span><code>         * ds.insertSql({name:'wxyz', price:342});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO test (name, price) VALUES ('wxyz', 342)</code></li>
<li class='green'><span class=''> </span><code>         * ds.insertSql({});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO test DEFAULT VALUES</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //object that has a values property</code></li>
<li class='green'><span class=''> </span><code>         * ds.insertSql({values:{a:1}});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO test (a) VALUES (1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //arbitrary value</code></li>
<li class='green'><span class=''> </span><code>         * ds.insertSql(123);</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO test VALUES (123)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //with dataset</code></li>
<li class='green'><span class=''> </span><code>         * ds.insertSql(DB.from("something").filter({x:2}));</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO test SELECT * FROM something WHERE (x = 2)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //with array</code></li>
<li class='green'><span class=''> </span><code>         * ds.insertSql('a', 2, 6.5);</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO test VALUES ('a', 2, 6.5)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError} if there are Different number of values and columns given to insertSql or</code></li>
<li class='green'><span class=''> </span><code>         *                                  if an invalid BooleanExpresion is given.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset|patio.sql.LiteralString|Array|Object|patio.sql.BooleanExpression|...} values  values to</code></li>
<li class='green'><span class=''> </span><code>         *      insert into the database. The INSERT statement generated depends on the type.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Empty object| Or no arugments: then DEFAULT VALUES is used.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Object: the keys will be used as the columns, and values will be the values inserted.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Single {@link patio.Dataset} : an insert with subselect will be performed.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Array with {@link patio.Dataset} : The array will be used for columns and a subselect will performed with the dataset for the values.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;{@link patio.sql.LiteralString} : the literal value will be used.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Single Array : the values in the array will be used as the VALUES clause.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Two Arrays: the first array is the columns the second array is the values.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;{@link patio.sql.BooleanExpression} : the expression will be used as the values.</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;An arbitrary number of arguments : the {@link patio.Dataset#literal} version of the values will be used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} a INSERT SQL query string</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        insertSql:function (values) {</code></li>
<li class='green'><span class='hits'>1483</span><code>            values = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>1483</span><code>            var opts = this.__opts;</code></li>
<li class='green'><span class='hits'>1483</span><code>            if (opts.sql) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this._staticSql(opts.sql);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1483</span><code>            this.__checkModificationAllowed();</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1479</span><code>            var columns = [];</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1479</span><code>            switch (values.length) {</code></li>
<li class='green'><span class=''> </span><code>                case 0 :</code></li>
<li class='green'><span class=''> </span><code>                    //we have no values</code></li>
<li class='green'><span class='hits'>14</span><code>                    return this.insertSql({});</code></li>
<li class='green'><span class=''> </span><code>                case 1 :</code></li>
<li class='green'><span class='hits'>1387</span><code>                    var vals = values[0], v;</code></li>
<li class='green'><span class='hits'>1387</span><code>                    if (isInstanceOf(vals, Dataset, LiteralString) || isArray(vals)) {</code></li>
<li class='green'><span class='hits'>10</span><code>                        values = vals;</code></li>
<li class='green'><span class='hits'>1377</span><code>                    } else if (vals.hasOwnProperty("values") &amp;&amp; isObject((v = vals.values))) {</code></li>
<li class='green'><span class='hits'>2</span><code>                        return this.insertSql(v);</code></li>
<li class='green'><span class='hits'>1375</span><code>                    } else if (isHash(vals)) {</code></li>
<li class='green'><span class='hits'>1369</span><code>                        vals = merge({}, opts.defaults || {}, vals);</code></li>
<li class='green'><span class='hits'>1369</span><code>                        vals = merge({}, vals, opts.overrides || {});</code></li>
<li class='green'><span class='hits'>1369</span><code>                        values = [];</code></li>
<li class='green'><span class='hits'>1369</span><code>                        for (var i in vals) {</code></li>
<li class='green'><span class='hits'>6699</span><code>                            columns.push(i);</code></li>
<li class='green'><span class='hits'>6699</span><code>                            values.push(vals[i]);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>6</span><code>                    } else if (isInstanceOf(vals, BooleanExpression)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                        var op = vals.op;</code></li>
<li class='green'><span class='hits'>1</span><code>                        values = [];</code></li>
<li class='green'><span class='hits'>1</span><code>                        if (!isUndefinedOrNull(this._static.TWO_ARITY_OPERATORS[op])) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            var args = vals.args;</code></li>
<li class='green'><span class='hits'>1</span><code>                            columns.push(args[0]);</code></li>
<li class='green'><span class='hits'>1</span><code>                            values.push(args[1]);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            throw new QueryError("Invalid Expression op: " + op);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1385</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>                case 2 :</code></li>
<li class='green'><span class='hits'>75</span><code>                    var v0 = values[0], v1 = values[1]</code></li>
<li class='green'><span class='hits'>75</span><code>                    if (isArray(v0) &amp;&amp; isArray(v1) || isInstanceOf(v1, Dataset, LiteralString)) {</code></li>
<li class='green'><span class='hits'>70</span><code>                        columns = v0, values = v1;</code></li>
<li class='green'><span class='hits'>70</span><code>                        if (isArray(values) &amp;&amp; columns.length != values.length) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            throw new QueryError("Different number of values and columns given to insertSql");</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>75</span><code>                    break;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1463</span><code>            columns = columns.map(function (k) {</code></li>
<li class='green'><span class='hits'>6800</span><code>                return isString(k) ? new Identifier(k) : k;</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>1463</span><code>            return this.mergeOptions({columns:columns, values:values})._insertSql();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns an array of insert statements for inserting multiple records.</code></li>
<li class='green'><span class=''> </span><code>         * This method is used by {@link patio.dataset._Actions#multiInsert} to format insert statements.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;This method is not typically used directly.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;b&gt;Note:&lt;/b&gt;This method should be overridden by descendants if there is support for</code></li>
<li class='green'><span class=''> </span><code>         *                      inserting multiple records in a single SQL statement.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Array} columns The columns to insert values for.</code></li>
<li class='green'><span class=''> </span><code>         *                  This array will be used as the base for each values item in the values array.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Array[Array]} values Array of arrays of values to insert into the columns.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String[]} array of insert statements.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        multiInsertSql:function (columns, values) {</code></li>
<li class='green'><span class='hits'>28</span><code>            return values.map(function (r) {</code></li>
<li class='green'><span class='hits'>56</span><code>                return this.insertSql(columns, r)</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Formats an UPDATE statement using the given values.  See {@link patio.dataset._Actions#update}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").updateSql({price : 100, category : 'software'});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; "UPDATE items SET price = 100, category = 'software'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throw {QueryError} If the dataset is grouped or includes more than one table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*...} Variable number of values to update the table with.</code></li>
<li class='green'><span class=''> </span><code>         *  The UPDATE statement created depends on the values passed in.</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *              &lt;li&gt;Object : the keys will be used as the columns and the values will be the values to set to columns to&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *              &lt;li&gt;{@link patio.sql.Expression} : the {@link patio.dataset._Sql#literal} representation of the</code></li>
<li class='green'><span class=''> </span><code>         *                      {@link patio.sql.Expression} will be used as the value</code></li>
<li class='green'><span class=''> </span><code>         *              &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *              &lt;/li&gt; Other : the {@link patio.dataset._Sql#literal} value will be used as the value&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the UPDATE statement.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        updateSql:function (values) {</code></li>
<li class='green'><span class='hits'>237</span><code>            values = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>237</span><code>            if (this.__opts.sql) return this._staticSql(this.__opts.sql);</code></li>
<li class='green'><span class='hits'>237</span><code>            this.__checkModificationAllowed();</code></li>
<li class='green'><span class='hits'>233</span><code>            return this.mergeOptions({values:values})._updateSql();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a qualified column name (including a table name) if the column</code></li>
<li class='green'><span class=''> </span><code>         * name isn't already qualified.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.qualifiedColumnName("b1", "items");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; items.b1</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.qualifiedColumnName("ccc__b"));</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; 'ccc.b'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.qualifiedColumnName("ccc__b", "items"));</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; 'ccc.b'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} column the column to qualify. If the column is already qualified (e.g. ccc__b) then the</code></li>
<li class='green'><span class=''> </span><code>         *                        table name (e.g. ccc) will override the provided table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} table the name of the table to qualify the column to.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the qualified column name..</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        qualifiedColumnName:function (column, table) {</code></li>
<li class='green'><span class='hits'>1212</span><code>            if (isString(column)) {</code></li>
<li class='green'><span class='hits'>1209</span><code>                var parts = this._splitString(column);</code></li>
<li class='green'><span class='hits'>1209</span><code>                var columnTable = parts[0], alias = parts[2], tableAlias;</code></li>
<li class='green'><span class='hits'>1209</span><code>                column = parts[1];</code></li>
<li class='green'><span class='hits'>1209</span><code>                if (!columnTable) {</code></li>
<li class='green'><span class='hits'>1207</span><code>                    if (isInstanceOf(table, Identifier)) {</code></li>
<li class='green'><span class='hits'>1184</span><code>                        table = table.value;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1207</span><code>                    if (isInstanceOf(table, AliasedExpression)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        tableAlias = table.alias;</code></li>
<li class='green'><span class='hits'>1207</span><code>                    } else if (isInstanceOf(table, QualifiedIdentifier)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                        tableAlias = table;</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>1206</span><code>                        parts = this._splitString(table);</code></li>
<li class='green'><span class='hits'>1206</span><code>                        var schema = parts[0], tableAlias = parts[2];</code></li>
<li class='green'><span class='hits'>1206</span><code>                        table = parts[1];</code></li>
<li class='green'><span class='hits'>1206</span><code>                        if (schema) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            tableAlias = new Identifier(tableAlias) || new QualifiedIdentifier(schema, table);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1207</span><code>                    columnTable = tableAlias || table;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1209</span><code>                return new QualifiedIdentifier(columnTable, column);</code></li>
<li class='green'><span class='hits'>3</span><code>            } else if (isInstanceOf(column, Identifier)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return column.qualify(table);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                return column;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a unique table alias that hasn't already been used in this dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").unusedTableAlias("t");</code></li>
<li class='green'><span class=''> </span><code>         *       //=&gt; "t"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").unusedTableAlias("table");</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; "table0"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table", "table0"]).unusedTableAlias("table");</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; "table1"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} tableAlias the table to get an unused alias for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the implicit alias that is in tableAlias with a possible "N"</code></li>
<li class='green'><span class=''> </span><code>         *                  if the alias has already been used, where N is an integer starting at 0.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        unusedTableAlias:function (tableAlias) {</code></li>
<li class='green'><span class='hits'>11</span><code>            tableAlias = this._toTableName(tableAlias);</code></li>
<li class='green'><span class='hits'>11</span><code>            var usedAliases = [], from, join;</code></li>
<li class='green'><span class='hits'>11</span><code>            if ((from = this.__opts.from) != null) {</code></li>
<li class='green'><span class='hits'>11</span><code>                usedAliases = usedAliases.concat(from.map(function (n) {</code></li>
<li class='green'><span class='hits'>13</span><code>                    return this._toTableName(n)</code></li>
<li class='green'><span class=''> </span><code>                }, this));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>11</span><code>            if ((join = this.__opts.join) != null) {</code></li>
<li class='green'><span class='hits'>1</span><code>                usedAliases = usedAliases.concat(join.map(function (join) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    if (join.tableAlias) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        return this.__toAliasedTableName(join.tableAlias);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                        return this._toTableName(join.table);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }, this));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>11</span><code>            if (usedAliases.indexOf(tableAlias) != -1) {</code></li>
<li class='green'><span class='hits'>10</span><code>                var base = tableAlias, i = 0;</code></li>
<li class='green'><span class='hits'>10</span><code>                do {</code></li>
<li class='green'><span class='hits'>13</span><code>                    tableAlias = string.format("%s%d", base, i++);</code></li>
<li class='green'><span class=''> </span><code>                } while (usedAliases.indexOf(tableAlias) != -1)</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>11</span><code>            return tableAlias;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a literal representation of a value to be used as part</code></li>
<li class='green'><span class=''> </span><code>         * of an SQL expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").literal("abc'def\\") //=&gt; "'abc''def\\\\'"</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").literal("items__id") //=&gt; "items.id"</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").literal([1, 2, 3]) //=&gt; "(1, 2, 3)"</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").literal(DB.from("items")) //=&gt; "(SELECT * FROM items)"</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").literal(sql.x.plus(1).gt("y")); //=&gt; "((x + 1) &gt; y)"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError} If an unsupported object is given.</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} v the value to convert the the SQL literal representation</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} a literal representation of the value.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        literal:function (v) {</code></li>
<li class='green'><span class='hits'>43926</span><code>            if (isInstanceOf(v, LiteralString)) {</code></li>
<li class='green'><span class='hits'>218</span><code>                return "" + v;</code></li>
<li class='green'><span class='hits'>43708</span><code>            } else if (isString(v)) {</code></li>
<li class='green'><span class='hits'>6164</span><code>                return this._literalString(v);</code></li>
<li class='green'><span class='hits'>37544</span><code>            } else if (isNumber(v)) {</code></li>
<li class='green'><span class='hits'>7025</span><code>                return this._literalNumber(v);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>30519</span><code>            else if (isInstanceOf(v, Expression)) {</code></li>
<li class='green'><span class='hits'>27937</span><code>                return this._literalExpression(v);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2582</span><code>            else if (isInstanceOf(v, Dataset)) {</code></li>
<li class='green'><span class='hits'>104</span><code>                return this._literalDataset(v);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2478</span><code>            else if (isArray(v)) {</code></li>
<li class='green'><span class='hits'>2106</span><code>                return this._literalArray(v);</code></li>
<li class='green'><span class='hits'>372</span><code>            } else if (isInstanceOf(v, sql.Year)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this._literalYear(v);</code></li>
<li class='green'><span class='hits'>371</span><code>            } else if (isInstanceOf(v, sql.TimeStamp, sql.DateTime)) {</code></li>
<li class='green'><span class='hits'>31</span><code>                return this._literalTimestamp(v);</code></li>
<li class='green'><span class='hits'>340</span><code>            } else if (isDate(v)) {</code></li>
<li class='green'><span class='hits'>7</span><code>                return this._literalDate(v);</code></li>
<li class='green'><span class='hits'>333</span><code>            } else if (isInstanceOf(v, sql.Time)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this._literalTime(v);</code></li>
<li class='green'><span class='hits'>332</span><code>            } else if (Buffer.isBuffer(v)) {</code></li>
<li class='green'><span class='hits'>11</span><code>                return this._literalBuffer(v);</code></li>
<li class='green'><span class='hits'>321</span><code>            } else if (isNull(v)) {</code></li>
<li class='green'><span class='hits'>232</span><code>                return this._literalNull();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>89</span><code>            else if (isBoolean(v)) {</code></li>
<li class='green'><span class='hits'>79</span><code>                return this._literalBoolean(v);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>10</span><code>            else if (isHash(v)) {</code></li>
<li class='green'><span class='hits'>6</span><code>                return this._literalObject(v);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>4</span><code>                return this._literalOther(v);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //BEGIN PROTECTED</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Qualify the given expression to the given table.</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.sql.Expression} column the expression to qualify</code></li>
<li class='green'><span class=''> </span><code>         * @param table the table to qualify the expression to</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _qualifiedExpression:function (e, table) {</code></li>
<li class='green'><span class='hits'>349</span><code>            var h, i, args;</code></li>
<li class='green'><span class='hits'>349</span><code>            if (isString(e)) {</code></li>
<li class='green'><span class=''> </span><code>                //this should not be hit but here just for completeness</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.stringToIdentifier(e);</code></li>
<li class='green'><span class='hits'>349</span><code>            } else if (isArray(e)) {</code></li>
<li class='green'><span class='hits'>73</span><code>                return e.map(function (exp) {</code></li>
<li class='green'><span class='hits'>164</span><code>                    return this._qualifiedExpression(exp, table);</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class='hits'>276</span><code>            } else if (isInstanceOf(e, Identifier)) {</code></li>
<li class='green'><span class='hits'>59</span><code>                return new QualifiedIdentifier(table, e);</code></li>
<li class='green'><span class='hits'>217</span><code>            } else if (isInstanceOf(e, OrderedExpression)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                return new OrderedExpression(this._qualifiedExpression(e.expression, table), e.descending,</code></li>
<li class='green'><span class=''> </span><code>                    {nulls:e.nulls});</code></li>
<li class='green'><span class='hits'>215</span><code>            } else if (isInstanceOf(e, AliasedExpression)) {</code></li>
<li class='green'><span class='hits'>72</span><code>                return new AliasedExpression(this._qualifiedExpression(e.expression, table), e.alias);</code></li>
<li class='green'><span class='hits'>143</span><code>            } else if (isInstanceOf(e, CaseExpression)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                args = [this._qualifiedExpression(e.conditions, table), this._qualifiedExpression(e.def, table)];</code></li>
<li class='green'><span class='hits'>2</span><code>                if (e.hasExpression) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    args.push(this._qualifiedExpression(e.expression, table));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>2</span><code>                return CaseExpression.fromArgs(args);</code></li>
<li class='green'><span class='hits'>141</span><code>            } else if (isInstanceOf(e, Cast)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return new Cast(this._qualifiedExpression(e.expr, table), e.type);</code></li>
<li class='green'><span class='hits'>140</span><code>            } else if (isInstanceOf(e, SQLFunction)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                return SQLFunction.fromArgs([e.f].concat(this._qualifiedExpression(e.args, table)));</code></li>
<li class='green'><span class='hits'>138</span><code>            } else if (isInstanceOf(e, ComplexExpression)) {</code></li>
<li class='green'><span class='hits'>30</span><code>                return ComplexExpression.fromArgs([e.op].concat(this._qualifiedExpression(e.args, table)));</code></li>
<li class='green'><span class='hits'>108</span><code>            } else if (isInstanceOf(e, SubScript)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return new SubScript(this._qualifiedExpression(e.f, table), this._qualifiedExpression(e.sub, table));</code></li>
<li class='green'><span class='hits'>107</span><code>            } else if (isInstanceOf(e, PlaceHolderLiteralString)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                args = [];</code></li>
<li class='green'><span class='hits'>3</span><code>                var eArgs = e.args;</code></li>
<li class='green'><span class='hits'>3</span><code>                if (isHash(eArgs)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    h = {};</code></li>
<li class='green'><span class='hits'>1</span><code>                    for (i in eArgs) {</code></li>
<li class='green'><span class='hits'>2</span><code>                        h[i] = this._qualifiedExpression(eArgs[i], table);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1</span><code>                    args = h;</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                    args = this._qualifiedExpression(eArgs, table);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>3</span><code>                return new PlaceHolderLiteralString(e.str, args, e.parens);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>104</span><code>            } else if (isHash(e)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                h = {};</code></li>
<li class='red'><span class='nohits'>0</span><code>                for (i in e) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    h[this._qualifiedExpression(i, table) + ""] = this._qualifiedExpression(e[i], table);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='red'><span class='nohits'>0</span><code>                return h;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>104</span><code>                return e;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a string that is the name of the table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError} If the name is not a String {@link patio.sql.Identifier},</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.sql.QualifiedIdentifier} or {@link patio.sql.AliasedExpression}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier|patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} name</code></li>
<li class='green'><span class=''> </span><code>         *          the object to get the table name from.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the name of the table.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _toTableName:function (name) {</code></li>
<li class='green'><span class='hits'>67</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>67</span><code>            if (isString(name)) {</code></li>
<li class='green'><span class='hits'>10</span><code>                var parts = this._splitString(name);</code></li>
<li class='green'><span class='hits'>10</span><code>                var schema = parts[0], table = parts[1], alias = parts[2];</code></li>
<li class='green'><span class='hits'>10</span><code>                ret = (schema || alias) ? alias || table : table;</code></li>
<li class='green'><span class='hits'>57</span><code>            } else if (isInstanceOf(name, Identifier)) {</code></li>
<li class='green'><span class='hits'>54</span><code>                ret = name.value;</code></li>
<li class='green'><span class='hits'>3</span><code>            } else if (isInstanceOf(name, QualifiedIdentifier)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = this._toTableName(name.column);</code></li>
<li class='green'><span class='hits'>2</span><code>            } else if (isInstanceOf(name, AliasedExpression)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = this.__toAliasedTableName(name.alias);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new QueryError("Invalid object to retrieve the table name from");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>67</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return the unaliased part of the identifier.  Handles both</code></li>
<li class='green'><span class=''> </span><code>         * implicit aliases in strings, as well as {@link patio.sql.AliasedExpression}s.</code></li>
<li class='green'><span class=''> </span><code>         * Other objects are returned as is.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.AliasedExpression|*} tableAlias the object to un alias</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.QualifiedIdentifier|String|*} the unaliased portion of the identifier</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _unaliasedIdentifier:function (c) {</code></li>
<li class='green'><span class='hits'>35</span><code>            if (isString(c)) {</code></li>
<li class='green'><span class='hits'>30</span><code>                var parts = this._splitString(c);</code></li>
<li class='green'><span class='hits'>30</span><code>                var table = parts[0], column = parts[1];</code></li>
<li class='green'><span class='hits'>30</span><code>                if (table) {</code></li>
<li class='green'><span class='hits'>5</span><code>                    return new QualifiedIdentifier(table, column);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>25</span><code>                return column;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>5</span><code>            } else if (isInstanceOf(c, AliasedExpression)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return c.expression;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                return c;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return a [@link patio.sql._Query#fromSelf} dataset if an order or limit is specified, so it works as expected</code></li>
<li class='green'><span class=''> </span><code>         * with UNION, EXCEPT, and INTERSECT clauses.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _compoundFromSelf:function () {</code></li>
<li class='green'><span class='hits'>102</span><code>            var opts = this.__opts;</code></li>
<li class='green'><span class='hits'>102</span><code>            return (opts["limit"] || opts["order"]) ? this.fromSelf() : this;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return true if the dataset has a non-null value for any key in opts.</code></li>
<li class='green'><span class=''> </span><code>         * @param opts the options to compate this datasets options to</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Boolean} true if the dataset has a non-null value for any key in opts.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _optionsOverlap:function (opts) {</code></li>
<li class='green'><span class='hits'>143</span><code>            var o = [];</code></li>
<li class='green'><span class='hits'>143</span><code>            for (var i in this.__opts) {</code></li>
<li class='green'><span class='hits'>349</span><code>                if (!isUndefinedOrNull(this.__opts[i])) {</code></li>
<li class='green'><span class='hits'>200</span><code>                    o.push(i);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>143</span><code>            return !(intersect(compact(o), opts).length == 0);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Formats in INSERT statement using the stored columns and values.</code></li>
<li class='green'><span class=''> </span><code>        _insertSql:function () {</code></li>
<li class='green'><span class='hits'>1455</span><code>            return this._clauseSql("insert");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Formats an UPDATE statement using the stored values.</code></li>
<li class='green'><span class=''> </span><code>        _updateSql:function () {</code></li>
<li class='green'><span class='hits'>233</span><code>            return this._clauseSql("update")</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code>        //Formats the truncate statement.  Assumes the table given has already been</code></li>
<li class='green'><span class=''> </span><code>        //literalized.</code></li>
<li class='green'><span class=''> </span><code>        _truncateSql:function (table) {</code></li>
<li class='green'><span class='hits'>29</span><code>            return "TRUNCATE TABLE" + table;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Prepares an SQL statement by calling all clause methods for the given statement type.</code></li>
<li class='green'><span class=''> </span><code>        _clauseSql:function (type) {</code></li>
<li class='green'><span class='hits'>6658</span><code>            var sql = [("" + type).toUpperCase()];</code></li>
<li class='green'><span class='hits'>6658</span><code>            try {</code></li>
<li class='green'><span class='hits'>6658</span><code>                this._static[sql + "_CLAUSE_METHODS"].forEach(function (m) {</code></li>
<li class='green'><span class='hits'>66207</span><code>                    if (m.match("With")) {</code></li>
<li class='green'><span class='hits'>6381</span><code>                        this[m](sql);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>59826</span><code>                        var sqlRet = this[m]();</code></li>
<li class='green'><span class='hits'>59824</span><code>                        if (sqlRet) {</code></li>
<li class='green'><span class='hits'>21305</span><code>                            sql.push(sqlRet);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            } catch (e) {</code></li>
<li class='green'><span class='hits'>2</span><code>                throw e;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>6656</span><code>            return sql.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //SQL fragment specifying the table to insert INTO</code></li>
<li class='green'><span class=''> </span><code>        _insertIntoSql:function (sql) {</code></li>
<li class='green'><span class='hits'>1464</span><code>            return string.format(" INTO%s", this._sourceList(this.__opts.from));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //SQL fragment specifying the columns to insert into</code></li>
<li class='green'><span class=''> </span><code>        _insertColumnsSql:function (sql) {</code></li>
<li class='green'><span class='hits'>1454</span><code>            var columns = this.__opts.columns, ret = "";</code></li>
<li class='green'><span class='hits'>1454</span><code>            if (columns &amp;&amp; columns.length) {</code></li>
<li class='green'><span class='hits'>1401</span><code>                ret = " (" + columns.map(</code></li>
<li class='green'><span class=''> </span><code>                    function (c) {</code></li>
<li class='green'><span class='hits'>6800</span><code>                        return c.toString(this);</code></li>
<li class='green'><span class=''> </span><code>                    }, this).join(this._static.COMMA_SEPARATOR) + ")";</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1454</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //SQL fragment specifying the values to insert.</code></li>
<li class='green'><span class=''> </span><code>        _insertValuesSql:function () {</code></li>
<li class='green'><span class='hits'>1454</span><code>            var values = this.__opts.values, ret = [];</code></li>
<li class='green'><span class='hits'>1454</span><code>            if (isArray(values)) {</code></li>
<li class='green'><span class='hits'>1436</span><code>                ret.push(values.length == 0 ? " DEFAULT VALUES" : " VALUES " + this.literal(values));</code></li>
<li class='green'><span class='hits'>18</span><code>            } else if (isInstanceOf(values, Dataset)) {</code></li>
<li class='green'><span class='hits'>6</span><code>                ret.push(" " + this._subselectSql(values));</code></li>
<li class='green'><span class='hits'>12</span><code>            } else if (isInstanceOf(values, LiteralString)) {</code></li>
<li class='green'><span class='hits'>11</span><code>                ret.push(" " + values.toString(this));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("Unsupported INSERT values type, should be an array or dataset");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1453</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //SQL fragment for Array</code></li>
<li class='green'><span class=''> </span><code>        _arraySql:function (a) {</code></li>
<li class='green'><span class='hits'>2107</span><code>            return !a.length ? '(NULL)' : "(" + this.__expressionList(a) + ")";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //This method quotes the given name with the SQL standard double quote.</code></li>
<li class='green'><span class=''> </span><code>        //should be overridden by subclasses to provide quoting not matching the</code></li>
<li class='green'><span class=''> </span><code>        //SQL standard, such as backtick (used by MySQL and SQLite).</code></li>
<li class='green'><span class=''> </span><code>        _quotedIdentifier:function (name) {</code></li>
<li class='green'><span class='hits'>15</span><code>            return string.format("\"%s\"", ("" + name).replace('"', '""'));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /*</code></li>
<li class='green'><span class=''> </span><code>         This section is for easier adapter overrides of sql formatting. These metthods are used by patio.sql.* toString</code></li>
<li class='green'><span class=''> </span><code>         methods to generate sql.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private  For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for AliasedExpression</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        aliasedExpressionSql:function (ae) {</code></li>
<li class='green'><span class='hits'>842</span><code>            return this.__asSql(this.literal(ae.expression), ae.alias);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for BooleanConstants</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        booleanConstantSql:function (constant) {</code></li>
<li class='green'><span class='hits'>12</span><code>            return this.literal(constant)</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for CaseExpression</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        caseExpressionSql:function (ce) {</code></li>
<li class='green'><span class='hits'>2</span><code>            var sql = ['(CASE '];</code></li>
<li class='green'><span class='hits'>2</span><code>            if (ce.expression) {</code></li>
<li class='green'><span class='hits'>1</span><code>                sql.push(this.literal(ce.expression), " ");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2</span><code>            var conds = ce.conditions;</code></li>
<li class='green'><span class='hits'>2</span><code>            if (isArray(conds)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                conds.forEach(function (cond) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    sql.push(format("WHEN %s THEN %s", this.literal(cond[0]), this.literal(cond[1])));</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='red'><span class='nohits'>0</span><code>            } else if (isHash(conds)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                for (var i in conds) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    sql.push(format("WHEN %s THEN %s", this.literal(i), this.literal(conds[i])));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2</span><code>            return format("%s ELSE %s END)", sql.join(""), this.literal(ce.def));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for the SQL CAST expression</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        castSql:function (expr, type) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return string.format("CAST(%s AS %s)", this.literal(expr), this.db.castTypeLiteral(type));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for specifying all columns in a given table</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        columnAllSql:function (ca) {</code></li>
<li class='green'><span class='hits'>19</span><code>            return  string.format("%s.*", this.quoteSchemaTable(ca.table));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for complex expressions</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        complexExpressionSql:function (op, args) {</code></li>
<li class='green'><span class='hits'>6550</span><code>            var newOp;</code></li>
<li class='green'><span class='hits'>6550</span><code>            var isOperators = this._static.IS_OPERATORS, isLiterals = this._static.IS_LITERALS;</code></li>
<li class='green'><span class='hits'>6550</span><code>            if ((newOp = isOperators[op]) != null) {</code></li>
<li class='green'><span class='hits'>259</span><code>                var r = args[1], v = isNull(r) ? isLiterals.NULL : isLiterals[r];</code></li>
<li class='green'><span class='hits'>259</span><code>                if (r == null || this.supportsIsTrue) {</code></li>
<li class='green'><span class='hits'>259</span><code>                    if (isUndefined(v)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        throw new QueryError(string.format("Invalid argument('%s') used for IS operator", r));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>259</span><code>                    l = args[0];</code></li>
<li class='green'><span class='hits'>259</span><code>                    return string.format("(%s %s %s)", isString(l) ? l : this.literal(l), newOp, v);</code></li>
<li class='red'><span class='nohits'>0</span><code>                } else if (op == "IS") {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this.complexExpressionSql("EQ", args);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this.complexExpressionSql("OR",</code></li>
<li class='green'><span class=''> </span><code>                        [BooleanExpression.fromArgs(["NEQ"].concat(args)), new BooleanExpression("IS", args[0],</code></li>
<li class='green'><span class=''> </span><code>                            null)]);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>6291</span><code>            } else if (["IN", "NOTIN"].indexOf(op) != -1) {</code></li>
<li class='green'><span class='hits'>17</span><code>                var cols = args[0], vals = args[1], colArray = isArray(cols), valArray = false, emptyValArray = false;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>17</span><code>                if (isArray(vals)) {</code></li>
<li class='green'><span class='hits'>13</span><code>                    valArray = true;</code></li>
<li class='green'><span class='hits'>13</span><code>                    emptyValArray = vals.length == 0;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>17</span><code>                if (colArray) {</code></li>
<li class='green'><span class='hits'>6</span><code>                    if (emptyValArray) {</code></li>
<li class='green'><span class='hits'>2</span><code>                        if (op == "IN") {</code></li>
<li class='green'><span class='hits'>1</span><code>                            return this.literal(BooleanExpression.fromValuePairs(cols.map(function (x) {</code></li>
<li class='green'><span class='hits'>2</span><code>                                return  [x, x];</code></li>
<li class='green'><span class=''> </span><code>                            }), "AND", true));</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                            return this.literal({1:1});</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>4</span><code>                    } else if (!this.supportsMultipleColumnIn) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        if (valArray) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            var expr = BooleanExpression.fromArgs(["OR"].concat(vals.map(function (vs) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                                return BooleanExpression.fromValuePairs(array.zip(cols, vs))</code></li>
<li class='green'><span class=''> </span><code>                            })));</code></li>
<li class='red'><span class='nohits'>0</span><code>                            return this.literal(op == "IN" ? expr : expr.invert())</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class=''> </span><code>                        //If the columns and values are both arrays, use _arraySql instead of</code></li>
<li class='green'><span class=''> </span><code>                        //literal so that if values is an array of two element arrays, it</code></li>
<li class='green'><span class=''> </span><code>                        //will be treated as a value list instead of a condition specifier.</code></li>
<li class='green'><span class='hits'>4</span><code>                        return format("(%s %s %s)", isString(cols) ? cols : this.literal(cols),</code></li>
<li class='green'><span class=''> </span><code>                            ComplexExpression.IN_OPERATORS[op],</code></li>
<li class='green'><span class=''> </span><code>                            valArray ? this._arraySql(vals) : this.literal(vals));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>                else {</code></li>
<li class='green'><span class='hits'>11</span><code>                    if (emptyValArray) {</code></li>
<li class='green'><span class='hits'>1</span><code>                        if (op == "IN") {</code></li>
<li class='green'><span class='hits'>1</span><code>                            return this.literal(BooleanExpression.fromValuePairs([</code></li>
<li class='green'><span class=''> </span><code>                                [cols, cols]</code></li>
<li class='green'><span class=''> </span><code>                            ], "AND", true));</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                            return this.literal({1:1});</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>10</span><code>                        return format("(%s %s %s)", isString(cols) ? cols : this.literal(cols),</code></li>
<li class='green'><span class=''> </span><code>                            ComplexExpression.IN_OPERATORS[op], this.literal(vals));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>6274</span><code>            } else if ((newOp = this._static.TWO_ARITY_OPERATORS[op]) != null) {</code></li>
<li class='green'><span class='hits'>5296</span><code>                var l = args[0];</code></li>
<li class='green'><span class='hits'>5296</span><code>                return format("(%s %s %s)", isString(l) ? l : this.literal(l), newOp,</code></li>
<li class='green'><span class=''> </span><code>                    this.literal(args[1]));</code></li>
<li class='green'><span class='hits'>978</span><code>            } else if ((newOp = this._static.N_ARITY_OPERATORS[op]) != null) {</code></li>
<li class='green'><span class='hits'>944</span><code>                return string.format("(%s)", args.map(this.literal, this).join(" " + newOp + " "));</code></li>
<li class='green'><span class='hits'>34</span><code>            } else if (op == "NOT") {</code></li>
<li class='green'><span class='hits'>5</span><code>                return string.format("NOT %s", this.literal(args[0]));</code></li>
<li class='green'><span class='hits'>29</span><code>            } else if (op == "NOOP") {</code></li>
<li class='green'><span class='hits'>29</span><code>                return this.literal(args[0]);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new QueryError("Invalid operator " + op);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for constants</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        constantSql:function (constant) {</code></li>
<li class='green'><span class='hits'>6</span><code>            return "" + constant;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment specifying an SQL function call</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        functionSql:function (f) {</code></li>
<li class='green'><span class='hits'>565</span><code>            var args = f.args</code></li>
<li class='green'><span class='hits'>565</span><code>            return string.format("%s%s", f.f, args.length == 0 ? '()' : this.literal(args));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment specifying a JOIN clause without ON or USING.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        joinClauseSql:function (jc) {</code></li>
<li class='green'><span class='hits'>931</span><code>            var table = jc.table</code></li>
<li class='green'><span class='hits'>931</span><code>            var tableAlias = jc.tableAlias</code></li>
<li class='green'><span class='hits'>931</span><code>            if (table === tableAlias) {</code></li>
<li class='green'><span class='hits'>37</span><code>                tableAlias = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>931</span><code>            var tref = this.__tableRef(table);</code></li>
<li class='green'><span class='hits'>931</span><code>            return string.format(" %s %s", this._joinTypeSql(jc.joinType),</code></li>
<li class='green'><span class=''> </span><code>                tableAlias ? this.__asSql(tref, tableAlias) : tref);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment specifying a JOIN clause with ON.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        joinOnClauseSql:function (jc) {</code></li>
<li class='green'><span class='hits'>813</span><code>            return string.format("%s ON %s", this.joinClauseSql(jc), this.literal(this._filterExpr(jc.on)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment specifying a JOIN clause with USING.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        joinUsingClauseSql:function (jc) {</code></li>
<li class='green'><span class='hits'>101</span><code>            return string.format("%s USING (%s)", this.joinClauseSql(jc), this.__columnList(jc.using));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for NegativeBooleanConstants.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        negativeBooleanConstantSql:function (constant) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return string.format("NOT %s", this.booleanConstantSql(constant));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for the ordered expression, used in the ORDER BY</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        orderedExpressionSql:function (oe) {</code></li>
<li class='green'><span class='hits'>73</span><code>            var s = string.format("%s %s", this.literal(oe.expression), oe.descending ? "DESC" : "ASC");</code></li>
<li class='green'><span class='hits'>73</span><code>            if (oe.nulls) {</code></li>
<li class='green'><span class='hits'>7</span><code>                s = string.format("%s NULLS %s", s, oe.nulls == "first" ? "FIRST" : "LAST");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>73</span><code>            return s;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for a literal string with placeholders</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        placeholderLiteralStringSql:function (pls) {</code></li>
<li class='green'><span class='hits'>55</span><code>            var args = pls.args;</code></li>
<li class='green'><span class='hits'>55</span><code>            var s;</code></li>
<li class='green'><span class='hits'>55</span><code>            if (isHash(args)) {</code></li>
<li class='green'><span class='hits'>6</span><code>                for (var i in args) {</code></li>
<li class='green'><span class='hits'>10</span><code>                    args[i] = this.literal(args[i]);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>6</span><code>                s = string.format(pls.str, args);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>49</span><code>                s = pls.str.replace(this._static.QUESTION_MARK, "%s");</code></li>
<li class='green'><span class='hits'>49</span><code>                args = toArray(args).map(this.literal, this);</code></li>
<li class='green'><span class='hits'>49</span><code>                s = string.format(s, args);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>55</span><code>            if (pls.parens) {</code></li>
<li class='green'><span class='hits'>30</span><code>                s = string.format("(%s)", s);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>55</span><code>            return s;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for the qualifed identifier, specifying</code></li>
<li class='green'><span class=''> </span><code>         * a table and a column (or schema and table).</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        qualifiedIdentifierSql:function (qcr) {</code></li>
<li class='green'><span class='hits'>4202</span><code>            return [qcr.table, qcr.column].map(</code></li>
<li class='green'><span class=''> </span><code>                function (x) {</code></li>
<li class='green'><span class='hits'>8404</span><code>                    return [QualifiedIdentifier, Identifier, String].some(function (c) {</code></li>
<li class='green'><span class='hits'>23691</span><code>                        return x instanceof c</code></li>
<li class='green'><span class=''> </span><code>                    }) ? this.literal(x) : this.quoteIdentifier(x)</code></li>
<li class='green'><span class=''> </span><code>                }, this).join('.');</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Adds quoting to identifiers (columns and tables). If identifiers are not</code></li>
<li class='green'><span class=''> </span><code>         * being quoted, returns name as a string.  If identifiers are being quoted</code></li>
<li class='green'><span class=''> </span><code>         * quote the name with {@link patio.dataset._Sql#_quotedIdentifier}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        quoteIdentifier:function (name) {</code></li>
<li class='green'><span class='hits'>33121</span><code>            if (isInstanceOf(name, LiteralString)) {</code></li>
<li class='green'><span class='hits'>260</span><code>                return name;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>32861</span><code>                if (isInstanceOf(name, Identifier)) {</code></li>
<li class='green'><span class='hits'>22289</span><code>                    name = name.value;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>32861</span><code>                name = this.inputIdentifier(name);</code></li>
<li class='green'><span class='hits'>32861</span><code>                if (this.quoteIdentifiers) {</code></li>
<li class='green'><span class='hits'>25787</span><code>                    name = this._quotedIdentifier(name)</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>32861</span><code>            return name;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Modify the identifier returned from the database based on the</code></li>
<li class='green'><span class=''> </span><code>         * identifierOutputMethod.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        inputIdentifier:function (v) {</code></li>
<li class='green'><span class='hits'>33014</span><code>            var i = this.__identifierInputMethod;</code></li>
<li class='green'><span class='hits'>33014</span><code>            v = v.toString(this);</code></li>
<li class='green'><span class='hits'>33014</span><code>            return !isUndefinedOrNull(i) ?</code></li>
<li class='green'><span class=''> </span><code>                isFunction(v[i]) ?</code></li>
<li class='green'><span class=''> </span><code>                    v[i]() :</code></li>
<li class='green'><span class=''> </span><code>                    isFunction(comb[i]) ?</code></li>
<li class='green'><span class=''> </span><code>                        comb[i](v)</code></li>
<li class='green'><span class=''> </span><code>                        : v</code></li>
<li class='green'><span class=''> </span><code>                : v;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Modify the identifier sent to the database based on the</code></li>
<li class='green'><span class=''> </span><code>         * identifierOutputMethod.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        outputIdentifier:function (v) {</code></li>
<li class='green'><span class='hits'>20096</span><code>            (v == '' &amp;&amp; (v = 'untitled'));</code></li>
<li class='green'><span class='hits'>20096</span><code>            var i = this.__identifierOutputMethod;</code></li>
<li class='green'><span class='hits'>20096</span><code>            return !isUndefinedOrNull(i) ?</code></li>
<li class='green'><span class=''> </span><code>                isFunction(v[i]) ?</code></li>
<li class='green'><span class=''> </span><code>                    v[i]() :</code></li>
<li class='green'><span class=''> </span><code>                    isFunction(comb[i]) ?</code></li>
<li class='green'><span class=''> </span><code>                        comb[i](v)</code></li>
<li class='green'><span class=''> </span><code>                        : v</code></li>
<li class='green'><span class=''> </span><code>                : v;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Separates the schema from the table and returns a string with them</code></li>
<li class='green'><span class=''> </span><code>         * quoted (if quoting identifiers)</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        quoteSchemaTable:function (table) {</code></li>
<li class='green'><span class='hits'>2238</span><code>            var parts = this.schemaAndTable(table);</code></li>
<li class='green'><span class='hits'>2238</span><code>            var schema = parts[0];</code></li>
<li class='green'><span class='hits'>2238</span><code>            table = parts[1];</code></li>
<li class='green'><span class='hits'>2238</span><code>            return string.format("%s%s", schema ? this.quoteIdentifier(schema) + "." : "", this.quoteIdentifier(table));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * Split the schema information from the table</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        schemaAndTable:function (tableName) {</code></li>
<li class='green'><span class='hits'>2448</span><code>            var sch = this.db ? this.db.defaultSchema || null : null;</code></li>
<li class='green'><span class='hits'>2448</span><code>            if (isString(tableName)) {</code></li>
<li class='green'><span class='hits'>1004</span><code>                var parts = this._splitString(tableName);</code></li>
<li class='green'><span class='hits'>1004</span><code>                var s = parts[0], table = parts[1];</code></li>
<li class='green'><span class='hits'>1004</span><code>                return [s || sch, table];</code></li>
<li class='green'><span class='hits'>1444</span><code>            } else if (isInstanceOf(tableName, QualifiedIdentifier)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return [tableName.table, tableName.column]</code></li>
<li class='green'><span class='hits'>1441</span><code>            } else if (isInstanceOf(tableName, Identifier)) {</code></li>
<li class='green'><span class='hits'>1441</span><code>                return [null, tableName.value];</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new QueryError("table should be a QualifiedIdentifier, Identifier, or String");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private For For internal use by patio</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for specifying subscripts (SQL array accesses)</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        subscriptSql:function (s) {</code></li>
<li class='green'><span class='hits'>76</span><code>            return string.format("%s[%s]", this.literal(s.f), this.__expressionList(s.sub));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Do a simple join of the arguments (which should be strings) separated by commas</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __argumentList:function (args) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return args.join(this._static.COMMA_SEPARATOR)</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment for specifying an alias.  expression should already be literalized.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __asSql:function (expression, alias) {</code></li>
<li class='green'><span class='hits'>937</span><code>            return string.format("%s AS %s", expression, this.quoteIdentifier(alias));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts an array of column names into a comma seperated string of</code></li>
<li class='green'><span class=''> </span><code>         * column names. If the array is empty, a wildcard (*) is returned.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __columnList:function (columns) {</code></li>
<li class='green'><span class='hits'>5428</span><code>            return (!columns || columns.length == 0) ? this._static.WILDCARD : this.__expressionList(columns);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The alias to use for datasets, takes a number to make sure the name is unique.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _datasetAlias:function (number) {</code></li>
<li class='green'><span class='hits'>96</span><code>            return this._static.DATASET_ALIAS_BASE_NAME + number;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts an array of expressions into a comma separated string of</code></li>
<li class='green'><span class=''> </span><code>         * expressions.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __expressionList:function (columns) {</code></li>
<li class='green'><span class='hits'>4243</span><code>            return columns.map(this.literal, this).join(this._static.COMMA_SEPARATOR);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Format the timestamp based on the default_timestamp_format, with a couple</code></li>
<li class='green'><span class=''> </span><code>        //of modifiers.  First, allow %N to be used for fractions seconds (if the</code></li>
<li class='green'><span class=''> </span><code>        //database supports them), and override %z to always use a numeric offset</code></li>
<li class='green'><span class=''> </span><code>        //of hours and minutes.</code></li>
<li class='green'><span class=''> </span><code>        formatTimestamp:function (v, format) {</code></li>
<li class='green'><span class='hits'>32</span><code>            return this.literal(patio.dateToString(v, format));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * SQL fragment specifying a JOIN type, splits a camelCased join type</code></li>
<li class='green'><span class=''> </span><code>         * and converts to uppercase/</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _joinTypeSql:function (joinType) {</code></li>
<li class='green'><span class='hits'>928</span><code>            return (joinType || "").replace(/([a-z]+)|([A-Z][a-z]+)/g,</code></li>
<li class='green'><span class=''> </span><code>                function (m) {</code></li>
<li class='green'><span class='hits'>1133</span><code>                    return m.toUpperCase() + " ";</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            ).trimRight() + " JOIN";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /*</code></li>
<li class='green'><span class=''> </span><code>         Methods for converting types to a SQL .</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for a type of object not handled by {@link patio.dataset._Sql#literal}.</code></li>
<li class='green'><span class=''> </span><code>         * If object has a method sqlLiteral then it is called with this dataset as the first argument,</code></li>
<li class='green'><span class=''> </span><code>         * otherwise raises an error. Classes implementing sqlLiteral should call a class-specific method</code></li>
<li class='green'><span class=''> </span><code>         * on the dataset provided and should add that method to {@link patio.dataset.Dataset}, allowing for adapters</code></li>
<li class='green'><span class=''> </span><code>         * to provide customized literalizations.</code></li>
<li class='green'><span class=''> </span><code>         * If a database specific type is allowed, this should be overriden in a subclass.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalOther:function (v) {</code></li>
<li class='green'><span class='hits'>4</span><code>            if (isFunction(v.sqlLiteral)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return v.sqlLiteral(this);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                throw string.format("can't express %j as a SQL literal", [v]);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *@return SQL fragment for Buffer, treated as an expression</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _literalBuffer:function (b) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return "X'" + b.toString("hex") + "'";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *@return SQL fragment for Hash, treated as an expression</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _literalObject:function (v) {</code></li>
<li class='green'><span class='hits'>6</span><code>            return this._literalExpression(BooleanExpression.fromValuePairs(v));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for Array.  Treats as an expression if an array of all two pairs, or as a SQL array otherwise.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalArray:function (v) {</code></li>
<li class='green'><span class='hits'>2106</span><code>            return Expression.isConditionSpecifier(v) ? this._literalExpression(BooleanExpression.fromValuePairs(v)) : this._arraySql(v);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for a number.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalNumber:function (num) {</code></li>
<li class='green'><span class='hits'>7025</span><code>            var ret = "" + num;</code></li>
<li class='green'><span class='hits'>7025</span><code>            if (isNaN(num) || num == Infinity) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = string.format("'%s'", ret);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>7025</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for Dataset.  Does a subselect inside parantheses.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalDataset:function (dataset) {</code></li>
<li class='green'><span class='hits'>115</span><code>            return string.format("(%s)", this._subselectSql(dataset));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for Date, using the ISO8601 format.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalDate:function (date) {</code></li>
<li class='green'><span class='hits'>7</span><code>            return (this.requiresSqlStandardDateTimes ? "DATE '" : "'") + patio.dateToString(date) + "'";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *@return SQL fragment for a year.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalYear:function (o) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return patio.dateToString(o, this._static.YEAR_FORMAT);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *@return SQL fragment for a timestamp, using the ISO8601 format.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalTimestamp:function (v) {</code></li>
<li class='green'><span class='hits'>31</span><code>            return this.formatTimestamp(v, this._static.TIMESTAMP_FORMAT)</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *@return SQL fragment for a timestamp, using the ISO8601 format.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalTime:function (v) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.formatTimestamp(v, this._static.TIME_FORMAT);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for a boolean.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _literalBoolean:function (b) {</code></li>
<li class='green'><span class='hits'>79</span><code>            return b ? this._static.BOOL_TRUE : this._static.BOOL_FALSE;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for SQL::Expression, result depends on the specific type of expression.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _literalExpression:function (v) {</code></li>
<li class='green'><span class='hits'>27947</span><code>            return v.toString(this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *@return SQL fragment for Hash, treated as an expression</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _literalHash:function (v) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this._literalExpression(BooleanExpression.fromValuePairs(v));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@return SQL fragment for null*/</code></li>
<li class='green'><span class=''> </span><code>        _literalNull:function () {</code></li>
<li class='green'><span class='hits'>232</span><code>            return this._static.NULL;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for String.  Doubles \ and ' by default.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _literalString:function (v) {</code></li>
<li class='green'><span class='hits'>6113</span><code>            var parts = this._splitString(v);</code></li>
<li class='green'><span class='hits'>6113</span><code>            var table = parts[0], column = parts[1], alias = parts[2];</code></li>
<li class='green'><span class='hits'>6113</span><code>            if (!alias) {</code></li>
<li class='green'><span class='hits'>6113</span><code>                return column &amp;&amp; table ? this._literalExpression(QualifiedIdentifier.fromArgs([table, column])) : "'"</code></li>
<li class='green'><span class=''> </span><code>                    + v.replace(/\\/g, "\\\\").replace(/'/g, "''") + "'"</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.literal(new AliasedExpression(column</code></li>
<li class='green'><span class=''> </span><code>                    &amp;&amp; table ? QualifiedIdentifier.fromArgs([table, column]) : new Identifier(column), alias));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /*SQL STATEMENT CREATION METHODS*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _selectQualifySql:function () {</code></li>
<li class='green'><span class='hits'>4961</span><code>            var o = this.__opts;</code></li>
<li class='green'><span class='hits'>4961</span><code>            var table = this.__opts.alwaysQualify;</code></li>
<li class='green'><span class='hits'>4961</span><code>            if (table &amp;&amp; !o.sql) {</code></li>
<li class='green'><span class='hits'>2</span><code>                array.intersect(Object.keys(o), this._static.QUALIFY_KEYS).forEach(function (k) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    o[k] = this._qualifiedExpression(o[k], table);</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class='hits'>2</span><code>                if (!o.select || isEmpty(o.select)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    o.select = [new ColumnAll(table)];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _deleteQualifySql:function () {</code></li>
<li class='green'><span class='hits'>945</span><code>            return this._selectQualifySql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the columns selected</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _selectColumnsSql:function () {</code></li>
<li class='green'><span class='hits'>4016</span><code>            return " " + this.__columnList(this.__opts.select);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@return the DISTINCT clause.*/</code></li>
<li class='green'><span class=''> </span><code>        _selectDistinctSql:function () {</code></li>
<li class='green'><span class='hits'>4016</span><code>            var distinct = this.__opts.distinct, ret = [];</code></li>
<li class='green'><span class='hits'>4016</span><code>            if (distinct) {</code></li>
<li class='green'><span class='hits'>10</span><code>                ret.push(" DISTINCT");</code></li>
<li class='green'><span class='hits'>10</span><code>                if (distinct.length) {</code></li>
<li class='green'><span class='hits'>4</span><code>                    ret.push(format(" ON (%s)", this.__expressionList(distinct)));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4016</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the EXCEPT, INTERSECT, or UNION clause.</code></li>
<li class='green'><span class=''> </span><code>         * This uses a subselect for the compound datasets used, because using parantheses doesn't</code></li>
<li class='green'><span class=''> </span><code>         * work on all databases.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _selectCompoundsSql:function () {</code></li>
<li class='green'><span class='hits'>4016</span><code>            var opts = this.__opts, compounds = opts.compounds, ret = [];</code></li>
<li class='green'><span class='hits'>4016</span><code>            if (compounds) {</code></li>
<li class='green'><span class='hits'>49</span><code>                compounds.forEach(function (c) {</code></li>
<li class='green'><span class='hits'>49</span><code>                    var type = c[0], dataset = c[1], all = c[2];</code></li>
<li class='green'><span class='hits'>49</span><code>                    ret.push(string.format(" %s%s %s", type.toUpperCase(), all ? " ALL" : "", this._subselectSql(dataset)));</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4016</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the sql to add the list of tables to select FROM</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _selectFromSql:function () {</code></li>
<li class='green'><span class='hits'>4034</span><code>            var from = this.__opts.from;</code></li>
<li class='green'><span class='hits'>4034</span><code>            return from ? string.format(" %s%s", this._static.FROM, this._sourceList(from)) : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the GROUP BY clause</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _selectGroupSql:function () {</code></li>
<li class='green'><span class='hits'>4016</span><code>            var group = this.__opts.group;</code></li>
<li class='green'><span class='hits'>4016</span><code>            return group ? string.format(" GROUP BY %s", this.__expressionList(group)) : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *@return the sql to add the filter criteria in the HAVING clause</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _selectHavingSql:function () {</code></li>
<li class='green'><span class='hits'>4016</span><code>            var having = this.__opts.having;</code></li>
<li class='green'><span class='hits'>4016</span><code>            return having ? string.format(" HAVING %s", this.literal(having)) : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the JOIN clause.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _selectJoinSql:function () {</code></li>
<li class='green'><span class='hits'>4019</span><code>            var join = this.__opts.join, ret = [];</code></li>
<li class='green'><span class='hits'>4019</span><code>            if (join) {</code></li>
<li class='green'><span class='hits'>595</span><code>                join.forEach(function (j) {</code></li>
<li class='green'><span class='hits'>931</span><code>                    ret.push(this.literal(j));</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4019</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the LIMIT and OFFSET clauses.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _selectLimitSql:function () {</code></li>
<li class='green'><span class='hits'>4016</span><code>            var ret = [], limit = this.__opts.limit, offset = this.__opts.offset;</code></li>
<li class='green'><span class='hits'>4016</span><code>            !isUndefined(limit) &amp;&amp; !isNull(limit) &amp;&amp; (ret.push(format(" LIMIT %s", this.literal(limit))));</code></li>
<li class='green'><span class='hits'>4016</span><code>            !isUndefined(offset) &amp;&amp; !isNull(offset) &amp;&amp; (ret.push(format(" OFFSET %s", this.literal(offset))));</code></li>
<li class='green'><span class='hits'>4016</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL for different locking modes.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _selectLockSql:function () {</code></li>
<li class='green'><span class='hits'>4015</span><code>            var lock = this.__opts.lock, ret = [];</code></li>
<li class='green'><span class='hits'>4015</span><code>            if (lock) {</code></li>
<li class='green'><span class='hits'>3</span><code>                if (lock == "update") {</code></li>
<li class='green'><span class='hits'>2</span><code>                    ret.push(this._static.FOR_UPDATE);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                    ret.push(" ", lock);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4015</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the SQL ORDER BY clause fragment.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _selectOrderSql:function () {</code></li>
<li class='green'><span class='hits'>4028</span><code>            var order = this.__opts.order;</code></li>
<li class='green'><span class='hits'>4028</span><code>            return order ? string.format(" ORDER BY %s", this.__expressionList(order)) : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return the SQL WHERE clause fragment.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _selectWhereSql:function () {</code></li>
<li class='green'><span class='hits'>5194</span><code>            var where = this.__opts.where;</code></li>
<li class='green'><span class='hits'>5194</span><code>            return where ? string.format(" WHERE %s", this.literal(where)) : "";</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL WITH clause fragment.</code></li>
<li class='green'><span class=''> </span><code>         * @param sql</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _selectWithSql:function (sql) {</code></li>
<li class='green'><span class='hits'>6381</span><code>            var wit = this.__opts["with"];</code></li>
<li class='green'><span class='hits'>6381</span><code>            if (wit &amp;&amp; wit.length) {</code></li>
<li class='green'><span class=''> </span><code>                //sql.length = 0;</code></li>
<li class='green'><span class='hits'>8</span><code>                var base = sql.join("");</code></li>
<li class='green'><span class='hits'>8</span><code>                sql.length = 0;</code></li>
<li class='green'><span class='hits'>8</span><code>                sql.push([this._selectWithSqlBase(), wit.map(function (w) {</code></li>
<li class='green'><span class='hits'>11</span><code>                    return [</code></li>
<li class='green'><span class=''> </span><code>                        this.quoteIdentifier(w.name),</code></li>
<li class='green'><span class=''> </span><code>                        (w.args ? ("(" + this.__argumentList(w.args) + ")") : ""),</code></li>
<li class='green'><span class=''> </span><code>                        " AS ",</code></li>
<li class='green'><span class=''> </span><code>                        this._literalDataset(w.dataset)</code></li>
<li class='green'><span class=''> </span><code>                    ].join("");</code></li>
<li class='green'><span class=''> </span><code>                }, this).join(this._static.COMMA_SEPARATOR), base].join(" "));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _deleteWithSql:function () {</code></li>
<li class='green'><span class='hits'>927</span><code>            return this._selectWithSql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _insertWithSql:function () {</code></li>
<li class='green'><span class='hits'>1318</span><code>            return this._selectWithSql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _updateWithSql:function () {</code></li>
<li class='green'><span class='hits'>206</span><code>            return this._selectWithSql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _insertReturningSql:function (sql) {</code></li>
<li class='green'><span class='hits'>2451</span><code>            var opts = this.__opts, ret = "";</code></li>
<li class='green'><span class='hits'>2451</span><code>            if (opts.hasOwnProperty("returning")) {</code></li>
<li class='green'><span class='hits'>1311</span><code>                return [this._static.RETURNING, this.__columnList(array.toArray(opts.returning))].join("");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1140</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _deleteReturningSql:function () {</code></li>
<li class='green'><span class='hits'>927</span><code>            return this._insertReturningSql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _updateReturningSql:function () {</code></li>
<li class='green'><span class='hits'>206</span><code>            return this._insertReturningSql.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return The base keyword to use for the SQL WITH clause</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _selectWithSqlBase:function () {</code></li>
<li class='green'><span class='hits'>8</span><code>            return this._static.SQL_WITH;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.dataset._Sql#_selectFromSql</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _deleteFromSql:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>            return this._selectFromSql();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.dataset._Sql#_selectOrderSql</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _deleteOrderSql:function () {</code></li>
<li class='green'><span class='hits'>10</span><code>            return this._selectOrderSql();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.dataset._Sql#_selectWhereSql</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _deleteWhereSql:function () {</code></li>
<li class='green'><span class='hits'>945</span><code>            return this._selectWhereSql();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.dataset._Sql#_selectOrderSql</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _updateOrderSql:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this._selectOrderSql();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.dataset._Sql#_selectWhereSql</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _updateWhereSql:function () {</code></li>
<li class='green'><span class='hits'>233</span><code>            return this._selectWhereSql();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment specifying the tables to delete from.</code></li>
<li class='green'><span class=''> </span><code>         * Includes join table if modifying joins is allowed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _updateTableSql:function (sql) {</code></li>
<li class='green'><span class='hits'>27</span><code>            var ret = [this._sourceList(this.__opts.from)];</code></li>
<li class='green'><span class='hits'>27</span><code>            if (this.supportsModifyingJoins) {</code></li>
<li class='green'><span class='hits'>3</span><code>                ret.push(this._selectJoinSql());</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>27</span><code>            return ret.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @returns The SQL fragment specifying the columns and values to SET.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        _updateSetSql:function () {</code></li>
<li class='green'><span class='hits'>233</span><code>            var values = this.__opts.values, defs = this.__opts.defaults, overrides = this.__opts.overrides;</code></li>
<li class='green'><span class='hits'>233</span><code>            var st = [" SET "];</code></li>
<li class='green'><span class='hits'>233</span><code>            if (isArray(values)) {</code></li>
<li class='green'><span class='hits'>233</span><code>                var v = [], mergedDefsAndOverrides = false, length = values.length;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>233</span><code>                for (var i = 0; i &lt; length; i++) {</code></li>
<li class='green'><span class='hits'>229</span><code>                    var val = values[i];</code></li>
<li class='green'><span class='hits'>229</span><code>                    if (isHash(val)) {</code></li>
<li class='green'><span class='hits'>225</span><code>                        mergedDefsAndOverrides = true;</code></li>
<li class='green'><span class='hits'>225</span><code>                        val = merge({}, defs || {}, val);</code></li>
<li class='green'><span class='hits'>225</span><code>                        val = merge({}, val, overrides || {});</code></li>
<li class='green'><span class='hits'>225</span><code>                        for (var j in val) {</code></li>
<li class='green'><span class='hits'>244</span><code>                            var ident = this.stringToIdentifier(j);</code></li>
<li class='green'><span class='hits'>244</span><code>                            v.push(this.quoteIdentifier(ident) + " = " + this.literal(val[j]));</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>4</span><code>                    } else if (isInstanceOf(val, Expression)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                        v.push(this._literalExpression(val).replace(/^\(|\)$/g, ""));</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                        v.push(val);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>233</span><code>                if (!mergedDefsAndOverrides) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    var val = merge({}, defs || {});</code></li>
<li class='green'><span class='hits'>8</span><code>                    val = merge({}, val, overrides || {});</code></li>
<li class='green'><span class='hits'>8</span><code>                    for (var i in val) {</code></li>
<li class='green'><span class='hits'>8</span><code>                        var ident = this.stringToIdentifier(i);</code></li>
<li class='green'><span class='hits'>8</span><code>                        v.push(this.quoteIdentifier(ident) + " = " + this.literal(val[i]));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>233</span><code>                st.push(v.join(this._static.COMMA_SEPARATOR));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                st.push(values);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>233</span><code>            return st.join("");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts an array of source names into into a comma separated list.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _sourceList:function (source) {</code></li>
<li class='green'><span class='hits'>6682</span><code>            if (!Array.isArray(source)) {</code></li>
<li class='green'><span class='hits'>928</span><code>                source = [source];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>6682</span><code>            if (!source || !source.length) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new QueryError("No source specified for the query");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>6682</span><code>            return " " + source.map(</code></li>
<li class='green'><span class=''> </span><code>                function (s) {</code></li>
<li class='green'><span class='hits'>6897</span><code>                    return this.__tableRef(s);</code></li>
<li class='green'><span class=''> </span><code>                }, this).join(this._static.COMMA_SEPARATOR);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL to use if this dataset uses static SQL.  Since static SQL</code></li>
<li class='green'><span class=''> </span><code>         * can be a PlaceholderLiteralString in addition to a String,</code></li>
<li class='green'><span class=''> </span><code>         * we literalize nonstrings.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _staticSql:function (sql) {</code></li>
<li class='green'><span class='hits'>51</span><code>            return isString(sql) ? sql : this.literal(sql);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @return SQL fragment for a subselect using the given database's SQL.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        _subselectSql:function (ds) {</code></li>
<li class='green'><span class='hits'>170</span><code>            return ds.sql;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @returns SQL fragment specifying a table name.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        __tableRef:function (t) {</code></li>
<li class='green'><span class='hits'>7828</span><code>            return isString(t) ? this._quotedIdentifier(t) : this.literal(t);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Raise an InvalidOperation exception if deletion is not allowed</code></li>
<li class='green'><span class=''> </span><code>        //for this dataset</code></li>
<li class='green'><span class=''> </span><code>        __checkModificationAllowed:function () {</code></li>
<li class='green'><span class='hits'>2702</span><code>            if (this.__opts.group) {</code></li>
<li class='green'><span class='hits'>8</span><code>                throw new QueryError("Grouped datasets cannot be modified");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2694</span><code>            if (!this.supportsModifyingJoins &amp;&amp; this._joinedDataset) {</code></li>
<li class='green'><span class='hits'>8</span><code>                throw new Error("Joined datasets cannot be modified");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __toAliasedTableName:function (alias) {</code></li>
<li class='green'><span class='hits'>2</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>2</span><code>            if (isString(alias)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = alias;</code></li>
<li class='green'><span class='hits'>1</span><code>            } else if (isInstanceOf(alias, Identifier)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = alias.value;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new QueryError("Invalid table alias");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            //Same as selectS, not aliased directly to make subclassing simpler.</code></li>
<li class='green'><span class=''> </span><code>            sql:function () {</code></li>
<li class='green'><span class='hits'>643</span><code>                return this.selectSql;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            selectSql:function () {</code></li>
<li class='green'><span class='hits'>4118</span><code>                if (this.__opts.sql) return this._staticSql(this.__opts.sql);</code></li>
<li class='green'><span class='hits'>4016</span><code>                else return this._clauseSql("select");</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            deleteSql:function () {</code></li>
<li class='green'><span class='hits'>949</span><code>                var opts = this.__opts;</code></li>
<li class='green'><span class='hits'>949</span><code>                if (opts.sql) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this._staticSql(this.sql);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>949</span><code>                    this.__checkModificationAllowed();</code></li>
<li class='green'><span class='hits'>945</span><code>                    return this._clauseSql("delete");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            truncateSql:function () {</code></li>
<li class='green'><span class='hits'>33</span><code>                if (this.__opts.sql) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    return this._staticSql(this.__opts.sql);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>33</span><code>                    this.__checkModificationAllowed();</code></li>
<li class='green'><span class='hits'>29</span><code>                    if (this.__opts.where) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                        throw new QueryError("cant truncate filtered datasets");</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>29</span><code>                    return this._truncateSql(this._sourceList(this.__opts.from));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            exists:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>                return new LiteralString("EXISTS (" + this.selectSql + ")");</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether this dataset is a joined dataset</code></li>
<li class='green'><span class=''> </span><code>            _joinedDataset:function () {</code></li>
<li class='green'><span class='hits'>156</span><code>                var from = this.__opts.from;</code></li>
<li class='green'><span class='hits'>156</span><code>                return (isArray(from) &amp;&amp; from.length &gt; 1) || this.__opts.join;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default FROM clause</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        FROM:"FROM",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL AND separator.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        AND_SEPARATOR:" AND ",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL boolean false operator.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        BOOL_FALSE:"'f'",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL boolean true operator.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        BOOL_TRUE:"'t'",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL comma sperator.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        COMMA_SEPARATOR:', ',</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default COUNT expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        COUNT_OF_ALL_AS_COUNT:sql.count(sql.literal('*')).as("count"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default alias for datasets.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DATASET_ALIAS_BASE_NAME:'t',</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default FOR UPDATE SQL fragment.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        FOR_UPDATE:' FOR UPDATE',</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Hash of IS literals</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        IS_LITERALS:{NULL:'NULL', true:'TRUE', false:'FALSE'},</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Defaults IS OPERATORS. See {@link patio.sql.ComplexExpression.IS_OPERATORS}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        IS_OPERATORS:ComplexExpression.IS_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Defaults N(Multi arity) OPERATORS. See {@link patio.sql.ComplexExpression.N_ARITY_OPERATORS}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        N_ARITY_OPERATORS:ComplexExpression.N_ARITY_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Defaults TWO OPERATORS. See {@link patio.sql.ComplexExpression.TWO_ARITY_OPERATORS}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        TWO_ARITY_OPERATORS:ComplexExpression.TWO_ARITY_OPERATORS,</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Defaults SQL NULL.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        NULL:"NULL",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL clauses that need qualifying. This may be overrode by adapters.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        QUALIFY_KEYS:["select", "where", "having", "order", "group"],</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Regexp used to replace '?' in {@link patio.sql.PlaceHolderLiteralString}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        QUESTION_MARK:/\?/g,</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL DELETE clause methods. This may be overrode by adapters.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DELETE_CLAUSE_METHODS:clauseMethods("delete", "qualify from where"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL INSERT clause. This may be overrode by adapters.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        INSERT_CLAUSE_METHODS:clauseMethods("insert", "into columns values"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL SELECT clause. This may be overrode by adapters.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SELECT_CLAUSE_METHODS:clauseMethods("select", "qualify with distinct columns from join where group having compounds order limit lock"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL UPDATE clause. This may be overrode by adapters.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        UPDATE_CLAUSE_METHODS:clauseMethods("update", "table set where"),</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL '*' literal string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        WILDCARD:new LiteralString('*'),</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL 'RETURNING' literal string</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        RETURNING:" RETURNING ",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default SQL WITH base. This may be overrode by adapters.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SQL_WITH:"WITH",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Default space to use when building SQL queries</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        SPACE:" ",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        clauseMethods:clauseMethods</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="database/defaults.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/defaults.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>93.55</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>244</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>31</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>2</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/defaults.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsTransactionIsolationLevels:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsSavePoints:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __supportsPreparedTransactions:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function (opts) {</code></li>
<li class='green'><span class='hits'>122</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>122</span><code>            var statics = this._static;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__identifierInputMethod = isUndefined(opts.identifierInputMethod) ? isUndefined(statics.identifierInputMethod) ? this.identifierInputMethodDefault : statics.identifierInputMethod : opts.identifierInputMethod;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__identifierOutputMethod = isUndefined(opts.identifierOutputMethod) ? isUndefined(statics.identifierOutputMethod) ? this.identifierOutputMethodDefault : statics.identifierOutputMethod : opts.identifierOutputMethod;</code></li>
<li class='green'><span class='hits'>122</span><code>            this.__quoteIdentifiers = isUndefined(opts.quoteIdentifiers) ? isUndefinedOrNull(statics.quoteIdentifiers) ? this.quoteIdentifiersDefault : statics.quoteIdentifiers : opts.quoteIdentifiers;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The default options for the connection pool.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Object</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            connectionPoolDefaultOptions:function () {</code></li>
<li class='green'><span class='hits'>122</span><code>                return {};</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Default schema to use. This is generally null but may be overridden by an adapter.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type {String|patio.sql.Identifier}</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            defaultSchemaDefault:function () {</code></li>
<li class='green'><span class='hits'>122</span><code>                return null;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The default String or comb method to use transform identifiers with when</code></li>
<li class='green'><span class=''> </span><code>             * sending identifiers to the database.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             * @default toUpperCase</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethodDefault:function () {</code></li>
<li class='green'><span class='hits'>20</span><code>                return "toUpperCase";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The default String or comb method to use transform identifiers with when</code></li>
<li class='green'><span class=''> </span><code>             * they are retrieved from the database.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             * @default toLowerCase</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethodDefault:function () {</code></li>
<li class='green'><span class='hits'>17</span><code>                return "toLowerCase";</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Default boolean of whether or not to quote identifiers before sending</code></li>
<li class='green'><span class=''> </span><code>             * then to the database.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             * @default true</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiersDefault:function () {</code></li>
<li class='green'><span class='hits'>10</span><code>                return true;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Default serial primary key options, used by the table creation</code></li>
<li class='green'><span class=''> </span><code>             * code.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Object</code></li>
<li class='green'><span class=''> </span><code>             * @default {primaryKey : true, type : "integer", autoIncrement : true}</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            serialPrimaryKeyOptions:function () {</code></li>
<li class='green'><span class='hits'>8</span><code>                return {primaryKey:true, type:"integer", autoIncrement:true};</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Whether the database and adapter support prepared transactions</code></li>
<li class='green'><span class=''> </span><code>             * (two-phase commit)</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             * @default false</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            supportsPreparedTransactions:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return this.__supportsPreparedTransactions;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Whether the database and adapter support savepoints.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             * @default false</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            supportsSavepoints:function () {</code></li>
<li class='green'><span class='hits'>607</span><code>                return this.__supportsSavePoints;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Whether the database and adapter support transaction isolation levels.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             * @default false</code></li>
<li class='green'><span class=''> </span><code>             * */</code></li>
<li class='green'><span class=''> </span><code>            supportsTransactionIsolationLevels:function () {</code></li>
<li class='green'><span class='hits'>144</span><code>                return this.__supportsTransactionIsolationLevels;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The String or comb method to use transform identifiers with when</code></li>
<li class='green'><span class=''> </span><code>             * sending identifiers to the database. If this property is undefined then</code></li>
<li class='green'><span class=''> </span><code>             * {@link patio.Database#identifierInputMethodDefault} will be used.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function () {</code></li>
<li class='green'><span class='hits'>14908</span><code>                return this.__identifierInputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The String or comb method to use transform identifiers with when</code></li>
<li class='green'><span class=''> </span><code>             * they are retrieved from database. If this property is undefined then</code></li>
<li class='green'><span class=''> </span><code>             * {@link patio.Database#identifierOutputMethodDefault} will be used.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function () {</code></li>
<li class='green'><span class='hits'>14908</span><code>                return this.__identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Boolean of whether or not to quote identifiers before sending</code></li>
<li class='green'><span class=''> </span><code>             * then to the database. If this property is undefined then</code></li>
<li class='green'><span class=''> </span><code>             * then {@link patio.Database#quoteIdentifiersDefault} will be used.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             * @default true</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function () {</code></li>
<li class='green'><span class='hits'>14874</span><code>                return this.__quoteIdentifiers;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function (identifierInputMethod) {</code></li>
<li class='green'><span class='hits'>50</span><code>                this.__identifierInputMethod = identifierInputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function (identifierOutputMethod) {</code></li>
<li class='green'><span class='hits'>50</span><code>                this.__identifierOutputMethod = identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function (quoteIdentifiers) {</code></li>
<li class='green'><span class='hits'>20</span><code>                this.__quoteIdentifiers = quoteIdentifiers;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsTransactionIsolationLevels:function (supports) {</code></li>
<li class='green'><span class='hits'>2</span><code>                this.__supportsTransactionIsolationLevels = supports;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsPreparedTransactions:function (supports) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                this.__supportsPreparedTransactions = supports;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            supportsSavepoints:function (supports) {</code></li>
<li class='green'><span class='hits'>1</span><code>                this.__supportsSavePoints = supports;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __identifierInputMethod:undefined,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __identifierOutputMethod:undefined,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __quoteIdentifiers:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Database*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The String or comb method to use transform identifiers with when</code></li>
<li class='green'><span class=''> </span><code>             * they are sent to database. See {@link patio#identifierInputMethod}</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function () {</code></li>
<li class='green'><span class='hits'>222</span><code>                return this.__identifierInputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The String or comb method to use transform identifiers with when</code></li>
<li class='green'><span class=''> </span><code>             * they are retrieved from database. See {@link patio#identifierOutputMethod}</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function () {</code></li>
<li class='green'><span class='hits'>225</span><code>                return this.__identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Boolean of whether or not to quote identifiers before sending</code></li>
<li class='green'><span class=''> </span><code>             * then to the database. See {@link patio#quoteIdentifiers}</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function () {</code></li>
<li class='green'><span class='hits'>229</span><code>                return this.__quoteIdentifiers;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            identifierInputMethod:function (identifierInputMethod) {</code></li>
<li class='green'><span class='hits'>79</span><code>                this.__identifierInputMethod = identifierInputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            identifierOutputMethod:function (identifierOutputMethod) {</code></li>
<li class='green'><span class='hits'>79</span><code>                this.__identifierOutputMethod = identifierOutputMethod;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function (quoteIdentifiers) {</code></li>
<li class='green'><span class='hits'>83</span><code>                this.__quoteIdentifiers = quoteIdentifiers;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="dataset/actions.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>dataset/actions.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>96.05</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>1183</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>177</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>7</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="dataset/actions.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("../errors"),</code></li>
<li class='green'><span class=''> </span><code>    asyncArray = comb.async.array,</code></li>
<li class='green'><span class=''> </span><code>    NotImplemented = errors.NotImplemented,</code></li>
<li class='green'><span class=''> </span><code>    QueryError = errors.QueryError,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    Identifier = sql.Identifier,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isNumber = comb.isNumber,</code></li>
<li class='green'><span class=''> </span><code>    QualifiedIdentifier = sql.QualifiedIdentifier,</code></li>
<li class='green'><span class=''> </span><code>    AliasedExpression = sql.AliasedExpression,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    logging = comb.logging,</code></li>
<li class='green'><span class=''> </span><code>    Logger = logging.Logger,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Dataset;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var LOGGER = Logger.getLogger("patio.Dataset");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>28667</span><code>            if (!Dataset) {</code></li>
<li class='green'><span class='hits'>1</span><code>                Dataset = require("../index").Dataset;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>28667</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a Promise that is resolved with an array with all records in the dataset.</code></li>
<li class='green'><span class=''> </span><code>         * If a block is given, the array is iterated over after all items have been loaded.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").all().then(function(res){</code></li>
<li class='green'><span class=''> </span><code>         *      //res === [{id : 1, ...}, {id : 2, ...}, ...];</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * // Iterate over all rows in the table</code></li>
<li class='green'><span class=''> </span><code>         * var myArr = [];</code></li>
<li class='green'><span class=''> </span><code>         * var rowPromise = DB.from("table").all(function(row){ myArr.push(row);});</code></li>
<li class='green'><span class=''> </span><code>         * rowPromise.then(function(rows){</code></li>
<li class='green'><span class=''> </span><code>         *    //=&gt; rows == myArr;</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} block a block to be called with each item. The return value of the block is ignored.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] a block to invoke when the action is done</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved with an array of rows.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        all:function (block, cb) {</code></li>
<li class='green'><span class='hits'>2717</span><code>            var a = [];</code></li>
<li class='green'><span class='hits'>2717</span><code>            var ret = asyncArray(this.forEach().chain(this.postLoad.bind(this)));</code></li>
<li class='green'><span class='hits'>2717</span><code>            if (block) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = ret.forEach(block);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2717</span><code>            return ret.classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise that is resolved with the average value for the given column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT avg(number) FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").avg("number").then(function(avg){</code></li>
<li class='green'><span class=''> </span><code>         *      // avg === 3</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the column to average</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved with the average value of the column.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        avg:function (column, cb) {</code></li>
<li class='green'><span class='hits'>6</span><code>            return this.__aggregateDataset().get(sql.avg(this.stringToIdentifier(column)), cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise that is resolved with the number of records in the dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT COUNT(*) AS count FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").count().then(function(count){</code></li>
<li class='green'><span class=''> </span><code>         *     //count === 3;</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved with the the number of records in the dataset.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        count:function (cb) {</code></li>
<li class='green'><span class='hits'>109</span><code>            return this.__aggregateDataset().get(sql.COUNT(sql.literal("*")).as("count")).chain(function (res) {</code></li>
<li class='green'><span class='hits'>109</span><code>                return parseInt(res, 10);</code></li>
<li class='green'><span class=''> </span><code>            }).classic(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        "delete":function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.remove();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Deletes the records in the dataset.  The returned Promise should be resolved with the</code></li>
<li class='green'><span class=''> </span><code>         * number of records deleted, but that is adapter dependent.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // DELETE * FROM table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").remove().then(function(numDeleted){</code></li>
<li class='green'><span class=''> </span><code>         *     //numDeleted === 3</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise resolved with the</code></li>
<li class='green'><span class=''> </span><code>         * number of records deleted, but that is adapter dependent.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        remove:function (cb) {</code></li>
<li class='green'><span class='hits'>929</span><code>            return this.executeDui(this.deleteSql).classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Iterates over the records in the dataset as they are returned from the</code></li>
<li class='green'><span class=''> </span><code>         * database adapter.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").forEach(function(row){</code></li>
<li class='green'><span class=''> </span><code>         *      //....do something</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [block] the block to invoke for each row.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved when the action has completed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        forEach:function (block, cb) {</code></li>
<li class='green'><span class='hits'>3329</span><code>            var rowCb, ret;</code></li>
<li class='green'><span class='hits'>3329</span><code>            if (this.__opts.graph) {</code></li>
<li class='green'><span class='hits'>12</span><code>                ret = this.graphEach(block);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3317</span><code>                ret = this.fetchRows(this.selectSql);</code></li>
<li class='green'><span class='hits'>3317</span><code>                if ((rowCb = this.rowCb)) {</code></li>
<li class='green'><span class='hits'>1455</span><code>                    ret = ret.map(function (r) {</code></li>
<li class='green'><span class='hits'>1789</span><code>                        return rowCb(r);</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>3317</span><code>                if (block) {</code></li>
<li class='green'><span class='hits'>112</span><code>                    ret = ret.forEach(block);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3329</span><code>            return ret.classic(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise that is resolved with true if no records exist in the dataset,</code></li>
<li class='green'><span class=''> </span><code>         * false otherwise.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT 1 FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").isEmpty().then(function(isEmpty){</code></li>
<li class='green'><span class=''> </span><code>         *   // isEmpty === false</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] a function to callback when action is done</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved with a boolean indicating if the table is empty.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isEmpty:function (cb) {</code></li>
<li class='green'><span class='hits'>15</span><code>            return this.get(1).chain(function (res) {</code></li>
<li class='green'><span class='hits'>15</span><code>                return isUndefinedOrNull(res) || res.length === 0;</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this)).classic(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Executes a select query and fetches records, passing each record to the</code></li>
<li class='green'><span class=''> </span><code>         * supplied cb. This method should not be called by user code, use {@link patio.Dataset#forEach}</code></li>
<li class='green'><span class=''> </span><code>         * instead.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fetchRows:function (sql) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            throw new NotImplemented("fetchRows must be implemented by the adapter");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * If a integer argument is given, it is interpreted as a limit, and then returns all</code></li>
<li class='green'><span class=''> </span><code>         * matching records up to that limit.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If no arguments are passed, it returns the first matching record.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If a function taking no arguments is passed in as the last parameter then it</code></li>
<li class='green'><span class=''> </span><code>         * is assumed to be a filter block. If the a funciton is passed in that takes arguments</code></li>
<li class='green'><span class=''> </span><code>         * then it is assumed to be a callback. You may also pass in both the second to last argument</code></li>
<li class='green'><span class=''> </span><code>         * being a filter function, and the last being a callback.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If any other type of argument(s) is passed, it is given to {@link patio.Dataset#filter} and the</code></li>
<li class='green'><span class=''> </span><code>         * first matching record is returned.  Examples:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * comb.executeInOrder(DB.from("table"), function(ds){</code></li>
<li class='green'><span class=''> </span><code>         *   // SELECT * FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first(); // =&gt; {id : 7}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   // SELECT * FROM table LIMIT 2</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first(2); // =&gt; [{id : 6}, {id : 4}]</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   // SELECT * FROM table WHERE (id = 2) LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first({id : 2}) // =&gt; {id : 2}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT * FROM table WHERE (id = 3) LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first("id = 3"); // =&gt; {id : 3}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   // SELECT * FROM table WHERE (id = 4) LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first("id = ?", 4); // =&gt; {id : 4}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   // SELECT * FROM table WHERE (id &gt; 2) LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first(function(){return this.id.gt(2);}); // =&gt; {id : 5}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   // SELECT * FROM table WHERE ((id &gt; 4) AND (id &lt; 6)) LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first("id &gt; ?", 4, function(){</code></li>
<li class='green'><span class=''> </span><code>         *          return this.id.lt(6);</code></li>
<li class='green'><span class=''> </span><code>         *   }); // =&gt; {id : 5}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *    // SELECT * FROM table WHERE (id &lt; 2) LIMIT 2</code></li>
<li class='green'><span class=''> </span><code>         *   ds.first(2, function(){</code></li>
<li class='green'><span class=''> </span><code>         *          return this.id.lt(2)</code></li>
<li class='green'><span class=''> </span><code>         *   }); // =&gt; [{id:1}]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} args varargs to be used to limit/filter the result set.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved with the either the first matching record.</code></li>
<li class='green'><span class=''> </span><code>         *                        Or an array of items if a limit was provided as the first argument.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        first:function (args) {</code></li>
<li class='green'><span class='hits'>70</span><code>            args = comb(arguments).toArray();</code></li>
<li class='green'><span class='hits'>70</span><code>            var cb,</code></li>
<li class='green'><span class=''> </span><code>                block = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='green'><span class='hits'>70</span><code>            if (block &amp;&amp; block.length &gt; 0) {</code></li>
<li class='green'><span class='hits'>18</span><code>                cb = block;</code></li>
<li class='green'><span class='hits'>18</span><code>                block = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>70</span><code>            var ds = block ? this.filter(block) : this;</code></li>
<li class='green'><span class='hits'>70</span><code>            if (!args.length) {</code></li>
<li class='green'><span class='hits'>47</span><code>                return ds.singleRecord(cb);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>23</span><code>                args = (args.length === 1) ? args[0] : args;</code></li>
<li class='green'><span class='hits'>23</span><code>                if (isNumber(args)) {</code></li>
<li class='green'><span class='hits'>9</span><code>                    return ds.limit(args).all(null, cb);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>14</span><code>                    return ds.filter(args).singleRecord(cb);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return the column value for the first matching record in the dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT id FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").get("id").then(function(val){</code></li>
<li class='green'><span class=''> </span><code>         *   // val === 3</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT sum(id) FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * ds.get(sql.sum("id")).then(function(val){</code></li>
<li class='green'><span class=''> </span><code>         *      // val === 6;</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT sum(id) FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * ds.get(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      return this.sum("id");</code></li>
<li class='green'><span class=''> </span><code>         * }).then(function(val){</code></li>
<li class='green'><span class=''> </span><code>         *      // val === 6;</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} column the column to filter on can be anything that</code></li>
<li class='green'><span class=''> </span><code>         *            {@link patio.Dataset#select} accepts.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that will be resolved will the value requested.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        get:function (column, cb) {</code></li>
<li class='green'><span class='hits'>174</span><code>            return this.select(column).singleValue(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Inserts multiple records into the associated table. This method can be</code></li>
<li class='green'><span class=''> </span><code>         * used to efficiently insert a large number of records into a table in a</code></li>
<li class='green'><span class=''> </span><code>         * single query if the database supports it. Inserts</code></li>
<li class='green'><span class=''> </span><code>         * are automatically wrapped in a transaction.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * This method is called with a columns array and an array of value arrays:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   // INSERT INTO table (x, y) VALUES (1, 2)</code></li>
<li class='green'><span class=''> </span><code>         *   // INSERT INTO table (x, y) VALUES (3, 4)</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("table").import(["x", "y"], [[1, 2], [3, 4]]).</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * This method also accepts a dataset instead of an array of value arrays:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  // INSERT INTO table (x, y) SELECT a, b FROM table2</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").import(["x", "y"], DB.from("table2").select("a", "b"));</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * The method also accepts a commitEvery option that specifies</code></li>
<li class='green'><span class=''> </span><code>         * the number of records to insert per transaction. This is useful especially</code></li>
<li class='green'><span class=''> </span><code>         * when inserting a large number of records, e.g.:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   // this will commit every 50 records</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").import(["x", "y"], [[1, 2], [3, 4], ...], {commitEvery : 50});</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Array} columns The columns to insert values for.</code></li>
<li class='green'><span class=''> </span><code>         *                  This array will be used as the base for each values item in the values array.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Array[Array]} values Array of arrays of values to insert into the columns.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] options</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number} [opts.commitEvery] the number of records to insert per transaction.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved once all records have been inserted.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        "import":function (columns, values, opts, cb) {</code></li>
<li class='green'><span class='hits'>29</span><code>            if (isFunction(opts)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                cb = opts;</code></li>
<li class='green'><span class='hits'>3</span><code>                opts = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>29</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>29</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>29</span><code>            if (isInstanceOf(values, Dataset)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = this.db.transaction(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                    return this.insert(columns, values);</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>27</span><code>                ret = new Promise();</code></li>
<li class='green'><span class='hits'>27</span><code>                if (!values.length) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret.callback();</code></li>
<li class='green'><span class='hits'>27</span><code>                } else if (!columns.length) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    throw new QueryError("Invalid columns in import");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>27</span><code>                var sliceSize = opts.commitEvery || opts.slice;</code></li>
<li class='green'><span class='hits'>27</span><code>                if (sliceSize) {</code></li>
<li class='green'><span class='hits'>10</span><code>                    var offset = 0;</code></li>
<li class='green'><span class='hits'>10</span><code>                    var execute = function () {</code></li>
<li class='green'><span class='hits'>30</span><code>                        if (offset &gt;= values.length) {</code></li>
<li class='green'><span class='hits'>10</span><code>                            ret.callback();</code></li>
<li class='green'><span class='hits'>10</span><code>                            return;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>20</span><code>                        this.db.transaction(opts, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>20</span><code>                            return when(this.multiInsertSql(columns, values.slice(offset, sliceSize + offset)).map(hitch(this, function (st) {</code></li>
<li class='green'><span class='hits'>28</span><code>                                return this.executeDui(st);</code></li>
<li class='green'><span class=''> </span><code>                            })));</code></li>
<li class='green'><span class=''> </span><code>                        })).then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>20</span><code>                            offset += sliceSize;</code></li>
<li class='green'><span class='hits'>20</span><code>                            execute();</code></li>
<li class='green'><span class=''> </span><code>                        }), ret);</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this);</code></li>
<li class='green'><span class='hits'>10</span><code>                    execute();</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>17</span><code>                    var statements = this.multiInsertSql(columns, values);</code></li>
<li class='green'><span class='hits'>17</span><code>                    ret = this.db.transaction(function () {</code></li>
<li class='green'><span class='hits'>17</span><code>                        return when(statements.map(function (st) {</code></li>
<li class='green'><span class='hits'>37</span><code>                            return this.executeDui(st);</code></li>
<li class='green'><span class=''> </span><code>                        }.bind(this)));</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>29</span><code>            return ret.classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This is the recommended function to do the insert of multiple items into the</code></li>
<li class='green'><span class=''> </span><code>         * database. This acts as a proxy to the {@link patio.Dataset#import} method so</code></li>
<li class='green'><span class=''> </span><code>         * one can use an array of hashes rather than an array of columns and an array of values.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Dataset#import} for more information regarding the method of inserting.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;b&gt;NOTE:&lt;/b&gt;All hashes should have the same keys other wise some values could be missed&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO table (x) VALUES (1)</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO table (x) VALUES (2)</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").multiInsert([{x : 1}, {x : 2}]).then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //...do something</code></li>
<li class='green'><span class=''> </span><code>         * })</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //commit every 50 inserts</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").multiInsert([{x : 1}, {x : 2},....], {commitEvery : 50}).then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //...do something</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object[]} hashes an array of objects to insert into the database. The keys of</code></li>
<li class='green'><span class=''> </span><code>         * the first item in the array will be used to look up columns in all subsequent objects. If the</code></li>
<li class='green'><span class=''> </span><code>         * array is empty then the promise is resolved immediatly.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} opts See {@link patio.Dataset#import}.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} See {@link patio.Dataset#import} for return functionality.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        multiInsert:function (hashes, opts, cb) {</code></li>
<li class='green'><span class='hits'>18</span><code>            if (isFunction(opts)) {</code></li>
<li class='green'><span class='hits'>5</span><code>                cb = opts;</code></li>
<li class='green'><span class='hits'>5</span><code>                opts = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>18</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>18</span><code>            hashes = hashes || [];</code></li>
<li class='green'><span class='hits'>18</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!hashes.length) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret.callback();</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>16</span><code>                var columns = Object.keys(hashes[0]);</code></li>
<li class='green'><span class='hits'>16</span><code>                ret = this["import"](columns, hashes.map(function (h) {</code></li>
<li class='green'><span class='hits'>48</span><code>                    return columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>48</span><code>                        return h[c];</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                }), opts, cb);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>18</span><code>            return ret.classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Inserts values into the associated table. The returned value is generally</code></li>
<li class='green'><span class=''> </span><code>         * the value of the primary key for the inserted row, but that is adapter dependent.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO items DEFAULT VALUES</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insert()</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO items DEFAULT VALUES</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insert({});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO items VALUES (1, 2, 3)</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insert([1,2,3]);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO items (a, b) VALUES (1, 2)</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insert(["a", "b"], [1,2]);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO items (a, b) VALUES (1, 2)</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insert({a : 1, b : 2});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO items SELECT * FROM old_items</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insert(DB.from("old_items"));</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // INSERT INTO items (a, b) SELECT * FROM old_items</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").insert(["a", "b"], DB.from("old_items"));</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset|patio.sql.LiteralString|Array|Object|patio.sql.BooleanExpression|...} values  values to</code></li>
<li class='green'><span class=''> </span><code>         *      insert into the database. The INSERT statement generated depends on the type.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Empty object| Or no arugments: then DEFAULT VALUES is used.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Object: the keys will be used as the columns, and values will be the values inserted.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Single {@link patio.Dataset} : an insert with subselect will be performed.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Array with {@link patio.Dataset} : The array will be used for columns and a subselect will performed with the dataset for the values.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;{@link patio.sql.LiteralString} : the literal value will be used.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Single Array : the values in the array will be used as the VALUES clause.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;Two Arrays: the first array is the columns the second array is the values.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;{@link patio.sql.BooleanExpression} : the expression will be used as the values.</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;li&gt;An arbitrary number of arguments : the {@link patio.Dataset#literal} version of the values will be used&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is typically resolved with the ID of the inserted row.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        insert:function () {</code></li>
<li class='green'><span class='hits'>1315</span><code>            var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>1315</span><code>            var cb = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='green'><span class='hits'>1315</span><code>            return this.executeInsert(this.insertSql.apply(this, args)).classic(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#insert</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        save:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.insert.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Inserts multiple values. If a block is given it is invoked for each</code></li>
<li class='green'><span class=''> </span><code>         * item in the given array before inserting it.  See {@link patio.Dataset#multiInsert} as</code></li>
<li class='green'><span class=''> </span><code>         * a possible faster version that inserts multiple records in one SQL statement.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt; Params see @link patio.Dataset#insert&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").insertMultiple([{x : 1}, {x : 2}]);</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO table (x) VALUES (1)</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO table (x) VALUES (2)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").insertMultiple([{x : 1}, {x : 2}], function(row){</code></li>
<li class='green'><span class=''> </span><code>         *      row.y = row.x * 2;</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO table (x, y) VALUES (1, 2)</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO table (x, y) VALUES (2, 4)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param array See {@link patio.Dataset#insert} for possible values.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [block] a function to be called before each item is inserted.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] a function to be called when the aciton is complete</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.PromiseList} a promiseList that should be resolved with the id of each item inserted</code></li>
<li class='green'><span class=''> </span><code>         *          in the order that was in the array.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        insertMultiple:function (array, block, cb) {</code></li>
<li class='green'><span class='hits'>4</span><code>            var promises, ret;</code></li>
<li class='green'><span class='hits'>4</span><code>            if (block) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = when(array.map(function (i) {</code></li>
<li class='green'><span class='hits'>6</span><code>                    return this.insert(block(i));</code></li>
<li class='green'><span class=''> </span><code>                }, this));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = when(array.map(function (i) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    return this.insert(i);</code></li>
<li class='green'><span class=''> </span><code>                }, this));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4</span><code>            return ret.classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#insertMultiple</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        saveMultiple:function () {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.insertMultiple.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise that is resolved with the interval between minimum and maximum values</code></li>
<li class='green'><span class=''> </span><code>         * for the given column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT (max(id) - min(id)) FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("table").interval("id").then(function(interval){</code></li>
<li class='green'><span class=''> </span><code>         *      //(e.g) interval === 6</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column to find the interval of.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] a function to be called when the aciton is complete</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that will be resolved with the interval between the min and max values</code></li>
<li class='green'><span class=''> </span><code>         * of the column.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        interval:function (column, cb) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return this.__aggregateDataset().get(sql.max(column).minus(sql.min(column)), cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Reverses the order and then runs first.  Note that this</code></li>
<li class='green'><span class=''> </span><code>         * will not necessarily give you the last record in the dataset,</code></li>
<li class='green'><span class=''> </span><code>         * unless you have an unambiguous order.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT * FROM table ORDER BY id DESC LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").order("id").last().then(function(lastItem){</code></li>
<li class='green'><span class=''> </span><code>         *      //...(e.g lastItem === {id : 10})</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT * FROM table ORDER BY id ASC LIMIT 2</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("table").order(sql.id.desc()).last(2).then(function(lastItems){</code></li>
<li class='green'><span class=''> </span><code>         *      //...(e.g lastItems === [{id : 1}, {id : 2});</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.error.QueryError} If there is not currently an order for this dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} args See {@link patio.Dataset#first} for argument types.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that will be resolved with a single object or array depending on the</code></li>
<li class='green'><span class=''> </span><code>         * arguments provided.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        last:function (args) {</code></li>
<li class='green'><span class='hits'>32</span><code>            if (!this.__opts.order) {</code></li>
<li class='green'><span class='hits'>4</span><code>                throw new QueryError("No order specified");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>28</span><code>            var ds = this.reverse();</code></li>
<li class='green'><span class='hits'>28</span><code>            return ds.first.apply(ds, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Maps column values for each record in the dataset (if a column name is</code></li>
<li class='green'><span class=''> </span><code>         * given).</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").map("id").then(function(ids){</code></li>
<li class='green'><span class=''> </span><code>         *   // e.g. ids === [1, 2, 3, ...]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").map(function(r){</code></li>
<li class='green'><span class=''> </span><code>         *      return r.id * 2;</code></li>
<li class='green'><span class=''> </span><code>         * }).then(function(ids){</code></li>
<li class='green'><span class=''> </span><code>         *     // e.g. ids === [2, 4, 6, ...]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function|String} column if a string is provided then then it is assumed</code></li>
<li class='green'><span class=''> </span><code>         * to be the name of a column in that table and the value of the column for each row</code></li>
<li class='green'><span class=''> </span><code>         * will be returned. If column is a function then the return value of the function will</code></li>
<li class='green'><span class=''> </span><code>         * be used.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] a function to be called when the aciton is complete</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise resolved with the array of mapped values.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        map:function (column, cb) {</code></li>
<li class='green'><span class='hits'>527</span><code>            var ret = this.forEach();</code></li>
<li class='green'><span class='hits'>527</span><code>            column &amp;&amp; (ret = ret[isFunction(column) ? "map" : "pluck"](column))</code></li>
<li class='green'><span class='hits'>527</span><code>            return ret.classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with  the maximum value for the given column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT max(id) FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").max("id").then(function(max){</code></li>
<li class='green'><span class=''> </span><code>         *   // e.g. max === 10.</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the column to find the maximum value for.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] callback to invoke when action is done</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {*} the maximum value for the column.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        max:function (column, cb) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.__aggregateDataset().get(sql.max(this.stringToIdentifier(column)), cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with  the minimum value for the given column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT min(id) FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").min("id").then(function(min){</code></li>
<li class='green'><span class=''> </span><code>         *   // e.g. max === 0.</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the column to find the minimum value for.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] callback to invoke when action is done</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {*} the minimum value for the column.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        min:function (column, cb) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.__aggregateDataset().get(sql.min(this.stringToIdentifier(column)), cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with  a range from the minimum and maximum values for the</code></li>
<li class='green'><span class=''> </span><code>         * given column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT max(id) AS v1, min(id) AS v2 FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").range("id").then(function(min, max){</code></li>
<li class='green'><span class=''> </span><code>         *      //e.g min === 1 AND max === 10</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} column the column to find the min and max value for.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved with the min and max value, as the first</code></li>
<li class='green'><span class=''> </span><code>         * and second args respectively.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        range:function (column, cb) {</code></li>
<li class='green'><span class='hits'>8</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>8</span><code>            this.__aggregateDataset()</code></li>
<li class='green'><span class=''> </span><code>                .select(sql.min(this.stringToIdentifier(column)).as("v1"), sql.max(this.stringToIdentifier(column)).as("v2"))</code></li>
<li class='green'><span class=''> </span><code>                .first()</code></li>
<li class='green'><span class=''> </span><code>                .then(function (r) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    ret.callback(r.v1, r.v2);</code></li>
<li class='green'><span class=''> </span><code>                }, ret);</code></li>
<li class='green'><span class='hits'>8</span><code>            return ret.classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Selects the column given (either as an argument or as a callback), and</code></li>
<li class='green'><span class=''> </span><code>         * returns an array of all values of that column in the dataset.  If you</code></li>
<li class='green'><span class=''> </span><code>         * give a block argument that returns an array with multiple entries,</code></li>
<li class='green'><span class=''> </span><code>         * the contents of the resulting array are undefined.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT id FROM table</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").selectMap("id").then(function(selectMap){</code></li>
<li class='green'><span class=''> </span><code>         *   // e,g. selectMap === [3, 5, 8, 1, ...]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT abs(id) FROM table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").selectMap(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      return this.abs("id");</code></li>
<li class='green'><span class=''> </span><code>         * }).then(function(selectMap){</code></li>
<li class='green'><span class=''> </span><code>         *   //e.g selectMap === [3, 5, 8, 1, ...]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} column  The column to return the values for.</code></li>
<li class='green'><span class=''> </span><code>         *      See {@link patio.Dataset#select} for valid column values.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] a function to be called when the aciton is complete</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise resolved with the array of mapped values.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        selectMap:function (column, cb) {</code></li>
<li class='green'><span class='hits'>13</span><code>            var ds = this.naked().ungraphed().select(column), col;</code></li>
<li class='green'><span class='hits'>13</span><code>            return ds.map(function (r) {</code></li>
<li class='green'><span class='hits'>29</span><code>                return r[col || (col = Object.keys(r)[0])];</code></li>
<li class='green'><span class=''> </span><code>            }, cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * The same as {@link patio.Dataset#selectMap}, but in addition orders the array by the column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT id FROM table ORDER BY id</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").selectOrderMap("id").then(function(mappedIds){</code></li>
<li class='green'><span class=''> </span><code>         *   //e.g. [1, 2, 3, 4, ...]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT abs(id) FROM table ORDER BY abs(id)</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").selectOrderMap(function(){</code></li>
<li class='green'><span class=''> </span><code>         *          return this.abs("id");</code></li>
<li class='green'><span class=''> </span><code>         *  }).then(function(mappedIds){</code></li>
<li class='green'><span class=''> </span><code>         *      //e.g. [1, 2, 3, 4, ...]</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {*} column  The column to return the values for.</code></li>
<li class='green'><span class=''> </span><code>         *      See {@link patio.Dataset#select} for valid column values.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise resolved with the array of mapped values.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        selectOrderMap:function (column, cb) {</code></li>
<li class='green'><span class='hits'>28</span><code>            var col, ds = this.naked()</code></li>
<li class='green'><span class=''> </span><code>                .ungraphed()</code></li>
<li class='green'><span class=''> </span><code>                .select(column)</code></li>
<li class='green'><span class=''> </span><code>                .order(isFunction(column) ? column : this._unaliasedIdentifier(column));</code></li>
<li class='green'><span class='hits'>28</span><code>            return ds.map(function (r) {</code></li>
<li class='green'><span class='hits'>59</span><code>                return r[col || (col = Object.keys(r)[0])];</code></li>
<li class='green'><span class=''> </span><code>            }, cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Same as {@link patio.Dataset#singleRecord} but accepts arguments</code></li>
<li class='green'><span class=''> </span><code>         * to filter the dataset. See {@link patio.Dataset#filter} for argument types.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;NOTE&lt;/b&gt; If the last argument is a function that accepts arguments it is not assumed to</code></li>
<li class='green'><span class=''> </span><code>         * be a filter function but instead a callback.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise resolved with a single row from the database that matched the filter.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        one:function () {</code></li>
<li class='green'><span class='hits'>1598</span><code>            var args = comb(arguments).toArray(), cb;</code></li>
<li class='green'><span class='hits'>1598</span><code>            var last = args[args.length - 1];</code></li>
<li class='green'><span class='hits'>1598</span><code>            if (isFunction(last) &amp;&amp; last.length &gt; 0) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                cb = args.pop();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1598</span><code>            var ret = this;</code></li>
<li class='green'><span class='hits'>1598</span><code>            if (args.length) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = ret.filter.apply(ret, args)</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1598</span><code>            return ret.singleRecord(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with  the first record in the dataset, or null if the dataset</code></li>
<li class='green'><span class=''> </span><code>         * has no records. Users should probably use {@link patio.Dataset#first} instead of</code></li>
<li class='green'><span class=''> </span><code>         * this method.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //'SELECT * FROM test LIMIT 1'</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").singleRecord().then(function(r) {</code></li>
<li class='green'><span class=''> </span><code>         *     //e.g r === {id : 1, name : "firstName"}</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] a function to be called when the aciton is complete</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise resolved with the first record returned from the query.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        singleRecord:function (cb) {</code></li>
<li class='green'><span class='hits'>1858</span><code>            return this.mergeOptions({limit:1}).all().chain(function (r) {</code></li>
<li class='green'><span class='hits'>1855</span><code>                return r &amp;&amp; r.length ? r[0] : null;</code></li>
<li class='green'><span class=''> </span><code>            }).classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with the first value of the first record in the dataset.</code></li>
<li class='green'><span class=''> </span><code>         * Returns null if dataset is empty.  Users should generally use</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.Dataset#get} instead of this method.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //'SELECT * FROM test LIMIT 1'</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").singleValue().then(function(r) {</code></li>
<li class='green'><span class=''> </span><code>         *     //e.g r === 1</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that will be resolved with the first value of the first row returned</code></li>
<li class='green'><span class=''> </span><code>         * from the dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        singleValue:function (cb) {</code></li>
<li class='green'><span class='hits'>195</span><code>            return this.naked().ungraphed().singleRecord().chain(function (r) {</code></li>
<li class='green'><span class='hits'>192</span><code>                return r ? r[Object.keys(r)[0]] : null;</code></li>
<li class='green'><span class=''> </span><code>            }).classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved the sum for the given column.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT sum(id) FROM table LIMIT 1</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").sum("id").then(function(sum){</code></li>
<li class='green'><span class=''> </span><code>         *   // e.g sum === 55</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier\patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} column</code></li>
<li class='green'><span class=''> </span><code>         * the column to find the sum of.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise resolved with the sum of the column.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        sum:function (column, cb) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.__aggregateDataset().get(sql.sum(this.stringToIdentifier(column)), cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with a string in CSV format containing the dataset records. By</code></li>
<li class='green'><span class=''> </span><code>         * default the CSV representation includes the column titles in the</code></li>
<li class='green'><span class=''> </span><code>         * first line. You can turn that off by passing false as the</code></li>
<li class='green'><span class=''> </span><code>         * includeColumnTitles argument.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *    &lt;b&gt;NOTE:&lt;/b&gt; This does not use a CSV library or handle quoting of values in</code></li>
<li class='green'><span class=''> </span><code>         *          any way.  If any values in any of the rows could include commas or line</code></li>
<li class='green'><span class=''> </span><code>         *          endings, you shouldn't use this.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").toCsv().then(function(csv){</code></li>
<li class='green'><span class=''> </span><code>         *      console.log(csv);</code></li>
<li class='green'><span class=''> </span><code>         *      //outputs</code></li>
<li class='green'><span class=''> </span><code>         *        id,name</code></li>
<li class='green'><span class=''> </span><code>         *        1,Jim</code></li>
<li class='green'><span class=''> </span><code>         *        2,Bob</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *    // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").toCsv(false).then(function(csv){</code></li>
<li class='green'><span class=''> </span><code>         *      console.log(csv);</code></li>
<li class='green'><span class=''> </span><code>         *      //outputs</code></li>
<li class='green'><span class=''> </span><code>         *        1,Jim</code></li>
<li class='green'><span class=''> </span><code>         *        2,Bob</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @param {Boolean} [includeColumnTitles=true] Set to false to prevent the printing of the column</code></li>
<li class='green'><span class=''> </span><code>         *  titles as the first line.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @return {comb.Promise} a promise that will be resolved with the CSV string of the results of the</code></li>
<li class='green'><span class=''> </span><code>         *  query.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toCsv:function (includeColumnTitles, cb) {</code></li>
<li class='green'><span class='hits'>4</span><code>            var n = this.naked();</code></li>
<li class='green'><span class='hits'>4</span><code>            if (isFunction(includeColumnTitles)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                cb = includeColumnTitles;</code></li>
<li class='green'><span class='hits'>1</span><code>                includeColumnTitles = true;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4</span><code>            includeColumnTitles = isBoolean(includeColumnTitles) ? includeColumnTitles : true;</code></li>
<li class='green'><span class='hits'>4</span><code>            return n.columns.chain(function (cols) {</code></li>
<li class='green'><span class='hits'>4</span><code>                var vals = [];</code></li>
<li class='green'><span class='hits'>4</span><code>                if (includeColumnTitles) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    vals.push(cols.join(", "));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>4</span><code>                return n.forEach(function (r) {</code></li>
<li class='green'><span class='hits'>12</span><code>                    vals.push(cols.map(function (c) {</code></li>
<li class='green'><span class='hits'>36</span><code>                        return r[c] || "";</code></li>
<li class='green'><span class=''> </span><code>                    }).join(", "));</code></li>
<li class='green'><span class=''> </span><code>                }).chain(function () {</code></li>
<li class='green'><span class='hits'>4</span><code>                        return vals.join("\r\n") + "\r\n";</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>            }.bind(this)).classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with a hash with keyColumn values as keys and valueColumn values as</code></li>
<li class='green'><span class=''> </span><code>         * values.  Similar to {@link patio.Dataset#toHash}, but only selects the two columns.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT id, name FROM table</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").selectHash("id", "name").then(function(hash){</code></li>
<li class='green'><span class=''> </span><code>         *   // e.g {1 : 'a', 2 : 'b', ...}</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier\patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} keyColumn the column</code></li>
<li class='green'><span class=''> </span><code>         * to use as the key in the hash.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier\patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} valueColumn the column</code></li>
<li class='green'><span class=''> </span><code>         * to use as the value in the hash.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved with an array of hashes, that have the keyColumn</code></li>
<li class='green'><span class=''> </span><code>         * as the key and the valueColumn as the value.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        selectHash:function (keyColumn, valueColumn, cb) {</code></li>
<li class='green'><span class='hits'>8</span><code>            var map = {}, args = comb.argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>8</span><code>            cb = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='green'><span class='hits'>8</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>8</span><code>            var k = this.__hashIdentifierToName(keyColumn),</code></li>
<li class='green'><span class=''> </span><code>                v = this.__hashIdentifierToName(valueColumn);</code></li>
<li class='green'><span class='hits'>8</span><code>            return this.select.apply(this, args).map(function (r) {</code></li>
<li class='green'><span class='hits'>16</span><code>                map[r[k]] = v ? r[v] : r;</code></li>
<li class='green'><span class=''> </span><code>            }).chain(map).classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a promise resolved with a hash with one column used as key and another used as value.</code></li>
<li class='green'><span class=''> </span><code>         * If rows have duplicate values for the key column, the latter row(s)</code></li>
<li class='green'><span class=''> </span><code>         * will overwrite the value of the previous row(s). If the valueColumn</code></li>
<li class='green'><span class=''> </span><code>         * is not given or null, uses the entire hash as the value.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").toHash("id", "name").then(function(hash){</code></li>
<li class='green'><span class=''> </span><code>         *    // {1 : 'Jim', 2 : 'Bob', ...}</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // SELECT * FROM table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").toHash("id").then(function(hash){</code></li>
<li class='green'><span class=''> </span><code>         *   // {1 : {id : 1, name : 'Jim'}, 2 : {id : 2, name : 'Bob'}, ...}</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @param {String|patio.sql.Identifier\patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} keyColumn the column</code></li>
<li class='green'><span class=''> </span><code>         *  to use as the key in the returned hash.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @param {String|patio.sql.Identifier\patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} [keyValue=null] the</code></li>
<li class='green'><span class=''> </span><code>         *  key of the column to use as the value in the hash</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @return {comb.Promise} a promise that will be resolved with the resulting hash.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        toHash:function (keyColumn, valueColumn, cb) {</code></li>
<li class='green'><span class='hits'>8</span><code>            var ret = new Promise(), map = {};</code></li>
<li class='green'><span class='hits'>8</span><code>            if (isFunction(valueColumn)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                cb = valueColumn;</code></li>
<li class='green'><span class='hits'>2</span><code>                valueColumn = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>8</span><code>            var k = this.__hashIdentifierToName(keyColumn), v = this.__hashIdentifierToName(valueColumn);</code></li>
<li class='green'><span class='hits'>8</span><code>            var mapPromise = this.map(function (r) {</code></li>
<li class='green'><span class='hits'>24</span><code>                map[r[k]] = v ? r[v] : r;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>8</span><code>            mapPromise.then(function () {</code></li>
<li class='green'><span class='hits'>8</span><code>                ret.callback(map);</code></li>
<li class='green'><span class=''> </span><code>            }, ret);</code></li>
<li class='green'><span class='hits'>8</span><code>            return ret.classic(cb).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Truncates the dataset.  Returns a promise that is resolved once truncation is complete.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // TRUNCATE table</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").truncate().then(function(){</code></li>
<li class='green'><span class=''> </span><code>         *     //...do something</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise} a promise that is resolved once truncation is complete.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        truncate:function (cb) {</code></li>
<li class='green'><span class='hits'>28</span><code>            return this.executeDdl(this.truncateSql).classic(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Updates values for the dataset.  The returned promise is resolved with a value that is generally the</code></li>
<li class='green'><span class=''> </span><code>         * number of rows updated, but that is adapter dependent.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * // UPDATE table SET x = NULL</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("table").update({x : null}).then(function(numRowsUpdated){</code></li>
<li class='green'><span class=''> </span><code>         *      //e.g. numRowsUpdated === 10</code></li>
<li class='green'><span class=''> </span><code>         *  });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * // UPDATE table SET x = (x + 1), y = 0</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").update({ x : sql.x.plus(1), y : 0}).then(function(numRowsUpdated){</code></li>
<li class='green'><span class=''> </span><code>         *   // e.g. numRowsUpdated === 10</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} values See {@link patio.Dataset#updateSql} for parameter types.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] the callback to invoke when the action is done.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {comb.Promise}  a promise that is generally resolved with the</code></li>
<li class='green'><span class=''> </span><code>         * number of rows updated, but that is adapter dependent.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        update:function (values, cb) {</code></li>
<li class='green'><span class='hits'>204</span><code>            return this.executeDui(this.updateSql(values)).classic(cb);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#set</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        set:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            this.update.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Execute the given select SQL on the database using execute. Use the</code></li>
<li class='green'><span class=''> </span><code>         * readOnly server unless a specific server is set.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        execute:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>3129</span><code>            return this.db.execute(sql, merge({server:this.__opts.server || "readOnly"}, opts || {}));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Execute the given SQL on the database using {@link patio.Database#executeDdl}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        executeDdl:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>28</span><code>            return this.db.executeDdl(sql, this.__defaultServerOpts(opts || {}));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Execute the given SQL on the database using {@link patio.Database#executeDui}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        executeDui:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>1249</span><code>            return this.db.executeDui(sql, this.__defaultServerOpts(opts || {}));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Execute the given SQL on the database using {@link patio.Database#executeInsert}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        executeInsert:function (sql, opts) {</code></li>
<li class='green'><span class='hits'>1315</span><code>            return this.db.executeInsert(sql, this.__defaultServerOpts(opts || {}));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This is run inside {@link patio.Dataset#all}, after all of the records have been loaded</code></li>
<li class='green'><span class=''> </span><code>         * via {@link patio.Dataset#forEach}, but before any block passed to all is called.  It is called with</code></li>
<li class='green'><span class=''> </span><code>         * a single argument, an array of all returned records.  Does nothing by</code></li>
<li class='green'><span class=''> </span><code>         * default.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        postLoad:function (allRecords) {</code></li>
<li class='green'><span class='hits'>2714</span><code>            return allRecords;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Clone of this dataset usable in aggregate operations.  Does</code></li>
<li class='green'><span class=''> </span><code>         * a {@link patio.Dataset#fromSelf} if dataset contains any parameters that would</code></li>
<li class='green'><span class=''> </span><code>         * affect normal aggregation, or just removes an existing</code></li>
<li class='green'><span class=''> </span><code>         * order if not.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __aggregateDataset:function () {</code></li>
<li class='green'><span class='hits'>143</span><code>            return this._optionsOverlap(this._static.COUNT_FROM_SELF_OPTS) ? this.fromSelf() : this.unordered();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Set the server to use to "default" unless it is already set in the passed opts</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __defaultServerOpts:function (opts) {</code></li>
<li class='green'><span class='hits'>2592</span><code>            return merge({server:this.__opts.server || "default"}, opts || {});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Returns the string version of the identifier.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier\patio.sql.QualifiedIdentifier|patio.sql.AliasedExpression} identifier</code></li>
<li class='green'><span class=''> </span><code>         *      identifier to resolve to a string.</code></li>
<li class='green'><span class=''> </span><code>         * @return {String} the string version of the identifier.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __hashIdentifierToName:function (identifier) {</code></li>
<li class='green'><span class='hits'>60</span><code>            return isString(identifier) ? this.__hashIdentifierToName(this.stringToIdentifier(identifier)) :</code></li>
<li class='green'><span class=''> </span><code>                isInstanceOf(identifier, Identifier) ? identifier.value :</code></li>
<li class='green'><span class=''> </span><code>                    isInstanceOf(identifier, QualifiedIdentifier) ? identifier.column :</code></li>
<li class='green'><span class=''> </span><code>                        isInstanceOf(identifier, AliasedExpression) ? identifier.alias : identifier;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type {comb.Promise}</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             *  Returns a promise that is resolved with the columns in the result set in order as an array of strings.</code></li>
<li class='green'><span class=''> </span><code>             * If the columns are currently cached, then the promise is immediately resolved with the cached value. Otherwise,</code></li>
<li class='green'><span class=''> </span><code>             * a SELECT query is performed to retrieve a single row in order to get the columns.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * If you are looking for all columns for a single table and maybe some information about</code></li>
<li class='green'><span class=''> </span><code>             * each column (e.g. database type), see {@link patio.Database#schema}.</code></li>
<li class='green'><span class=''> </span><code>             *</code></li>
<li class='green'><span class=''> </span><code>             * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>             *  DB.from("table").columns.then(function(columns){</code></li>
<li class='green'><span class=''> </span><code>             *        // =&gt; ["id", "name"]</code></li>
<li class='green'><span class=''> </span><code>             *   });</code></li>
<li class='green'><span class=''> </span><code>             * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>             **/</code></li>
<li class='green'><span class=''> </span><code>            columns:function () {</code></li>
<li class='green'><span class='hits'>21</span><code>                if (this.__columns) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    return asyncArray(this.__columns);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>13</span><code>                    var ds = this.unfiltered().unordered().mergeOptions({distinct:null, limit:1});</code></li>
<li class='green'><span class='hits'>13</span><code>                    return asyncArray(ds.forEach().chain(function () {</code></li>
<li class='green'><span class='hits'>13</span><code>                        return (this.__columns = ds.__columns || []);</code></li>
<li class='green'><span class=''> </span><code>                    }.bind(this)));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * List of action methods avaiable on the dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @type String[]</code></li>
<li class='green'><span class=''> </span><code>         * @default ['all', 'one', 'avg', 'count', 'columns', 'remove', 'forEach', 'isEmpty', 'first',</code></li>
<li class='green'><span class=''> </span><code>         *          'get', 'import', 'insert', 'save', 'insertMultiple', 'saveMultiple', 'interval', 'last',</code></li>
<li class='green'><span class=''> </span><code>         *          'map', 'max', 'min', 'multiInsert', 'range', 'selectHash', 'selectMap', 'selectOrderMap', 'set',</code></li>
<li class='green'><span class=''> </span><code>         *          'singleRecord', 'singleValue', 'sum', 'toCsv', 'toHash', 'truncate', 'update']</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ACTION_METHODS:['all', 'one', 'avg', 'count', 'columns', 'remove', 'forEach', 'isEmpty', 'first',</code></li>
<li class='green'><span class=''> </span><code>            'get', 'import', 'insert', 'save', 'insertMultiple', 'saveMultiple', 'interval', 'last',</code></li>
<li class='green'><span class=''> </span><code>            'map', 'max', 'min', 'multiInsert', 'range', 'selectHash', 'selectMap', 'selectOrderMap', 'set',</code></li>
<li class='green'><span class=''> </span><code>            'singleRecord', 'singleValue', 'sum', 'toCsv', 'toHash', 'truncate', 'update'],</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * List of options that can interfere with the aggregation of a {@link patio.Dataset}</code></li>
<li class='green'><span class=''> </span><code>         * @type String[]</code></li>
<li class='green'><span class=''> </span><code>         * @default ["distinct", "group", "sql", "limit", "compounds"]</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        COUNT_FROM_SELF_OPTS:["distinct", "group", "sql", "limit", "compounds"]</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="plugins/association.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/association.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>97.06</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>447</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>68</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>2</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/association.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var associations = require("../associations"),</code></li>
<li class='green'><span class=''> </span><code>    oneToMany = associations.oneToMany,</code></li>
<li class='green'><span class=''> </span><code>    manyToOne = associations.manyToOne,</code></li>
<li class='green'><span class=''> </span><code>    oneToOne = associations.oneToOne,</code></li>
<li class='green'><span class=''> </span><code>    manyToMany = associations.manyToMany,</code></li>
<li class='green'><span class=''> </span><code>    fetch = associations.fetch,</code></li>
<li class='green'><span class=''> </span><code>    comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    asyncArray = comb.async.array,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var RECIPROCAL_ASSOC = {</code></li>
<li class='green'><span class=''> </span><code>    "oneToOne":["manyToOne"],</code></li>
<li class='green'><span class=''> </span><code>    "manyToOne":["oneToMany", "oneToOne"],</code></li>
<li class='green'><span class=''> </span><code>    "oneToMany":["manyToOne"],</code></li>
<li class='green'><span class=''> </span><code>    "manyToMany":["manyToMany"]</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>exports.AssociationPlugin = comb.define(null, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Model.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;Plugin to expose association capability.&lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * The associations exposed include</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;oneToMany&lt;/b&gt; - Foreign key in associated model's table points to this</code></li>
<li class='green'><span class=''> </span><code>         *         model's primary key.   Each current model object can be associated with</code></li>
<li class='green'><span class=''> </span><code>         *         more than one associated model objects.  Each associated model object</code></li>
<li class='green'><span class=''> </span><code>         *         can be associated with only one current model object.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;manyToOne&lt;/b&gt; - Foreign key in current model's table points to</code></li>
<li class='green'><span class=''> </span><code>         *         associated model's primary key.  Each associated model object can</code></li>
<li class='green'><span class=''> </span><code>         *         be associated with more than one current model objects.  Each current</code></li>
<li class='green'><span class=''> </span><code>         *         model object can be associated with only one associated model object.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;oneToOne&lt;/b&gt; - Similar to one_to_many in terms of foreign keys, but</code></li>
<li class='green'><span class=''> </span><code>         *         only one object is associated to the current object through the</code></li>
<li class='green'><span class=''> </span><code>         *         association.  The methods created are similar to many_to_one, except</code></li>
<li class='green'><span class=''> </span><code>         *         that the one_to_one setter method saves the passed object./li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;manyToMany&lt;/b&gt; - A join table is used that has a foreign key that points</code></li>
<li class='green'><span class=''> </span><code>         *         to this model's primary key and a foreign key that points to the</code></li>
<li class='green'><span class=''> </span><code>         *         associated model's primary key.  Each current model object can be</code></li>
<li class='green'><span class=''> </span><code>         *         associated with many associated model objects, and each associated</code></li>
<li class='green'><span class=''> </span><code>         *         model object can be associated with many current model objects./li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>3125</span><code>            if (comb.isUndefinedOrNull(this.__associations)) {</code></li>
<li class='green'><span class='hits'>3022</span><code>                this.__associations = {};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3125</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        reload:function () {</code></li>
<li class='green'><span class='hits'>15</span><code>            this.__associations = {};</code></li>
<li class='green'><span class='hits'>15</span><code>            return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Model.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * List of associations on the {@link patio.Model}</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            associations:function () {</code></li>
<li class='green'><span class='hits'>42</span><code>                return this._static.associations;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Returns true if this {@link patio.Model} has associations.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @ignoreCode</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            hasAssociations:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>                return this._static.hasAssociations;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Model*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __associations:null,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent an event from being emitted when an association is added to the model</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        emitOnAssociationAdd:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @borrows _Association.fetch as fetch</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fetchType:fetch,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * String for to signify an association as one to one.</code></li>
<li class='green'><span class=''> </span><code>         * @const</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ONE_TO_ONE:"oneToOne",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * String for to signify an association as one to many.</code></li>
<li class='green'><span class=''> </span><code>         * @const</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ONE_TO_MANY:"oneToMany",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * String for to signify an association as many to one.</code></li>
<li class='green'><span class=''> </span><code>         * @const</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        MANY_TO_ONE:"manyToOne",</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * String for to signify an association as many to many.</code></li>
<li class='green'><span class=''> </span><code>         * @const</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        MANY_TO_MANY:"manyToMany",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Creates a ONE_TO_MANY association.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.plugins.AssociationPlugin.associate} for options.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  //define the BiologicalFather model</code></li>
<li class='green'><span class=''> </span><code>         *  patio.addModel("biologicalFather", {</code></li>
<li class='green'><span class=''> </span><code>         *      static:{</code></li>
<li class='green'><span class=''> </span><code>         *          init:function () {</code></li>
<li class='green'><span class=''> </span><code>         *              this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code>         *              this.oneToMany("children");</code></li>
<li class='green'><span class=''> </span><code>         *          }</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //define Child  model</code></li>
<li class='green'><span class=''> </span><code>         * patio.addModel("child", {</code></li>
<li class='green'><span class=''> </span><code>         *      static:{</code></li>
<li class='green'><span class=''> </span><code>         *          init:function () {</code></li>
<li class='green'><span class=''> </span><code>         *              this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code>         *              this.manyToOne("biologicalFather");</code></li>
<li class='green'><span class=''> </span><code>         *          }</code></li>
<li class='green'><span class=''> </span><code>         *     }</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        oneToMany:function (name, options, filter) {</code></li>
<li class='green'><span class='hits'>13</span><code>            return this.associate(this.ONE_TO_MANY, name, options, filter);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a MANY_TO_ONE association.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.plugins.AssociationPlugin.oneToMany}.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.plugins.AssociationPlugin.associate}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        manyToOne:function (name, options, filter) {</code></li>
<li class='green'><span class='hits'>16</span><code>            return this.associate(this.MANY_TO_ONE, name, options, filter);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a ONE_TO_ONE relationship between models.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.plugins.AssociationPlugin.associate} for options.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.addModel("state", {</code></li>
<li class='green'><span class=''> </span><code>         *      static:{</code></li>
<li class='green'><span class=''> </span><code>         *          init:function () {</code></li>
<li class='green'><span class=''> </span><code>         *              this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code>         *              this.oneToOne("capital");</code></li>
<li class='green'><span class=''> </span><code>         *          }</code></li>
<li class='green'><span class=''> </span><code>         *     }</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.addModel("capital", {</code></li>
<li class='green'><span class=''> </span><code>         *      static:{</code></li>
<li class='green'><span class=''> </span><code>         *        init:function () {</code></li>
<li class='green'><span class=''> </span><code>         *          this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code>         *          this.manyToOne("state");</code></li>
<li class='green'><span class=''> </span><code>         *        }</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        oneToOne:function (name, options, filter) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return this.associate(this.ONE_TO_ONE, name, options, filter);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a MANY_TO_MANY relationship between models.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.plugins.AssociationPlugin.associate} for options.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  patio.addModel("class", {</code></li>
<li class='green'><span class=''> </span><code>         *      static:{</code></li>
<li class='green'><span class=''> </span><code>         *          init:function(){</code></li>
<li class='green'><span class=''> </span><code>         *              this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code>         *              this.manyToMany("students", {fetchType:this.fetchType.EAGER, order : [sql.firstName.desc(), sql.lastName.desc()]});</code></li>
<li class='green'><span class=''> </span><code>         *          }</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * patio.addModel("student", {</code></li>
<li class='green'><span class=''> </span><code>         *      instance:{</code></li>
<li class='green'><span class=''> </span><code>         *          enroll:function(clas){</code></li>
<li class='green'><span class=''> </span><code>         *              if (comb.isArray(clas)) {</code></li>
<li class='green'><span class=''> </span><code>         *                  return this.addClasses(clas);</code></li>
<li class='green'><span class=''> </span><code>         *              } else {</code></li>
<li class='green'><span class=''> </span><code>         *                  return this.addClass(clas);</code></li>
<li class='green'><span class=''> </span><code>         *              }</code></li>
<li class='green'><span class=''> </span><code>         *          }</code></li>
<li class='green'><span class=''> </span><code>         *      },</code></li>
<li class='green'><span class=''> </span><code>         *      static:{</code></li>
<li class='green'><span class=''> </span><code>         *          init:function(){</code></li>
<li class='green'><span class=''> </span><code>         *              this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code>         *              this.manyToMany("classes", {fetchType:this.fetchType.EAGER, order : sql.name.desc()});</code></li>
<li class='green'><span class=''> </span><code>         *          }</code></li>
<li class='green'><span class=''> </span><code>         *      }</code></li>
<li class='green'><span class=''> </span><code>         });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        manyToMany:function (name, options, filter) {</code></li>
<li class='green'><span class='hits'>18</span><code>            return this.associate(this.MANY_TO_MANY, name, options, filter);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Associates a related model with the current model. The following types are</code></li>
<li class='green'><span class=''> </span><code>         * supported:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;oneToMany&lt;/b&gt; - Foreign key in associated model's table points to this</code></li>
<li class='green'><span class=''> </span><code>         *         model's primary key.   Each current model object can be associated with</code></li>
<li class='green'><span class=''> </span><code>         *         more than one associated model objects.  Each associated model object</code></li>
<li class='green'><span class=''> </span><code>         *         can be associated with only one current model object.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;manyToOne&lt;/b&gt; - Foreign key in current model's table points to</code></li>
<li class='green'><span class=''> </span><code>         *         associated model's primary key.  Each associated model object can</code></li>
<li class='green'><span class=''> </span><code>         *         be associated with more than one current model objects.  Each current</code></li>
<li class='green'><span class=''> </span><code>         *         model object can be associated with only one associated model object.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;oneToOne&lt;/b&gt; - Similar to one_to_many in terms of foreign keys, but</code></li>
<li class='green'><span class=''> </span><code>         *         only one object is associated to the current object through the</code></li>
<li class='green'><span class=''> </span><code>         *         association.  The methods created are similar to many_to_one, except</code></li>
<li class='green'><span class=''> </span><code>         *         that the one_to_one setter method saves the passed object./li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;b&gt;manyToMany&lt;/b&gt; - A join table is used that has a foreign key that points</code></li>
<li class='green'><span class=''> </span><code>         *         to this model's primary key and a foreign key that points to the</code></li>
<li class='green'><span class=''> </span><code>         *         associated model's primary key.  Each current model object can be</code></li>
<li class='green'><span class=''> </span><code>         *         associated with many associated model objects, and each associated</code></li>
<li class='green'><span class=''> </span><code>         *         model object can be associated with many current model objects.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Model.ONE_TO_ONE|patio.Model.ONE_TO_MANY|patio.Model.MANY_TO_ONE|patio.Model.MANY_TO_MANY} type the</code></li>
<li class='green'><span class=''> </span><code>         *          type of association that is to be created.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} name the name of the association, the name specified will be exposed as a property on instances</code></li>
<li class='green'><span class=''> </span><code>         * of the model.</code></li>
<li class='green'><span class=''> </span><code>         @param {Object} [options] additional options.</code></li>
<li class='green'><span class=''> </span><code>         * The following options can be supplied:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;model&lt;/b&gt; - The associated class or its name. If not  given, uses the association's name,</code></li>
<li class='green'><span class=''> </span><code>         *    which is singularized unless the type is MANY_TO_ONE or ONE_TO_ONE&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;query&lt;/b&gt; - The conditions to use to filter the association, can be any argument passed</code></li>
<li class='green'><span class=''> </span><code>         *   to {@link patio.Dataset#filter}.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;dataset&lt;/b&gt; - A function that is called in the scope of the model and called with the model as the</code></li>
<li class='green'><span class=''> </span><code>         *     first argument. The function must return a dataset that can be used as the base for all dataset</code></li>
<li class='green'><span class=''> </span><code>         *     operations.&lt;b&gt;NOTE:&lt;/b&gt;The dataset returned will have all options applied to it.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;distinct&lt;/b&gt; Use the DISTINCT clause when selecting associated objects.</code></li>
<li class='green'><span class=''> </span><code>         *   See {@link patio.Dataset#distinct}.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;limit&lt;/b&gt; : Limit the number of records to the provided value.  Use</code></li>
<li class='green'><span class=''> </span><code>         *     an array with two elements for the value to specify a limit (first element) and an</code></li>
<li class='green'><span class=''> </span><code>         *     offset (second element). See {@link patio.Dataset#limit}.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;order&lt;/b&gt; : the column/s order the association dataset by.  Can be a</code></li>
<li class='green'><span class=''> </span><code>         *     one or more columns.</code></li>
<li class='green'><span class=''> </span><code>         *     See {@link patio.Dataset#order}.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;readOnly&lt;/b&gt; : Do not add a setter method (for MANY_TO_ONE or ONE_TO_ONE associations),</code></li>
<li class='green'><span class=''> </span><code>         *     or add/remove/removeAll methods (for ONE_TO_MANY and MANY_TO_MANY associations).&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;li&gt;&lt;b&gt;select&lt;/b&gt; : the columns to select.  Defaults to the associated class's</code></li>
<li class='green'><span class=''> </span><code>         *     tableName.* in a MANY_TO_MANY association, which means it doesn't include the attributes from the</code></li>
<li class='green'><span class=''> </span><code>         *     join table.  If you want to include the join table attributes, you can</code></li>
<li class='green'><span class=''> </span><code>         *     use this option, but beware that the join table attributes can clash with</code></li>
<li class='green'><span class=''> </span><code>         *     attributes from the model table, so you should alias any attributes that have</code></li>
<li class='green'><span class=''> </span><code>         *     the same name in both the join table and the associated table.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   ManyToOne additional options:</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;key&lt;/b&gt; : foreignKey in current model's table that references</code></li>
<li class='green'><span class=''> </span><code>         *          associated model's primary key.  Defaults to : "{tableName}Id".  Can use an</code></li>
<li class='green'><span class=''> </span><code>         *          array of strings for a composite key association.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;li&gt;&lt;b&gt;primaryKey&lt;/b&gt; : column in the associated table that the &lt;b&gt;key&lt;/b&gt; option references.</code></li>
<li class='green'><span class=''> </span><code>         *              Defaults to the primary key of the associated table. Can use an</code></li>
<li class='green'><span class=''> </span><code>         *              array of strings for a composite key association.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * OneToMany and OneToOne additional options:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;key&lt;/b&gt; : foreign key in associated model's table that references</code></li>
<li class='green'><span class=''> </span><code>         *             current model's primary key, as a string.  Defaults to</code></li>
<li class='green'><span class=''> </span><code>         *             "{thisTableName}Id".  Can use an array of columns for a composite key association.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;primaryKey&lt;/b&gt; : column in the current table that &lt;b&gt;key&lt;/b&gt; option references.</code></li>
<li class='green'><span class=''> </span><code>         *             Defaults to primary key of the current table. Can use an array of strings for a</code></li>
<li class='green'><span class=''> </span><code>         *             composite key association.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ManyToMany additional options:</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;joinTable&lt;/b&gt; : name of table that includes the foreign keys to both</code></li>
<li class='green'><span class=''> </span><code>         *          the current model and the associated model.  Defaults to the name</code></li>
<li class='green'><span class=''> </span><code>         *          of current model and name of associated model, pluralized,</code></li>
<li class='green'><span class=''> </span><code>         *          sorted, and joined with '' and camelized.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;leftKey&lt;/b&gt; : foreign key in join table that points to current model's</code></li>
<li class='green'><span class=''> </span><code>         *          primary key. Defaults to :"{tableName}Id".</code></li>
<li class='green'><span class=''> </span><code>         *          Can use an array of strings for a composite key association.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;leftPrimaryKey&lt;/b&gt; - column in current table that &lt;b&gt;leftKey&lt;/b&gt; points to.</code></li>
<li class='green'><span class=''> </span><code>         *          Defaults to primary key of current table.  Can use an array of strings for a</code></li>
<li class='green'><span class=''> </span><code>         *          composite key association.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;rightKey&lt;/b&gt; : foreign key in join table that points to associated</code></li>
<li class='green'><span class=''> </span><code>         *          model's primary key.  Defaults to Defaults to :"{associatedTableName}Id".</code></li>
<li class='green'><span class=''> </span><code>         *          Can use an array of strings for a composite key association.</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;&lt;b&gt;rightPrimaryKey&lt;/b&gt; : column in associated table that &lt;b&gt;rightKey&lt;/b&gt; points to.</code></li>
<li class='green'><span class=''> </span><code>         *          Defaults to primary key of the associated table.  Can use an</code></li>
<li class='green'><span class=''> </span><code>         *          array of strings for a composite key association.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [filter] optional function to filter the dataset after all other options have been applied.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        associate:function (type, name, options, filter) {</code></li>
<li class='green'><span class='hits'>55</span><code>            if (comb.isFunction(options)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                filter = options;</code></li>
<li class='green'><span class='hits'>1</span><code>                options = {};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>55</span><code>            this.__associations = this.__associations || {manyToMany:{}, oneToMany:{}, manyToOne:{}, oneToOne:{}};</code></li>
<li class='green'><span class='hits'>55</span><code>            var assoc = new associations[type](comb.merge({model:name}, options), this.patio, filter);</code></li>
<li class='green'><span class='hits'>55</span><code>            assoc.inject(this, name);</code></li>
<li class='green'><span class='hits'>55</span><code>            this.__associations[type][name] = assoc;</code></li>
<li class='green'><span class='hits'>55</span><code>            this.emit("associate", type, this);</code></li>
<li class='green'><span class='hits'>55</span><code>            return this;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        sync:function (cb) {</code></li>
<li class='green'><span class='hits'>4016</span><code>            if (!this.synced &amp;&amp; this.hasAssociations) {</code></li>
<li class='green'><span class='hits'>47</span><code>                return this._super().chain(function () {</code></li>
<li class='green'><span class='hits'>47</span><code>                    var associations = this.__associations;</code></li>
<li class='green'><span class='hits'>47</span><code>                    return asyncArray(Object.keys(associations)).map(function (type) {</code></li>
<li class='green'><span class='hits'>188</span><code>                        var types = associations[type];</code></li>
<li class='green'><span class='hits'>188</span><code>                        return asyncArray(Object.keys(types)).map(function (name) {</code></li>
<li class='green'><span class='hits'>55</span><code>                            return types[name].model.sync();</code></li>
<li class='green'><span class=''> </span><code>                        }, 1);</code></li>
<li class='green'><span class=''> </span><code>                    }, 1);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3969</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __isReciprocalAssociation:function (assoc, pAssoc) {</code></li>
<li class='green'><span class='hits'>1300</span><code>            var keys = assoc._getAssociationKey(), leftKey = keys[0], rightKey = keys[1];</code></li>
<li class='green'><span class='hits'>1300</span><code>            var pKeys = pAssoc._getAssociationKey(), pLeftKey = pKeys[0], pRightKey = pKeys[1];</code></li>
<li class='green'><span class='hits'>1300</span><code>            return leftKey.every(function (k, i) {</code></li>
<li class='green'><span class='hits'>1300</span><code>                return pRightKey[i] === k;</code></li>
<li class='green'><span class=''> </span><code>            }) &amp;&amp; rightKey.every(function (k, i) {</code></li>
<li class='green'><span class='hits'>1300</span><code>                return pLeftKey[i] === k;</code></li>
<li class='green'><span class=''> </span><code>            }) &amp;&amp; assoc.parent === pAssoc.model;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _findAssociation:function (assoc) {</code></li>
<li class='green'><span class='hits'>1300</span><code>            var ret = null;</code></li>
<li class='green'><span class='hits'>1300</span><code>            if (!comb.isEmpty(this.__associations)) {</code></li>
<li class='green'><span class='hits'>1300</span><code>                var type = assoc.type, recipTypes = RECIPROCAL_ASSOC[type];</code></li>
<li class='green'><span class='hits'>1300</span><code>                for (var i in recipTypes) {</code></li>
<li class='green'><span class='hits'>1310</span><code>                    var recipType = recipTypes[i];</code></li>
<li class='green'><span class='hits'>1310</span><code>                    var potentialAssociations = this.__associations[recipType];</code></li>
<li class='green'><span class='hits'>1310</span><code>                    var found = false;</code></li>
<li class='green'><span class='hits'>1310</span><code>                    for (var i in potentialAssociations) {</code></li>
<li class='green'><span class='hits'>1300</span><code>                        var pAssoc = potentialAssociations[i];</code></li>
<li class='green'><span class='hits'>1300</span><code>                        if (this.__isReciprocalAssociation(assoc, pAssoc)) {</code></li>
<li class='green'><span class='hits'>1287</span><code>                            ret = [i, pAssoc], found = true;</code></li>
<li class='green'><span class='hits'>1287</span><code>                            break;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1310</span><code>                    if (found) {</code></li>
<li class='green'><span class='hits'>1287</span><code>                        break;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1300</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _clearAssociationsForType:function (type, clazz, model) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            this._findAssociationsForType(type, clazz).forEach(function (assoc) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                assoc._clearAssociations(model);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _reloadAssociationsForType:function (type, clazz, model) {</code></li>
<li class='green'><span class='hits'>121</span><code>            var pl = this._findAssociationsForType(type, clazz).map(function (assoc) {</code></li>
<li class='green'><span class='hits'>243</span><code>                return assoc._forceReloadAssociations(model);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>121</span><code>            return (pl.length ? new PromiseList(pl) : new Promise().callback()).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _findAssociationsForType:function (type, clazz) {</code></li>
<li class='green'><span class='hits'>121</span><code>            var associations = this.__associations[type], ret = [];</code></li>
<li class='green'><span class='hits'>121</span><code>            for (var i in associations) {</code></li>
<li class='green'><span class='hits'>243</span><code>                var assoc = associations[i];</code></li>
<li class='green'><span class='hits'>243</span><code>                if (assoc.model == clazz) {</code></li>
<li class='green'><span class='hits'>243</span><code>                    ret.push(assoc);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>121</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.plugins.AssociationPlugin*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * A list of associated model names.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type String[]</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            associations:function () {</code></li>
<li class='green'><span class='hits'>183</span><code>                var ret = [], assoc = this.__associations;</code></li>
<li class='green'><span class='hits'>183</span><code>                if (assoc != null) {</code></li>
<li class='green'><span class='hits'>136</span><code>                    Object.keys(assoc).forEach(function (k) {</code></li>
<li class='green'><span class='hits'>544</span><code>                        ret = ret.concat(Object.keys(assoc[k]));</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>183</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * Returns true if this model has associations.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            hasAssociations:function () {</code></li>
<li class='green'><span class='hits'>99</span><code>                return this.associations.length &gt; 0;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }});</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="plugins/validation.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/validation.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>97.66</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>535</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>128</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>3</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/validation.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    compact = array.compact,</code></li>
<li class='green'><span class=''> </span><code>    flatten = array.flatten,</code></li>
<li class='green'><span class=''> </span><code>    toArray = array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    net = require("net"),</code></li>
<li class='green'><span class=''> </span><code>    isIP = net.isIP,</code></li>
<li class='green'><span class=''> </span><code>    isIPv4 = net.isIPv4,</code></li>
<li class='green'><span class=''> </span><code>    isIPv6 = net.isIPv6,</code></li>
<li class='green'><span class=''> </span><code>    validator = require("validator"),</code></li>
<li class='green'><span class=''> </span><code>    validatorCheck = validator.check,</code></li>
<li class='green'><span class=''> </span><code>    dateCmp = comb.date.compare,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    combDeepEqual = comb.deepEqual,</code></li>
<li class='green'><span class=''> </span><code>    combIsBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    combIsDefined = comb.isDefined,</code></li>
<li class='green'><span class=''> </span><code>    combIsNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    ModelError = require("../errors.js").ModelError,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    serial = comb.serial,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Validator = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function validator(col) {</code></li>
<li class='green'><span class='hits'>42</span><code>            this.col = col;</code></li>
<li class='green'><span class='hits'>42</span><code>            this.__actions = [];</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __addAction:function __addAction(action, opts) {</code></li>
<li class='green'><span class='hits'>44</span><code>            this.__actions.push({</code></li>
<li class='green'><span class=''> </span><code>                action:action,</code></li>
<li class='green'><span class=''> </span><code>                opts:merge({onlyDefined:true, onlyNotNull:false}, opts)</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>44</span><code>            return this;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isAfter:function (date, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>1</span><code>            var cmpDate = combIsBoolean(opts.date) ? opts.date : true;</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return dateCmp(col, date, cmpDate ? "date" : "datetime") &gt; 0;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be after " + date + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isBefore:function (date, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>1</span><code>            var cmpDate = combIsBoolean(opts.date) ? opts.date : true;</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return dateCmp(col, date, cmpDate ? "date" : "datetime") === -1;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be before " + date + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isDefined:function isDefined(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return combIsDefined(col);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be defined.", onlyDefined:false, onlyNotNull:false}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isNotDefined:function isDefined(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return !combIsDefined(col);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} cannot be defined.", onlyDefined:false, onlyNotNull:false}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isNotNull:function isNotNull(opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>21</span><code>                return combIsDefined(col) &amp;&amp; !combIsNull(col);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} cannot be null.", onlyDefined:false, onlyNotNull:false}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isNull:function isNull(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return !combIsDefined(col) || combIsNull(col);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be null got {val}.", onlyDefined:false, onlyNotNull:false}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isEq:function eq(val, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>8</span><code>                return combDeepEqual(col, val);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must === " + val + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isNeq:function neq(val, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>8</span><code>                return !combDeepEqual(col, val);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must !== " + val + "."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isLike:function like(val, opts) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>14</span><code>                return !!col.match(val);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be like " + val + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isNotLike:function notLike(val, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>6</span><code>                return !(!!col.match(val));</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must not be like " + val + "."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isLt:function lt(num, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return col &lt; num;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be &lt; " + num + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isGt:function gt(num, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return col &gt; num;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be &gt; " + num + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isLte:function lte(num, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return col &lt;= num;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be &lt;= " + num + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isGte:function gte(num, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return col &gt;= num;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be &gt;= " + num + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isIn:function isIn(arr, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            if (!isArray(arr)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new Error("isIn requires an array of values");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return arr.indexOf(col) !== -1;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be in " + arr.join(",") + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isNotIn:function notIn(arr, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            if (!isArray(arr)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new Error("notIn requires an array of values");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return arr.indexOf(col) === -1;</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} cannot be in " + arr.join(",") + " got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isMacAddress:function isMaxAddress(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>4</span><code>                return !!col.match(/^([0-9A-F]{2}[:\-]){5}([0-9A-F]{2})$/);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a valid MAC address got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isIPAddress:function isIpAddress(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>4</span><code>                return !!isIP(col);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a valid IPv4 or IPv6 address got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isIPv4Address:function isIpAddress(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return isIPv4(col);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a valid IPv4 address got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isIPv6Address:function isIpAddress(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return isIPv6(col);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a valid IPv6 address got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isUUID:function isUUID(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return !!col.match(/^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a valid UUID got {val}"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isEmail:function isEmail(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return validatorCheck(col).isEmail();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a valid Email Address got {val}"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isUrl:function isUrl(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return validatorCheck(col).isUrl();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a valid url got {val}"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isAlpha:function isAlpha(opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>11</span><code>                return validatorCheck(col).isAlpha();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a only letters got {val}"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isAlphaNumeric:function isAlphaNumeric(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return validatorCheck(col).isAlphanumeric();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be a alphanumeric got {val}"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        hasLength:function hasLength(min, max, opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>6</span><code>                return validatorCheck(col).len(min, max);</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must have a length between " + min + (max ? " and " + max : "") + "."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isLowercase:function isLowercase(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return validatorCheck(col).isLowercase();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be lowercase got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isUppercase:function isUppercase(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                return validatorCheck(col).isUppercase();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be uppercase got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isEmpty:function isEmpty(opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>3</span><code>                try {</code></li>
<li class='green'><span class='hits'>3</span><code>                    validatorCheck(col).notEmpty();</code></li>
<li class='green'><span class='hits'>2</span><code>                    return false;</code></li>
<li class='green'><span class=''> </span><code>                } catch (e) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    return true;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must be empty got {val}."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isNotEmpty:function isNotEmpty(opts) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.__addAction(function (col) {</code></li>
<li class='green'><span class='hits'>11</span><code>                return validatorCheck(col).notEmpty();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} must not be empty."}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isCreditCard:function isCreditCard(opts) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            return this.__addAction(function (col) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                return validatorCheck(col).isCreditCard();</code></li>
<li class='green'><span class=''> </span><code>            }, merge({message:"{col} is an invalid credit card"}, opts));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        check:function (fun, opts) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.__addAction(fun, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        validate:function validate(value) {</code></li>
<li class='green'><span class='hits'>208</span><code>            var errOpts = {col:this.col, val:value};</code></li>
<li class='green'><span class='hits'>208</span><code>            return compact(this.__actions.map(function (action) {</code></li>
<li class='green'><span class='hits'>238</span><code>                var actionOpts = action.opts;</code></li>
<li class='green'><span class='hits'>238</span><code>                if ((!actionOpts.onlyDefined || combIsDefined(value)) ||</code></li>
<li class='green'><span class=''> </span><code>                    (combIsNull(value) &amp;&amp; actionOpts.onlyNotNull)) {</code></li>
<li class='green'><span class='hits'>179</span><code>                    var ret = null;</code></li>
<li class='green'><span class='hits'>179</span><code>                    try {</code></li>
<li class='green'><span class='hits'>179</span><code>                        if (!action.action(value)) {</code></li>
<li class='green'><span class='hits'>69</span><code>                            ret = format(actionOpts.message, errOpts);</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    } catch (e) {</code></li>
<li class='green'><span class='hits'>26</span><code>                        ret = format(actionOpts.message, errOpts);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>179</span><code>                    return ret;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }, this));</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>function shouldValidate(opts, def) {</code></li>
<li class='green'><span class='hits'>111</span><code>    opts = opts || {};</code></li>
<li class='green'><span class='hits'>111</span><code>    return combIsBoolean(opts.validate) ? opts.validate : def;</code></li>
<li class='green'><span class=''> </span><code>}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>function validateHook(prop, next, opts) {</code></li>
<li class='green'><span class='hits'>111</span><code>    if (shouldValidate(opts, prop) &amp;&amp; !this.isValid()) {</code></li>
<li class='green'><span class='hits'>44</span><code>        next(flatten(toArray(this.errors).map(function (entry) {</code></li>
<li class='green'><span class='hits'>62</span><code>            return entry[1].map(function (err) {</code></li>
<li class='green'><span class='hits'>47</span><code>                return new Error(err);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        })));</code></li>
<li class='green'><span class=''> </span><code>    } else {</code></li>
<li class='green'><span class='hits'>67</span><code>        next();</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * A validation plugin for patio models. This plugin adds a &lt;code&gt;validate&lt;/code&gt; method to each {@link patio.Model}</code></li>
<li class='green'><span class=''> </span><code>         * class that adds it as a plugin. This plugin does not include most typecast checks as &lt;code&gt;patio&lt;/code&gt; already checks</code></li>
<li class='green'><span class=''> </span><code>         * types upon column assignment.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * To do single col validation</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var Model = patio.addModel("validator", {</code></li>
<li class='green'><span class=''> </span><code>         *      plugins:[ValidatorPlugin]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * //this ensures column assignment</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate("col1").isNotNull().isAlphaNumeric().hasLength(1, 10);</code></li>
<li class='green'><span class=''> </span><code>         * //col2 does not have to be assigned but if it is it must match /hello/ig.</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate("col2").like(/hello/ig);</code></li>
<li class='green'><span class=''> </span><code>         * //Ensures that the emailAddress column is a valid email address.</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate("emailAddress").isEmailAddress();</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Or you can do a mass validation through a callback.</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var Model = patio.addModel("validator", {</code></li>
<li class='green'><span class=''> </span><code>         *      plugins:[ValidatorPlugin]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate(function(validate){</code></li>
<li class='green'><span class=''> </span><code>         *      //this ensures column assignment</code></li>
<li class='green'><span class=''> </span><code>         *      validate("col1").isNotNull().isAlphaNumeric().hasLength(1, 10);</code></li>
<li class='green'><span class=''> </span><code>         *      //col2 does not have to be assigned but if it is it must match /hello/ig.</code></li>
<li class='green'><span class=''> </span><code>         *      validate("col2").isLike(/hello/ig);</code></li>
<li class='green'><span class=''> </span><code>         *      //Ensures that the emailAddress column is a valid email address.</code></li>
<li class='green'><span class=''> </span><code>         *      validate("emailAddress").isEmail();</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * To check if a {@link patio.Model} is valid you can run the &lt;code&gt;isValid&lt;/code&gt; method.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * var model1 = new Model({col2 : 'grape', emailAddress : "test"}),</code></li>
<li class='green'><span class=''> </span><code>         *     model2 = new Model({col1 : "grape", col2 : "hello", emailAddress : "test@test.com"});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * model1.isValid() //false</code></li>
<li class='green'><span class=''> </span><code>         * model2.isValid() //true</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * To get the errors associated with an invalid model you can access the errors property</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * model1.errors; //{ col1: [ 'col1 must be defined.' ],</code></li>
<li class='green'><span class=''> </span><code>         *                //  col2: [ 'col2 must be like /hello/gi got grape.' ],</code></li>
<li class='green'><span class=''> </span><code>         *                //  emailAddress: [ 'emailAddress must be a valid Email Address got test' ] }</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Validation is also run pre save and pre update. To prevent this you can specify the &lt;code&gt;validate&lt;/code&gt; option</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * model1.save(null, {validate : false});</code></li>
<li class='green'><span class=''> </span><code>         * model2.save(null, {validate : false});</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Or you can specify the class level properties &lt;code&gt;validateOnSave&lt;/code&gt; and &lt;code&gt;validateOnUpdate&lt;/code&gt;</code></li>
<li class='green'><span class=''> </span><code>         * to false respectively</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * Model.validateOnSave = false;</code></li>
<li class='green'><span class=''> </span><code>         * Model.validateOnUpdate = false;</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Avaiable validation methods are.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isAfter&lt;/code&gt; : check that a date is after a specified date&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isBefore&lt;/code&gt; : check that a date is after before a specified date &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isDefined&lt;/code&gt; : ensure that a column is defined&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isNotDefined&lt;/code&gt; : ensure that a column is not defined&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isNotNull&lt;/code&gt; : ensure that a column is defined and not null&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isNull&lt;/code&gt; : ensure that a column is not defined or null&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isEq&lt;/code&gt; : ensure that a column equals a value &lt;b&gt;this uses deep equal&lt;/b&gt;&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isNeq&lt;/code&gt; : ensure that a column does not equal a value &lt;b&gt;this uses deep equal&lt;/b&gt;&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isLike&lt;/code&gt; : ensure that a column is like a value, can be a regexp or string&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isNotLike&lt;/code&gt; : ensure that a column is not like a value, can be a regexp or string&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isLt&lt;/code&gt; : ensure that a column is less than a value&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isGt&lt;/code&gt; : ensure that a column is greater than a value&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isLte&lt;/code&gt; : ensure that a column is less than or equal to a value&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isGte&lt;/code&gt; : ensure that a column is greater than or equal to a value&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isIn&lt;/code&gt; : ensure that a column is contained in an array of values&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isNotIn&lt;/code&gt; : ensure that a column is not contained in an array of values&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isMacAddress&lt;/code&gt; : ensure that a column is a valid MAC address&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isIPAddress&lt;/code&gt; : ensure that a column is a valid IPv4 or IPv6 address&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isIPv4Address&lt;/code&gt; : ensure that a column is a valid IPv4 address&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isIPv6Address&lt;/code&gt; : ensure that a column is a valid IPv6 address&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isUUID&lt;/code&gt; : ensure that a column is a valid UUID&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isEmail&lt;/code&gt; : ensure that a column is a valid email address&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isUrl&lt;/code&gt; : ensure than a column is a valid URL&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isAlpha&lt;/code&gt; : ensure than a column is all letters&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isAlphaNumeric&lt;/code&gt; : ensure than a column is all letters or numbers&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;hasLength&lt;/code&gt; : ensure than a column is fits within the specified length accepts a min and optional max value&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isLowercase&lt;/code&gt; : ensure than a column is lowercase&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isUppercase&lt;/code&gt; : ensure than a column is uppercase&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isEmpty&lt;/code&gt; : ensure than a column empty (i.e. a blank string)&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isNotEmpty&lt;/code&gt; : ensure than a column not empty (i.e. not a blank string)&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;isCreditCard&lt;/code&gt; : ensure than a is a valid credit card number&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;li&gt;&lt;code&gt;check&lt;/code&gt; : accepts a function to perform validation&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * All of the validation methods are chainable, and accept an options argument.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * The options include</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;code&gt;message&lt;/code&gt; : a message to return if a column fails validation. The message can include &lt;code&gt;{val}&lt;/code&gt; and &lt;code&gt;{col}&lt;/code&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     replacements which will insert the invalid value and the column name.</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;code&gt;[onlyDefined=true]&lt;/code&gt; : set to false to run the method even if the column value is not defined.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;&lt;code&gt;[onlyNotNull=true]&lt;/code&gt; : set to false to run the method even if the column value is null.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constructs</code></li>
<li class='green'><span class=''> </span><code>         * @name ValidatorPlugin</code></li>
<li class='green'><span class=''> </span><code>         * @memberOf patio.plugins</code></li>
<li class='green'><span class=''> </span><code>         * @property {Object} [errors={}] the validation errors for this model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>110</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>110</span><code>            this.errors = {};</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Validates a model, returning an array of error messages for each invalid property.</code></li>
<li class='green'><span class=''> </span><code>         * @return {String[]} an array of error messages for each invalid property.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        validate:function () {</code></li>
<li class='green'><span class='hits'>154</span><code>            this.errors = {};</code></li>
<li class='green'><span class='hits'>154</span><code>            return flatten(this._static.validators.map(function runValidator(validator) {</code></li>
<li class='green'><span class='hits'>208</span><code>                var col = validator.col, val = this.__values[validator.col], ret = validator.validate(val);</code></li>
<li class='green'><span class='hits'>208</span><code>                this.errors[col] = ret;</code></li>
<li class='green'><span class='hits'>208</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            }, this));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns if this model passes validation.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Boolean}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isValid:function () {</code></li>
<li class='green'><span class='hits'>154</span><code>            return this.validate().length === 0;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.plugins.ValidatorPlugin*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent model validation when saving.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        validateOnSave:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set to false to prevent model validation when updating.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        validateOnUpdate:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        init:function () {</code></li>
<li class='green'><span class='hits'>34</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __initValidation:function () {</code></li>
<li class='green'><span class='hits'>41</span><code>            if (!this.__isValidationInited) {</code></li>
<li class='green'><span class='hits'>33</span><code>                this.validators = [];</code></li>
<li class='green'><span class='hits'>33</span><code>                this.pre("save", function preSaveValidate(next, opts) {</code></li>
<li class='green'><span class='hits'>110</span><code>                    validateHook.call(this, this._static.validateOnSave, next, opts);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>33</span><code>                this.pre("update", function preUpdateValidate(next, opts) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    validateHook.call(this, this._static.validateOnSave, next, opts);</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>33</span><code>                this.__isValidationInited = true;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __getValidator:function validator(name) {</code></li>
<li class='green'><span class='hits'>42</span><code>            var ret = new Validator(name);</code></li>
<li class='green'><span class='hits'>42</span><code>            this.validators.push(ret);</code></li>
<li class='green'><span class='hits'>42</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Sets up validation for a model.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * To do single col validation</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var Model = patio.addModel("validator", {</code></li>
<li class='green'><span class=''> </span><code>         *      plugins:[ValidatorPlugin]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * //this ensures column assignment</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate("col1").isDefined().isAlphaNumeric().hasLength(1, 10);</code></li>
<li class='green'><span class=''> </span><code>         * //col2 does not have to be assigned but if it is it must match /hello/ig.</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate("col2").like(/hello/ig);</code></li>
<li class='green'><span class=''> </span><code>         * //Ensures that the emailAddress column is a valid email address.</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate("emailAddress").isEmailAddress();</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Or you can do a mass validation through a callback.</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var Model = patio.addModel("validator", {</code></li>
<li class='green'><span class=''> </span><code>         *      plugins:[ValidatorPlugin]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * Model.validate(function(validate){</code></li>
<li class='green'><span class=''> </span><code>         *      //this ensures column assignment</code></li>
<li class='green'><span class=''> </span><code>         *      validate("col1").isDefined().isAlphaNumeric().hasLength(1, 10);</code></li>
<li class='green'><span class=''> </span><code>         *      //col2 does not have to be assigned but if it is it must match /hello/ig.</code></li>
<li class='green'><span class=''> </span><code>         *      validate("col2").isLike(/hello/ig);</code></li>
<li class='green'><span class=''> </span><code>         *      //Ensures that the emailAddress column is a valid email address.</code></li>
<li class='green'><span class=''> </span><code>         *      validate("emailAddress").isEmail();</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|Function} name the name of the column, or a callback that accepts a function to create validators.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.ModelError} if name is not a function or string.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Model|Validator} returns a validator if name is a string, other wise returns this for chaining.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        validate:function (name) {</code></li>
<li class='green'><span class='hits'>41</span><code>            this.__initValidation();</code></li>
<li class='green'><span class='hits'>41</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>41</span><code>            if (isFunction(name)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                name.apply(this, [this.__getValidator.bind(this)]);</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = this;</code></li>
<li class='green'><span class='hits'>40</span><code>            } else if (isString(name)) {</code></li>
<li class='green'><span class='hits'>40</span><code>                ret = this.__getValidator(name);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                throw new ModelError("name is must be a string or function when validating");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>41</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="dataset/query.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>dataset/query.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>97.71</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>2161</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>437</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>10</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="dataset/query.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    array = comb.array,</code></li>
<li class='green'><span class=''> </span><code>    flatten = array.flatten,</code></li>
<li class='green'><span class=''> </span><code>    compact = array.compact,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isNumber = comb.isNumber,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isObject = comb.isObject,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    LiteralString = sql.LiteralString,</code></li>
<li class='green'><span class=''> </span><code>    Expression = sql.Expression,</code></li>
<li class='green'><span class=''> </span><code>    ComplexExpression = sql.ComplexExpression,</code></li>
<li class='green'><span class=''> </span><code>    BooleanExpression = sql.BooleanExpression,</code></li>
<li class='green'><span class=''> </span><code>    PlaceHolderLiteralString = sql.PlaceHolderLiteralString,</code></li>
<li class='green'><span class=''> </span><code>    Identifier = sql.Identifier,</code></li>
<li class='green'><span class=''> </span><code>    QualifiedIdentifier = sql.QualifiedIdentifier,</code></li>
<li class='green'><span class=''> </span><code>    AliasedExpression = sql.AliasedExpression,</code></li>
<li class='green'><span class=''> </span><code>    StringExpression = sql.StringExpression,</code></li>
<li class='green'><span class=''> </span><code>    NumericExpression = sql.NumericExpression,</code></li>
<li class='green'><span class=''> </span><code>    OrderedExpression = sql.OrderedExpression,</code></li>
<li class='green'><span class=''> </span><code>    JoinClause = sql.JoinClause,</code></li>
<li class='green'><span class=''> </span><code>    JoinOnClause = sql.JoinOnClause,</code></li>
<li class='green'><span class=''> </span><code>    JoinUsingClause = sql.JoinUsingClause,</code></li>
<li class='green'><span class=''> </span><code>    ColumnAll = sql.ColumnAll,</code></li>
<li class='green'><span class=''> </span><code>    QueryError = require("../errors").QueryError;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Dataset;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>function conditionedJoin(type) {</code></li>
<li class='green'><span class='hits'>700</span><code>    var args = argsToArray(arguments, 1);</code></li>
<li class='green'><span class='hits'>700</span><code>    return this.joinTable.apply(this, [type].concat(args));</code></li>
<li class='green'><span class=''> </span><code>}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>function unConditionJoin(type, table) {</code></li>
<li class='green'><span class='hits'>6</span><code>    var args = argsToArray(arguments, 1);</code></li>
<li class='green'><span class='hits'>6</span><code>    return this.joinTable.apply(this, [type, table]);</code></li>
<li class='green'><span class=''> </span><code>}</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>28667</span><code>            !Dataset &amp;&amp; (Dataset = require("../index").Dataset);</code></li>
<li class='green'><span class='hits'>28667</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>28667</span><code>            this._static.CONDITIONED_JOIN_TYPES.forEach(function (type) {</code></li>
<li class='green'><span class='hits'>200669</span><code>                if (!this[type + "Join"]) {</code></li>
<li class='green'><span class='hits'>200669</span><code>                    this[type + "Join"] = conditionedJoin.bind(this, type);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>28667</span><code>            this._static.UNCONDITIONED_JOIN_TYPES.forEach(function (type) {</code></li>
<li class='green'><span class='hits'>143335</span><code>                if (!this[type + "Join"]) {</code></li>
<li class='green'><span class='hits'>143335</span><code>                    this[type + "Join"] = unConditionJoin.bind(this, type);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds a RETURNING clause, which is not supported by all databases. If returning is</code></li>
<li class='green'><span class=''> </span><code>         * used instead of returning the autogenerated primary key or update/delete returning the number of rows modified.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.from("items").returning() //"RETURNING *"</code></li>
<li class='green'><span class=''> </span><code>         * ds.from("items").returning(null) //"RETURNING NULL"</code></li>
<li class='green'><span class=''> </span><code>         * ds.from("items").returning("id", "name") //"RETURNING id, name"</code></li>
<li class='green'><span class=''> </span><code>         * ds.from("items").returning(["id", "name"]) //"RETURNING id, name"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param values columns to return. If values is an array then the array is assumed to contain the columns to</code></li>
<li class='green'><span class=''> </span><code>         * return. Otherwise the arguments will be used.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a new dataset with the retuning option added.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        returning:function (values) {</code></li>
<li class='green'><span class='hits'>1312</span><code>            var args;</code></li>
<li class='green'><span class='hits'>1312</span><code>            if (Array.isArray(values)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                args = values;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1312</span><code>                args = argsToArray(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1312</span><code>            return this.mergeOptions({returning:args.map(function (v) {</code></li>
<li class='green'><span class='hits'>1146</span><code>                return isString(v) ? sql.stringToIdentifier(v) : v;</code></li>
<li class='green'><span class=''> </span><code>            })});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds a futher filter to an existing filter using AND. This method is identical to {@link patio.Dataset#filter}</code></li>
<li class='green'><span class=''> </span><code>         * except it expects an existing filter.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;b&gt;For parameter types see {@link patio.Dataset#filter}.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").filter("a").and("b").sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;SELECT * FROM table WHERE a AND b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError} If no WHERE?HAVING clause exists.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the condtion added to the WHERE/HAVING clause added.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        and:function () {</code></li>
<li class='green'><span class='hits'>7</span><code>            var tOpts = this.__opts, clauseObj = tOpts[tOpts.having ? "having" : "where"];</code></li>
<li class='green'><span class='hits'>7</span><code>            if (clauseObj) {</code></li>
<li class='green'><span class='hits'>6</span><code>                return this.filter.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("No existing filter found");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        as:function (alias) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return new AliasedExpression(this, alias);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds an alternate filter to an existing WHERE/HAVING using OR.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;b&gt;For parameter types see {@link patio.Dataset#filter}.&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter("a").or("b")</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE a OR b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError} If no WHERE?HAVING clause exists.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the condtion added to the WHERE/HAVING clause added.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        or:function () {</code></li>
<li class='green'><span class='hits'>9</span><code>            var tOpts = this.__opts;</code></li>
<li class='green'><span class='hits'>9</span><code>            var clause = (tOpts.having ? "having" : "where"), clauseObj = tOpts[clause];</code></li>
<li class='green'><span class='hits'>9</span><code>            if (clauseObj) {</code></li>
<li class='green'><span class='hits'>8</span><code>                var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>8</span><code>                args = args.length == 1 ? args[0] : args;</code></li>
<li class='green'><span class='hits'>8</span><code>                var opts = {};</code></li>
<li class='green'><span class='hits'>8</span><code>                opts[clause] = new BooleanExpression("OR", clauseObj, this._filterExpr(args))</code></li>
<li class='green'><span class='hits'>8</span><code>                return this.mergeOptions(opts);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("No existing filter found");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the SQL DISTINCT clause.</code></li>
<li class='green'><span class=''> </span><code>         * The DISTINCT clause is used to remove duplicate rows from the</code></li>
<li class='green'><span class=''> </span><code>         * output.  If arguments are provided, uses a DISTINCT ON clause,</code></li>
<li class='green'><span class=''> </span><code>         * in which case it will only be distinct on those columns, instead</code></li>
<li class='green'><span class=''> </span><code>         * of all returned columns.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").distinct().sqll</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT DISTINCT * FROM items</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").order("id").distinct("id").sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT DISTINCT ON (id) * FROM items ORDER BY id</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError}  If arguments are given and DISTINCT ON is not supported.</code></li>
<li class='green'><span class=''> </span><code>         * @param {...String|...patio.sql.Identifier} args variable number of arguments used to create</code></li>
<li class='green'><span class=''> </span><code>         *                                                 the DISTINCT ON clause.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the DISTINCT/DISTINCT ON clause added.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        distinct:function (args) {</code></li>
<li class='green'><span class='hits'>13</span><code>            args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>13</span><code>            if (args.length &amp;&amp; !this.supportsDistinctOn) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("DISTICT ON is not supported");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>12</span><code>            args = args.map(function (a) {</code></li>
<li class='green'><span class='hits'>6</span><code>                return isString(a) ? new Identifier(a) : a;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>12</span><code>            return this.mergeOptions({distinct:args});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds an EXCEPT clause using a second dataset object.</code></li>
<li class='green'><span class=''> </span><code>         * An EXCEPT compound dataset returns all rows in the current dataset</code></li>
<li class='green'><span class=''> </span><code>         * that are not in the given dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").except(DB.from("other_items")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items EXCEPT SELECT * FROM other_items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").except(DB.from("other_items"),</code></li>
<li class='green'><span class=''> </span><code>         *                        {all : true, fromSelf : false}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items EXCEPT ALL SELECT * FROM other_items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").except(DB.from("other_items"),</code></li>
<li class='green'><span class=''> </span><code>         *                        {alias : "i"}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;SELECT * FROM (SELECT * FROM items EXCEPT SELECT * FROM other_items) AS i</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError} if the operation is not supported.</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} dataset the dataset to use to create the EXCEPT clause.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] options to use when creating the EXCEPT clause</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [opt.alias] Use the given value as the {@link patio.Dataset#fromSelf} alias.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.all] Set to true to use EXCEPT ALL instead of EXCEPT, so duplicate rows can occur</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.fromSelf] Set to false to not wrap the returned dataset in a {@link patio.Dataset#fromSelf}, use with care.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the EXCEPT clause added.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        except:function (dataset, opts) {</code></li>
<li class='green'><span class='hits'>18</span><code>            opts = isUndefined(opts) ? {} : opts;</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!isHash(opts)) {</code></li>
<li class='green'><span class='hits'>5</span><code>                opts = {all:true};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!this.supportsIntersectExcept) {</code></li>
<li class='green'><span class='hits'>2</span><code>                throw new QueryError("EXCEPT not supoorted");</code></li>
<li class='green'><span class='hits'>16</span><code>            } else if (opts.hasOwnProperty("all") &amp;&amp; !this.supportsIntersectExceptAll) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("EXCEPT ALL not supported");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>15</span><code>            return this.compoundClone("except", dataset, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Performs the inverse of {@link patio.Dataset#filter}.  Note that if you have multiple filter</code></li>
<li class='green'><span class=''> </span><code>         * conditions, this is not the same as a negation of all conditions. For argument types see</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.Dataset#filter}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").exclude({category : "software").sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE (category != 'software')</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").exclude({category : 'software', id : 3}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE ((category != 'software') OR (id != 3))</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the excluded conditions applied to the HAVING/WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        exclude:function () {</code></li>
<li class='green'><span class='hits'>77</span><code>            var cond = argsToArray(arguments), tOpts = this.__opts;</code></li>
<li class='green'><span class='hits'>77</span><code>            var clause = (tOpts["having"] ? "having" : "where"), clauseObj = tOpts[clause];</code></li>
<li class='green'><span class='hits'>77</span><code>            cond = cond.length &gt; 1 ? cond : cond[0];</code></li>
<li class='green'><span class='hits'>77</span><code>            cond = this._filterExpr.call(this, cond);</code></li>
<li class='green'><span class='hits'>77</span><code>            cond = BooleanExpression.invert(cond);</code></li>
<li class='green'><span class='hits'>77</span><code>            if (clauseObj) {</code></li>
<li class='green'><span class='hits'>66</span><code>                cond = new BooleanExpression("AND", clauseObj, cond)</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>77</span><code>            var opts = {};</code></li>
<li class='green'><span class='hits'>77</span><code>            opts[clause] = cond;</code></li>
<li class='green'><span class='hits'>77</span><code>            return this.mergeOptions(opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the given conditions applied to it.</code></li>
<li class='green'><span class=''> </span><code>         * If the query already has a HAVING clause, then the conditions are applied to the</code></li>
<li class='green'><span class=''> </span><code>         * HAVING clause otherwise they are applied to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter({id : 3}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE (id = 3)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter('price &lt; ?', 100)</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE price &lt; 100</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter({id, [1,2,3]}).filter({id : {between : [0, 10]}}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT</code></li>
<li class='green'><span class=''> </span><code>         *               *</code></li>
<li class='green'><span class=''> </span><code>         *           FROM</code></li>
<li class='green'><span class=''> </span><code>         *               items</code></li>
<li class='green'><span class=''> </span><code>         *           WHERE</code></li>
<li class='green'><span class=''> </span><code>         *               ((id IN (1, 2, 3)) AND ((id &gt;= 0) AND (id &lt;= 10)))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter('price &lt; 100');</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE price &lt; 100</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter("active").sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE active</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      return this.price.lt(100);</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE (price &lt; 100)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //Multiple filter calls can be chained for scoping:</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter(:category =&gt; 'software').filter{price &lt; 100}</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE ((category = 'software') AND (price &lt; 100))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object|Array|String|patio.sql.Identifier|patio.sql.BooleanExpression} args filters to apply to the</code></li>
<li class='green'><span class=''> </span><code>         *  WHERE/HAVING clause. Description of each:</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;Hash - list of equality/inclusion expressions&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;Array - depends:</code></li>
<li class='green'><span class=''> </span><code>         *          &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *              &lt;li&gt;If first member is a string, assumes the rest of the arguments</code></li>
<li class='green'><span class=''> </span><code>         *                  are parameters and interpolates them into the string.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *              &lt;li&gt;If all members are arrays of length two, treats the same way</code></li>
<li class='green'><span class=''> </span><code>         *                  as a hash, except it allows for duplicate keys to be</code></li>
<li class='green'><span class=''> </span><code>         *                  specified.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *              &lt;li&gt;Otherwise, treats each argument as a separate condition.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *           &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;String - taken literally&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;{@link patio.sql.Identifier} - taken as a boolean column argument (e.g. WHERE active)&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;{@link patio.sql.BooleanExpression} - an existing condition expression,</code></li>
<li class='green'><span class=''> </span><code>         *          probably created using the patio.sql methods.</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb] filter also takes a cb, which should return one of the above argument</code></li>
<li class='green'><span class=''> </span><code>         * types, and is treated the same way.  This block is called with an {@link patio.sql} object which can be used to dynaically create expression.  For more details</code></li>
<li class='green'><span class=''> </span><code>         * on the sql object see {@link patio.sql}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;b&gt;NOTE:&lt;/b&gt;If both a cb and regular arguments are provided, they get ANDed together.</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the filter arumgents applied to the WHERE/HAVING clause.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        filter:function (args, cb) {</code></li>
<li class='green'><span class='hits'>3828</span><code>            args = [this.__opts["having"] ? "having" : "where"].concat(argsToArray(arguments));</code></li>
<li class='green'><span class='hits'>3828</span><code>            return this._filter.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#filter</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        find:function () {</code></li>
<li class='green'><span class='hits'>30</span><code>            var args = [this.__opts["having"] ? "having" : "where"].concat(argsToArray(arguments));</code></li>
<li class='green'><span class='hits'>30</span><code>            return this._filter.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("table").forUpdate()</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM table FOR UPDATE</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with a "update" lock style.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        forUpdate:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.lockStyle("update");</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the source changed. If no</code></li>
<li class='green'><span class=''> </span><code>         * source is given, removes all tables.  If multiple sources</code></li>
<li class='green'><span class=''> </span><code>         * are given, it is the same as using a CROSS JOIN (cartesian product) between all tables.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var dataset = DB.from("items");</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.from().sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.from("blah").sql</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM blah</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.from("blah", "foo")</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM blah, foo</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.from({a:"b"}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM a AS b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * dataset.from(dataset.from("a").group("b").as("c")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; "SELECT * FROM (SELECT * FROM a GROUP BY b) AS c"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {...String|...patio.sql.Identifier|...patio.Dataset|...Object} [source] tables to select from</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the FROM clause overridden.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        from:function (source) {</code></li>
<li class='green'><span class='hits'>891</span><code>            source = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>891</span><code>            var tableAliasNum = 0, sources = [];</code></li>
<li class='green'><span class='hits'>891</span><code>            source.forEach(function (s) {</code></li>
<li class='green'><span class='hits'>1106</span><code>                if (isInstanceOf(s, Dataset)) {</code></li>
<li class='green'><span class='hits'>86</span><code>                    sources.push(new AliasedExpression(s, this._datasetAlias(++tableAliasNum)));</code></li>
<li class='green'><span class='hits'>1020</span><code>                } else if (isHash(s)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    for (var i in s) {</code></li>
<li class='green'><span class='hits'>3</span><code>                        sources.push(new AliasedExpression(new Identifier(i), s[i]));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1017</span><code>                } else if (isString(s)) {</code></li>
<li class='green'><span class='hits'>992</span><code>                    sources.push(this.stringToIdentifier(s))</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>25</span><code>                    sources.push(s);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>891</span><code>            var o = {from:sources.length ? sources : null}</code></li>
<li class='green'><span class='hits'>891</span><code>            if (tableAliasNum) {</code></li>
<li class='green'><span class='hits'>84</span><code>                o.numDatasetSources = tableAliasNum;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>891</span><code>            return this.mergeOptions(o)</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a dataset selecting from the current dataset.</code></li>
<li class='green'><span class=''> </span><code>         * Supplying the alias option controls the alias of the result.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds = DB.from("items").order("name").select("id", "name")</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT id,name FROM items ORDER BY name</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.fromSelf().sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS t1</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.fromSelf({alias : "foo"}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS foo</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [opts.alias] alias to use</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the FROM clause set as the current dataset.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fromSelf:function (opts) {</code></li>
<li class='green'><span class='hits'>84</span><code>            opts = isUndefined(opts) ? {} : opts;</code></li>
<li class='green'><span class='hits'>84</span><code>            var fs = {};</code></li>
<li class='green'><span class='hits'>84</span><code>            var nonSqlOptions = this._static.NON_SQL_OPTIONS;</code></li>
<li class='green'><span class='hits'>84</span><code>            Object.keys(this.__opts).forEach(function (k) {</code></li>
<li class='green'><span class='hits'>302</span><code>                if (nonSqlOptions.indexOf(k) == -1) {</code></li>
<li class='green'><span class='hits'>302</span><code>                    fs[k] = null;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>84</span><code>            return this.mergeOptions(fs).from(opts["alias"] ? this.as(opts["alias"]) : this);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Match any of the columns to any of the patterns. The terms can be</code></li>
<li class='green'><span class=''> </span><code>         * strings (which use LIKE) or regular expressions (which are only</code></li>
<li class='green'><span class=''> </span><code>         * supported on MySQL and PostgreSQL).  Note that the total number of</code></li>
<li class='green'><span class=''> </span><code>         * pattern matches will be columns[].length * terms[].length,</code></li>
<li class='green'><span class=''> </span><code>         * which could cause performance issues.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").grep("a", "%test%").sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE (a LIKE '%test%');</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").grep(["a", "b"], ["%test%" "foo"]).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE ((a LIKE '%test%') OR (a LIKE 'foo') OR (b LIKE '%test%') OR (b LIKE 'foo'))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").grep(['a', 'b'], ["%foo%", "%bar%"], {allPatterns : true}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM a WHERE (((a LIKE '%foo%') OR (b LIKE '%foo%')) AND ((a LIKE '%bar%') OR (b LIKE '%bar%')))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").grep(["a", "b"], ['%foo%", "%bar%", {allColumns : true})sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM a WHERE (((a LIKE '%foo%') OR (a LIKE '%bar%')) AND ((b LIKE '%foo%') OR (b LIKE '%bar%')))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").grep(["a", "b"], ["%foo%", "%bar%"], {allPatterns : true, allColumns : true}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM a WHERE ((a LIKE '%foo%') AND (b LIKE '%foo%') AND (a LIKE '%bar%') AND (b LIKE '%bar%'))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String[]|patio.sql.Identifier[]} columns columns to search</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|RegExp} patterns patters to search with</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] options to use when searching. NOTE If both allColumns and allPatterns are true, all columns must match all patterns</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.allColumns] All columns must be matched to any of the given patterns.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.allPatterns] All patterns must match at least one of the columns.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.caseInsensitive] Use a case insensitive pattern match (the default is</code></li>
<li class='green'><span class=''> </span><code>         *                      case sensitive if the database supports it).</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a dataset with the LIKE clauses added</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        grep:function (columns, patterns, opts) {</code></li>
<li class='green'><span class='hits'>15</span><code>            opts = isUndefined(opts) ? {} : opts;</code></li>
<li class='green'><span class='hits'>15</span><code>            var conds;</code></li>
<li class='green'><span class='hits'>15</span><code>            if (opts.hasOwnProperty("allPatterns")) {</code></li>
<li class='green'><span class='hits'>4</span><code>                conds = array.toArray(patterns).map(function (pat) {</code></li>
<li class='green'><span class='hits'>8</span><code>                    return BooleanExpression.fromArgs(</code></li>
<li class='green'><span class=''> </span><code>                        [(opts.allColumns ? "AND" : "OR")]</code></li>
<li class='green'><span class=''> </span><code>                            .concat(array.toArray(columns)</code></li>
<li class='green'><span class=''> </span><code>                            .map(function (c) {</code></li>
<li class='green'><span class='hits'>16</span><code>                                return StringExpression.like(c, pat, opts);</code></li>
<li class='green'><span class=''> </span><code>                            })));</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>4</span><code>                return this.filter(BooleanExpression.fromArgs([opts.allPatterns ? "AND" : "OR"].concat(conds)));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>11</span><code>                conds = array.toArray(columns)</code></li>
<li class='green'><span class=''> </span><code>                    .map(function (c) {</code></li>
<li class='green'><span class='hits'>16</span><code>                        return BooleanExpression.fromArgs(["OR"].concat(array.toArray(patterns).map(function (pat) {</code></li>
<li class='green'><span class='hits'>26</span><code>                            return StringExpression.like(c, pat, opts);</code></li>
<li class='green'><span class=''> </span><code>                        })));</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class='hits'>11</span><code>                return this.filter(BooleanExpression.fromArgs([opts.allColumns ? "AND" : "OR"].concat(conds)));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#grep</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        like:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.grep.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the results grouped by the value of</code></li>
<li class='green'><span class=''> </span><code>         * the given columns.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").group("id")</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;SELECT * FROM items GROUP BY id</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").group("id", "name")</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM items GROUP BY id, name</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...|patio.sql.Identifier...} columns columns to group by.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the GROUP BY clause added.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        group:function (columns) {</code></li>
<li class='green'><span class='hits'>32</span><code>            columns = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>32</span><code>            var stringToIdentifier = this.stringToIdentifier.bind(this)</code></li>
<li class='green'><span class='hits'>32</span><code>            return this.mergeOptions({group:(array.compact(columns).length == 0 ? null : columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>32</span><code>                return isString(c) ? stringToIdentifier(c) : c;</code></li>
<li class='green'><span class=''> </span><code>            }))});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#group</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        groupBy:function () {</code></li>
<li class='green'><span class='hits'>10</span><code>            return this.group.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a dataset grouped by the given column with count by group.</code></li>
<li class='green'><span class=''> </span><code>         * Column aliases may be supplied, and will be included in the select clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").groupAndCount("name").all()</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT name, count(*) AS count FROM items GROUP BY name</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; [{name : 'a', count : 1}, ...]</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").groupAndCount("first_name", "last_name").all()</code></li>
<li class='green'><span class=''> </span><code>         *      //SELECT first_name, last_name, count(*) AS count FROM items GROUP BY first_name, last_name</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; [{first_name : 'a', last_name : 'b', count : 1}, ...]</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").groupAndCount("first_name___name").all()</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT first_name AS name, count(*) AS count FROM items GROUP BY first_name</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; [{name : 'a', count:1}, ...]</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...|patio.sql.Identifier...} columns columns to croup and count on.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the GROUP clause and count added.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        groupAndCount:function (columns) {</code></li>
<li class='green'><span class='hits'>8</span><code>            columns = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>8</span><code>            var group = this.group.apply(this, columns.map(function (c) {</code></li>
<li class='green'><span class='hits'>9</span><code>                return this._unaliasedIdentifier(c);</code></li>
<li class='green'><span class=''> </span><code>            }, this));</code></li>
<li class='green'><span class='hits'>8</span><code>            return group.select.apply(group, columns.concat([this._static.COUNT_OF_ALL_AS_COUNT]));</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the HAVING conditions changed. See {@link patio.Dataset#filter} for argument types.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").group("sum").having({sum : 10}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items GROUP BY sum HAVING (sum = 10)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with HAVING clause changed or added.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        having:function () {</code></li>
<li class='green'><span class='hits'>12</span><code>            var cond = argsToArray(arguments).map(function (s) {</code></li>
<li class='green'><span class='hits'>12</span><code>                return isString(s) &amp;&amp; s !== '' ? this.stringToIdentifier(s) : s</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>12</span><code>            return this._filter.apply(this, ["having"].concat(cond));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds an INTERSECT clause using a second dataset object.</code></li>
<li class='green'><span class=''> </span><code>         * An INTERSECT compound dataset returns all rows in both the current dataset</code></li>
<li class='green'><span class=''> </span><code>         * and the given dataset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").intersect(DB.from("other_items")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS t1</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").intersect(DB.from("other_items"), {all : true, fromSelf : false}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; SELECT * FROM items INTERSECT ALL SELECT * FROM other_items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").intersect(DB.from("other_items"), {alias : "i"}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS i</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {patio.QueryError} if the operation is not supported.</code></li>
<li class='green'><span class=''> </span><code>         * @param  {patio.Dataset} dataset the dataset to intersect</code></li>
<li class='green'><span class=''> </span><code>         * @param  {Object} [opts] options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [opts.alias] Use the given value as the {@link patio.Dataset#fromSelf} alias</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.all] Set to true to use INTERSECT ALL instead of INTERSECT, so duplicate rows can occur</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.fromSelf] Set to false to not wrap the returned dataset in a {@link patio.Dataset#fromSelf}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the INTERSECT clause.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        intersect:function (dataset, opts) {</code></li>
<li class='green'><span class='hits'>18</span><code>            opts = isUndefined(opts) ? {} : opts;</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!isHash(opts)) {</code></li>
<li class='green'><span class='hits'>5</span><code>                opts = {all:opts};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>18</span><code>            if (!this.supportsIntersectExcept) {</code></li>
<li class='green'><span class='hits'>2</span><code>                throw new QueryError("INTERSECT not supported");</code></li>
<li class='green'><span class='hits'>16</span><code>            } else if (opts.all &amp;&amp; !this.supportsIntersectExceptAll) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("INTERSECT ALL not supported");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>15</span><code>            return this.compoundClone("intersect", dataset, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Inverts the current filter.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter({category : 'software'}).invert()</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE (category != 'software')</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter({category : 'software', id : 3}).invert()</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items WHERE ((category != 'software') OR (id != 3))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the filter inverted.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        invert:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>            var having = this.__opts.having, where = this.__opts.where;</code></li>
<li class='green'><span class='hits'>3</span><code>            if (!(having || where)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("No current filter");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2</span><code>            var o = {}</code></li>
<li class='green'><span class='hits'>2</span><code>            if (having) {</code></li>
<li class='green'><span class='hits'>1</span><code>                o.having = BooleanExpression.invert(having);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2</span><code>            if (where) {</code></li>
<li class='green'><span class='hits'>2</span><code>                o.where = BooleanExpression.invert(where);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.mergeOptions(o);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with an inner join applied.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#joinTable</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        join:function () {</code></li>
<li class='green'><span class='hits'>236</span><code>            return this.innerJoin.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a joined dataset.  Uses the following arguments:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").joinTable("leftOuter", "categories", [["categoryId", "id"],["categoryId", [1, 2, 3]]]).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'SELECT</code></li>
<li class='green'><span class=''> </span><code>         *             *</code></li>
<li class='green'><span class=''> </span><code>         *            FROM</code></li>
<li class='green'><span class=''> </span><code>         *              `items`</code></li>
<li class='green'><span class=''> </span><code>         *                  LEFT OUTER JOIN</code></li>
<li class='green'><span class=''> </span><code>         *              `categories` ON (</code></li>
<li class='green'><span class=''> </span><code>         *                          (`categories`.`categoryId` = `items`.`id`)</code></li>
<li class='green'><span class=''> </span><code>         *                              AND</code></li>
<li class='green'><span class=''> </span><code>         *                          (`categories`.`categoryId` IN (1,2, 3))</code></li>
<li class='green'><span class=''> </span><code>         *                          )</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").leftOuter("categories", [["categoryId", "id"],["categoryId", [1, 2, 3]]]).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;'SELECT</code></li>
<li class='green'><span class=''> </span><code>         *             *</code></li>
<li class='green'><span class=''> </span><code>         *            FROM</code></li>
<li class='green'><span class=''> </span><code>         *              `items`</code></li>
<li class='green'><span class=''> </span><code>         *                  LEFT OUTER JOIN</code></li>
<li class='green'><span class=''> </span><code>         *              `categories` ON (</code></li>
<li class='green'><span class=''> </span><code>         *                          (`categories`.`categoryId` = `items`.`id`)</code></li>
<li class='green'><span class=''> </span><code>         *                              AND</code></li>
<li class='green'><span class=''> </span><code>         *                          (`categories`.`categoryId` IN (1,2, 3))</code></li>
<li class='green'><span class=''> </span><code>         *                          )</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").leftOuterJoin("categories", {categoryId:"id"}).sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" LEFT OUTER JOIN "categories" ON ("categories"."categoryId" = "items"."id")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").rightOuterJoin("categories", {categoryId:"id"}).sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" RIGHT OUTER JOIN "categories" ON ("categories"."categoryId" = "items"."id")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").fullOuterJoin("categories", {categoryId:"id"}).sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" FULL OUTER JOIN "categories" ON ("categories"."categoryId" = "items"."id")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").innerJoin("categories", {categoryId:"id"}).sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" INNER JOIN "categories" ON ("categories"."categoryId" = "items"."id")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").leftJoin("categories", {categoryId:"id"}).sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" LEFT JOIN "categories" ON ("categories"."categoryId" = "items"."id")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").rightJoin("categories", {categoryId:"id"}).sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" RIGHT JOIN "categories" ON ("categories"."categoryId" = "items"."id")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").fullJoin("categories", {categoryId:"id"}).sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" FULL JOIN "categories" ON ("categories"."categoryId" = "items"."id")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").naturalJoin("categories").sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" NATURAL JOIN "categories"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").naturalLeftJoin("categories").sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" NATURAL LEFT JOIN "categories"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").naturalRightJoin("categories").sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" NATURAL RIGHT JOIN "categories"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").naturalFullJoin("categories").sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" NATURAL FULL JOIN "categories"'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").crossJoin("categories").sql</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM "items" CROSS JOIN "categories"</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} type the type of join to do.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier|patio.Dataset|Object} table depends on the type.</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;{@link patio.Dataset} - a subselect is performed with an alias&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;Object - an object that has a tableName property.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *      &lt;li&gt;String|{@link patio.sql.Identifier}  - the name of the table&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *  &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param [expr] - depends on type</code></li>
<li class='green'><span class=''> </span><code>         * &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;Object|Array of two element arrays - Assumes key (1st arg) is column of joined table (unless already</code></li>
<li class='green'><span class=''> </span><code>         *     qualified), and value (2nd arg) is column of the last joined or primary table (or the</code></li>
<li class='green'><span class=''> </span><code>         *     implicitQualifier option&lt;/li&gt;.</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;Array - If all members of the array are string or {@link patio.sql.Identifier}, considers</code></li>
<li class='green'><span class=''> </span><code>         *     them as columns and uses a JOIN with a USING clause.  Most databases will remove duplicate columns from</code></li>
<li class='green'><span class=''> </span><code>         *     the result set if this is used.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;null|undefined(not passed in) - If a cb is not given, doesn't use ON or USING, so the JOIN should be a NATURAL</code></li>
<li class='green'><span class=''> </span><code>         *     or CROSS join. If a block is given, uses an ON clause based on the block, see below.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *     &lt;li&gt;Everything else - pretty much the same as a using the argument in a call to {@link patio.Dataset#filter},</code></li>
<li class='green'><span class=''> </span><code>         *     so strings are considered literal, {@link patio.sql.Identifiers} specify boolean columns, and patio.sql</code></li>
<li class='green'><span class=''> </span><code>         *      expressions can be used. Uses a JOIN with an ON clause.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} options an object of options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [options.tableAlias=undefined] the name of the table's alias when joining, necessary for joining</code></li>
<li class='green'><span class=''> </span><code>         *     to the same table more than once.  No alias is used by default.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [options.implicitQualifier=undefined] The name to use for qualifying implicit conditions.  By default,</code></li>
<li class='green'><span class=''> </span><code>         *     the last joined or primary table is used.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [cb]  cb - The cb argument should only be given if a JOIN with an ON clause is used,</code></li>
<li class='green'><span class=''> </span><code>         *   in which case it is called with</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;li&gt;table alias/name for the table currently being joined&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;li&gt; the table alias/name for the last joined (or first table)</code></li>
<li class='green'><span class=''> </span><code>         *       &lt;li&gt;array of previous&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   the cb should return an expression to be used in the ON clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset joined using the arguments.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        joinTable:function (type, table, expr, options, cb) {</code></li>
<li class='green'><span class='hits'>795</span><code>            var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>795</span><code>            if (isFunction(args[args.length - 1])) {</code></li>
<li class='green'><span class='hits'>12</span><code>                cb = args[args.length - 1];</code></li>
<li class='green'><span class='hits'>12</span><code>                args.pop();</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>783</span><code>                cb = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>795</span><code>            type = args.shift(), table = args.shift(), expr = args.shift(), options = args.shift();</code></li>
<li class='green'><span class='hits'>795</span><code>            expr = isUndefined(expr) ? null : expr, options = isUndefined(options) ? {} : options;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>795</span><code>            var h;</code></li>
<li class='green'><span class='hits'>795</span><code>            var usingJoin = isArray(expr) &amp;&amp; expr.length &amp;&amp; expr.every(function (x) {</code></li>
<li class='green'><span class='hits'>344</span><code>                return isString(x) || isInstanceOf(x, Identifier)</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>795</span><code>            if (usingJoin &amp;&amp; !this.supportsJoinUsing) {</code></li>
<li class='green'><span class='hits'>1</span><code>                h = {};</code></li>
<li class='green'><span class='hits'>1</span><code>                expr.forEach(function (s) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    h[s] = s;</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.joinTable(type, table, h, options);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>794</span><code>            var tableAlias, lastAlias;</code></li>
<li class='green'><span class='hits'>794</span><code>            if (isHash(options)) {</code></li>
<li class='green'><span class='hits'>784</span><code>                tableAlias = options.tableAlias;</code></li>
<li class='green'><span class='hits'>784</span><code>                lastAlias = options.implicitQualifier;</code></li>
<li class='green'><span class='hits'>10</span><code>            } else if (isString(options) || isInstanceOf(options, Identifier)) {</code></li>
<li class='green'><span class='hits'>9</span><code>                tableAlias = options;</code></li>
<li class='green'><span class='hits'>9</span><code>                lastAlias = null;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("Invalid options format for joinTable %j4", [options]);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>793</span><code>            var tableAliasNum, tableName;</code></li>
<li class='green'><span class='hits'>793</span><code>            if (isInstanceOf(table, Dataset)) {</code></li>
<li class='green'><span class='hits'>11</span><code>                if (!tableAlias) {</code></li>
<li class='green'><span class='hits'>6</span><code>                    tableAliasNum = (this.__opts.numDatasetSources || 0) + 1;</code></li>
<li class='green'><span class='hits'>6</span><code>                    tableAlias = this._datasetAlias(tableAliasNum);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>11</span><code>                tableName = tableAlias;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>782</span><code>                if (!isUndefined(table.tableName)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    table = table.tableName;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>782</span><code>                if (isArray(table)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    table = table.map(this.stringToIdentifier, this);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>780</span><code>                    table = isString(table) ? this.stringToIdentifier(table) : table;</code></li>
<li class='green'><span class='hits'>780</span><code>                    var parts = this._splitAlias(table), implicitTableAlias = parts[1];</code></li>
<li class='green'><span class='hits'>780</span><code>                    table = parts[0]</code></li>
<li class='green'><span class='hits'>780</span><code>                    tableAlias = tableAlias || implicitTableAlias;</code></li>
<li class='green'><span class='hits'>780</span><code>                    tableName = tableAlias || table;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>793</span><code>            var join;</code></li>
<li class='green'><span class='hits'>793</span><code>            if (!expr &amp;&amp; !cb) {</code></li>
<li class='green'><span class='hits'>22</span><code>                join = new JoinClause(type, table, tableAlias);</code></li>
<li class='green'><span class='hits'>771</span><code>            } else if (usingJoin) {</code></li>
<li class='green'><span class='hits'>9</span><code>                if (cb) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    throw new QueryError("cant use a cb if an array is given");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>8</span><code>                join = new JoinUsingClause(expr, type, table, tableAlias);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>762</span><code>                lastAlias = lastAlias || this.__opts["lastJoinedTable"] || this.firstSourceAlias;</code></li>
<li class='green'><span class='hits'>761</span><code>                if (Expression.isConditionSpecifier(expr)) {</code></li>
<li class='green'><span class='hits'>749</span><code>                    var newExpr = [];</code></li>
<li class='green'><span class='hits'>749</span><code>                    for (var i in expr) {</code></li>
<li class='green'><span class='hits'>1207</span><code>                        var val = expr[i];</code></li>
<li class='green'><span class='hits'>1207</span><code>                        if (isArray(val) &amp;&amp; val.length == 2) {</code></li>
<li class='green'><span class='hits'>660</span><code>                            i = val[0], val = val[1];</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>1207</span><code>                        var k = this.qualifiedColumnName(i, tableName), v;</code></li>
<li class='green'><span class='hits'>1207</span><code>                        if (isInstanceOf(val, Identifier)) {</code></li>
<li class='green'><span class='hits'>542</span><code>                            v = val.qualify(lastAlias);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>665</span><code>                            v = val;</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class='hits'>1207</span><code>                        newExpr.push([k, v]);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>749</span><code>                    expr = newExpr;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>761</span><code>                if (isFunction(cb)) {</code></li>
<li class='green'><span class='hits'>11</span><code>                    var expr2 = cb.apply(sql, [tableName, lastAlias, this.__opts.join || []]);</code></li>
<li class='green'><span class='hits'>11</span><code>                    expr = expr ? new BooleanExpression("AND", expr, expr2) : expr2;</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>761</span><code>                join = new JoinOnClause(expr, type, table, tableAlias);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>791</span><code>            var opts = {join:(this.__opts.join || []).concat([join]), lastJoinedTable:tableName};</code></li>
<li class='green'><span class='hits'>791</span><code>            if (tableAliasNum) {</code></li>
<li class='green'><span class='hits'>6</span><code>                opts.numDatasetSources = tableAliasNum;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>791</span><code>            return this.mergeOptions(opts);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * If given an integer, the dataset will contain only the first l results.</code></li>
<li class='green'><span class=''> </span><code>         If a second argument is given, it is used as an offset. To use</code></li>
<li class='green'><span class=''> </span><code>         * an offset without a limit, pass null as the first argument.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").limit(10)</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items LIMIT 10</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").limit(10, 20)</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items LIMIT 10 OFFSET 20</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").limit([3, 7]).sql</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items LIMIT 5 OFFSET 3');</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").limit(null, 20)</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items OFFSET 20</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").limit('6', sql['a() - 1']).sql</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; 'SELECT * FROM items LIMIT 6 OFFSET a() - 1');</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number|String|Number[]} limit the limit to apply</code></li>
<li class='green'><span class=''> </span><code>         * @param {Number|String|patio.sql.LiteralString} offset the offset to apply</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset}  a cloned dataset witht the LIMIT and OFFSET applied.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        limit:function (limit, offset) {</code></li>
<li class='green'><span class='hits'>46</span><code>            if (this.__opts.sql) {</code></li>
<li class='green'><span class='hits'>7</span><code>                return this.fromSelf().limit(limit, offset);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>39</span><code>            if (isArray(limit) &amp;&amp; limit.length == 2) {</code></li>
<li class='green'><span class='hits'>1</span><code>                offset = limit[0];</code></li>
<li class='green'><span class='hits'>1</span><code>                limit = limit[1] - limit[0] + 1;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>39</span><code>            if (isString(limit) || isInstanceOf(limit, LiteralString)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                limit = parseInt("" + limit, 10);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>39</span><code>            if (isNumber(limit) &amp;&amp; limit &lt; 1) {</code></li>
<li class='green'><span class='hits'>2</span><code>                throw new QueryError("Limit must be &gt;= 1");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>37</span><code>            var opts = {limit:limit};</code></li>
<li class='green'><span class='hits'>37</span><code>            if (offset) {</code></li>
<li class='green'><span class='hits'>9</span><code>                if (isString(offset) || isInstanceOf(offset, LiteralString)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    offset = parseInt("" + offset, 10);</code></li>
<li class='green'><span class='hits'>1</span><code>                    isNaN(offset) &amp;&amp; (offset = 0);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>9</span><code>                if (isNumber(offset) &amp;&amp; offset &lt; 0) {</code></li>
<li class='green'><span class='hits'>1</span><code>                    throw new QueryError("Offset must be &gt;= 0");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>8</span><code>                opts.offset = offset;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>36</span><code>            return this.mergeOptions(opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with a not equal expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").neq({x : 1});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE (x != 1)</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").neq({x : 1, y : 10});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x != 1) AND (y != 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the not equal expression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the not equal expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        neq:function (obj) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("neq", obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with an equal expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").eq({x : 1});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE (x = 1)</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").eq({x : 1, y : 10});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x = 1) AND (y = 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the equal expression</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the equal expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        eq:function (obj) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("eq", obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with a greater than expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").gt({x : 1});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE (x &gt; 1)</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").gt({x : 1, y : 10});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &gt; 1) AND (y &gt; 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the greater than expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the greater than expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        gt:function (obj) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("gt", obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with a less than expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").lt({x : 1});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE (x &lt; 1)</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").lt({x : 1, y : 10});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &lt; 1) AND (y &lt; 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the less than expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the less than expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        lt:function (obj) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("lt", obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS NOT expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNot({boolFlag : null});</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NOT NULL);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNot({boolFlag : false, otherFlag : true, name : null});</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE ((boolFlag IS NOT FALSE) AND (otherFlag IS NOT TRUE) AND (name IS NOT NULL));</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the IS NOT expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS NOT expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isNot:function (obj) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.filter(this.__createBoolExpression("isNot", obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").is({boolFlag : null});</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NULL);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").is({boolFlag : false, otherFlag : true, name : null});</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE ((boolFlag IS FALSE) AND (otherFlag IS TRUE) AND (name IS NULL));</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the IS expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        is:function (obj) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.filter(this.__createBoolExpression("is", obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS NOT NULL boolean expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNotNull("boolFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NOT NULL);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNotNull("boolFlag", "otherFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NOT NULL AND otherFlag IS NOT NULL);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} arr variable number of arguments to create an IS NOT NULL expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS NOT NULL expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isNotNull:function (arr) {</code></li>
<li class='green'><span class='hits'>3</span><code>            arr = this.__arrayToConditionSpecifier(argsToArray(arguments), null);</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("isNot", arr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS NULL boolean expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNull("boolFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NULL);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNull("boolFlag", "otherFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NULL AND otherFlag IS NULL);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} arr variable number of arguments to create an IS NULL expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS NULL expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isNull:function (arr) {</code></li>
<li class='green'><span class='hits'>3</span><code>            arr = this.__arrayToConditionSpecifier(argsToArray(arguments), null);</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("is", arr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS NOT TRUE boolean expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNotTrue("boolFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NOT TRUE);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNotTrue("boolFlag", "otherFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NOT TRUE AND otherFlag IS NOT TRUE);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} arr variable number of arguments to create an IS NOT TRUE expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS NOT TRUE expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isNotTrue:function (arr) {</code></li>
<li class='green'><span class='hits'>3</span><code>            arr = this.__arrayToConditionSpecifier(argsToArray(arguments), true);</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("isNot", arr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS TRUE boolean expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isTrue("boolFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS TRUE);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isTrue("boolFlag", "otherFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS TRUE AND otherFlag IS TRUE);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} arr variable number of arguments to create an IS TRUE expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS TRUE expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isTrue:function (arr) {</code></li>
<li class='green'><span class='hits'>3</span><code>            arr = this.__arrayToConditionSpecifier(argsToArray(arguments), true);</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("is", arr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS NOT FALSE boolean expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNotFalse("boolFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NOT FALSE);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isNotFalse("boolFlag", "otherFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS NOT FALSE AND otherFlag IS NOT FALSE);</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} arr variable number of arguments to create an IS NOT FALSE expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS NOT FALSE expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isNotFalse:function (arr) {</code></li>
<li class='green'><span class='hits'>3</span><code>            arr = this.__arrayToConditionSpecifier(argsToArray(arguments), false);</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("isNot", arr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returnes a cloned dataset with the IS FALSE boolean expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isFalse("boolFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS FALSE);</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("test").isFalse("boolFlag", "otherFlag");</code></li>
<li class='green'><span class=''> </span><code>         *      =&gt; SELECT * FROM test WHERE (boolFlag IS FALSE AND otherFlag IS FALSE);</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} arr variable number of arguments to create an IS FALSE expression for.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the IS FALSE expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        isFalse:function (arr) {</code></li>
<li class='green'><span class='hits'>3</span><code>            arr = this.__arrayToConditionSpecifier(argsToArray(arguments), false);</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("is", arr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with a greater than or equal to expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").gte({x : 1});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE (x &gt;= 1)</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").gte({x : 1, y : 10});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &gt;= 1) AND (y &gt;= 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the greater than or equal to expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the greater than or equal to expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        gte:function (arr) {</code></li>
<li class='green'><span class='hits'>2</span><code>            arr = this.__arrayToConditionSpecifier(argsToArray(arguments), "gte");</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("gte", arr));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with a less than or equal to expression added to the WHERE</code></li>
<li class='green'><span class=''> </span><code>         * clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").gte({x : 1});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE (x &lt;= 1)</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("test").gte({x : 1, y : 10});</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &lt;= 1) AND (y &lt;= 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object used to create the less than or equal to expression.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the less than or equal to expression added to the WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        lte:function (obj) {</code></li>
<li class='green'><span class='hits'>2</span><code>            var arr = this.__arrayToConditionSpecifier(argsToArray(arguments), "lte");</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBoolExpression("lte", obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with a between clause added</code></li>
<li class='green'><span class=''> </span><code>         * to the where clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  ds.notBetween({x:[1, 2]}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &gt;= 1) OR (x &lt;= 2))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  ds.find({x:{notBetween:[1, 2]}}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &gt;= 1) OR (x &lt;= 2))</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object where the key is the column and the value is an array where the first element</code></li>
<li class='green'><span class=''> </span><code>         *                     is the item to be greater than or equal to than and the second item is less than or equal to than.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with a between clause added</code></li>
<li class='green'><span class=''> </span><code>         * to the where clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        between:function (obj) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBetweenExpression(obj));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with a not between clause added</code></li>
<li class='green'><span class=''> </span><code>         * to the where clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  ds.notBetween({x:[1, 2]}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &lt; 1) OR (x &gt; 2))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  ds.find({x:{notBetween:[1, 2]}}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM test WHERE ((x &lt; 1) OR (x &gt; 2))</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object where the key is the column and the value is an array where the first element</code></li>
<li class='green'><span class=''> </span><code>         *                     is the item to be less than and the second item is greater than.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with a not between clause added</code></li>
<li class='green'><span class=''> </span><code>         * to the where clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        notBetween:function (obj) {</code></li>
<li class='green'><span class='hits'>2</span><code>            return this.filter(this.__createBetweenExpression(obj, true));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset with the given lock style.  If style is a</code></li>
<li class='green'><span class=''> </span><code>         * string, it will be used directly.Currently "update" is respected</code></li>
<li class='green'><span class=''> </span><code>         * by most databases, and "share" is supported by some.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").lockStyle('FOR SHARE') # SELECT * FROM items FOR SHARE</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} style the lock style to use.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned datase with the given lock style.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        lockStyle:function (style) {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.mergeOptions({lock:style});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the order changed. If the dataset has an</code></li>
<li class='green'><span class=''> </span><code>         * existing order, it is ignored and overwritten with this order. If null is given</code></li>
<li class='green'><span class=''> </span><code>         * the returned dataset has no order. This can accept multiple arguments</code></li>
<li class='green'><span class=''> </span><code>         * of varying kinds, such as SQL functions.  This also takes a function similar</code></li>
<li class='green'><span class=''> </span><code>         * to {@link patio.Dataset#filter}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order("name")</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM items ORDER BY name</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order("a", "b")</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM items ORDER BY a, b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order(sql.literal('a + b'))</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM items ORDER BY a + b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order(sql.identifier("a").plus("b"))</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM items ORDER BY (a + b)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order(sql.identifier("name").desc())</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM items ORDER BY name DESC</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order(sql.identifier("name").asc({nulls : "last"))</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM items ORDER BY name ASC NULLS LAST</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order(function(){</code></li>
<li class='green'><span class=''> </span><code>         *          return this.sum("name").desc();</code></li>
<li class='green'><span class=''> </span><code>         *  }); //=&gt; SELECT * FROM items ORDER BY sum(name) DESC</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").order(null)</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt;SELECT * FROM items</code></li>
<li class='green'><span class=''> </span><code>         *  @param arg variable number of arguments similar to {@link patio.Dataset#filter}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @return {patio.Dataset} a cloned dataset with the order changed.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        order:function (args) {</code></li>
<li class='green'><span class='hits'>413</span><code>            args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>413</span><code>            var order = [];</code></li>
<li class='green'><span class='hits'>413</span><code>            args = compact(args).length ? args : null;</code></li>
<li class='green'><span class='hits'>413</span><code>            if (args) {</code></li>
<li class='green'><span class='hits'>271</span><code>                args.forEach(function (a) {</code></li>
<li class='green'><span class='hits'>334</span><code>                    if (isString(a)) {</code></li>
<li class='green'><span class='hits'>212</span><code>                        order.push(this.stringToIdentifier(a));</code></li>
<li class='green'><span class='hits'>122</span><code>                    } else if (isFunction(a)) {</code></li>
<li class='green'><span class='hits'>16</span><code>                        var res = a.apply(sql, [sql]);</code></li>
<li class='green'><span class='hits'>16</span><code>                        order = order.concat(isArray(res) ? res : [res]);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>106</span><code>                        order.push(a);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>142</span><code>                order = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>413</span><code>            return this.mergeOptions({order:order});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Alias of {@link patio.Dataset#orderMore};</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        orderAppend:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.orderMore.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#order</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        orderBy:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            return this.order.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the order columns added</code></li>
<li class='green'><span class=''> </span><code>         * to the end of the existing order. For more detail</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#order</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").order("a").order("b");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items ORDER BY b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").order("a").orderMore("b");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;SELECT * FROM items ORDER BY a, b</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        orderMore:function () {</code></li>
<li class='green'><span class='hits'>11</span><code>            var args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>11</span><code>            if (this.__opts.order) {</code></li>
<li class='green'><span class='hits'>9</span><code>                args = this.__opts.order.concat(args);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>11</span><code>            return this.order.apply(this, args);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the order columns added</code></li>
<li class='green'><span class=''> </span><code>         * to the beginning of the existing order. For more detail</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#order</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").order("a").order("b");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items ORDER BY b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").order("a").orderPrepend("b");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt;SELECT * FROM items ORDER BY b, a</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        orderPrepend:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>            var ds = this.order.apply(this, arguments);</code></li>
<li class='green'><span class='hits'>4</span><code>            return this.__opts.order ? ds.orderMore.apply(ds, this.__opts.order) : ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Qualify to the given table, or {@link patio.Dataset#firstSourceAlias} if not table is given.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter({id : 1}).qualify();</code></li>
<li class='green'><span class=''> </span><code>         *    //=&gt; SELECT items.* FROM items WHERE (items.id = 1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter({id : 1}).qualify("i");</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; SELECT i.* FROM items WHERE (i.id = 1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [table={@link patio.Dataset#firstSourceAlias}] the table name to qualify to.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset qualified to the table or {@link patio.Dataset#firstSourceAlias}</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        qualify:function (table) {</code></li>
<li class='green'><span class='hits'>19</span><code>            table = table || this.firstSourceAlias;</code></li>
<li class='green'><span class='hits'>19</span><code>            return this.qualifyTo(table);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Qualify the dataset to its current first source(first from clause).  This is useful</code></li>
<li class='green'><span class=''> </span><code>         * if you have unqualified identifiers in the query that all refer to</code></li>
<li class='green'><span class=''> </span><code>         * the first source, and you want to join to another table which</code></li>
<li class='green'><span class=''> </span><code>         * has columns with the same name as columns in the current dataset.</code></li>
<li class='green'><span class=''> </span><code>         * See {@link patio.Dataset#qualifyTo}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").filter({id : 1}).qualifyToFirstSource();</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT items.* FROM items WHERE (items.id = 1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset that is qualified with the first source.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        qualifyToFirstSource:function () {</code></li>
<li class='green'><span class='hits'>18</span><code>            return this.qualifyTo(this.firstSourceAlias);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Return a copy of the dataset with unqualified identifiers in the</code></li>
<li class='green'><span class=''> </span><code>         * SELECT, WHERE, GROUP, HAVING, and ORDER clauses qualified by the</code></li>
<li class='green'><span class=''> </span><code>         * given table. If no columns are currently selected, select all</code></li>
<li class='green'><span class=''> </span><code>         * columns of the given table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").filter({id : 1}).qualifyTo("i");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT i.* FROM items WHERE (i.id = 1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} table the name to qualify identifier to.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with unqualified identifiers qualified.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        qualifyTo:function (table) {</code></li>
<li class='green'><span class='hits'>40</span><code>            var o = this.__opts;</code></li>
<li class='green'><span class='hits'>40</span><code>            if (o.sql) {</code></li>
<li class='green'><span class='hits'>2</span><code>                return this.mergeOptions();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>38</span><code>            var h = {};</code></li>
<li class='green'><span class='hits'>38</span><code>            array.intersect(Object.keys(o), this._static.QUALIFY_KEYS).forEach(function (k) {</code></li>
<li class='green'><span class='hits'>65</span><code>                h[k] = this._qualifiedExpression(o[k], table);</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>38</span><code>            if (!o.select || isEmpty(o.select)) {</code></li>
<li class='green'><span class='hits'>14</span><code>                h.select = [new ColumnAll(table)];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>38</span><code>            return this.mergeOptions(h);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Same as {@link patio.Dataset@qualifyTo} except that it forces qualification on methods called</code></li>
<li class='green'><span class=''> </span><code>         * after it has been called.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //qualfyTo would generate</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").qualifyTo("i").filter({id : 1});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT i.* FROM items WHERE (id = 1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //alwaysQualify qualifies filter also.</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").alwaysQualify("i").filter({id : 1});</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT i.* FROM items WHERE (i.id = 1)</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [table=this.firstSourceAlias] the table to qualify to.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset that will always qualify.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        alwaysQualify:function (table) {</code></li>
<li class='green'><span class='hits'>3</span><code>            return this.mergeOptions({alwaysQualify:table || this.firstSourceAlias});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the order reversed. If no order is</code></li>
<li class='green'><span class=''> </span><code>         * given, the existing order is inverted.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").reverse("id");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items ORDER BY id DESC</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").order("id").reverse();</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items ORDER BY id DESC</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").order("id").reverse(sql.identifier("name").asc);</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items ORDER BY name ASC</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier|Function} args variable number of columns add to order before reversing.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the order reversed.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        reverse:function (args) {</code></li>
<li class='green'><span class='hits'>46</span><code>            args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>46</span><code>            return this.order.apply(this, this._invertOrder(args.length ? args : this.__opts.order));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @see patio.Dataset#reverse</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        reverseOrder:function () {</code></li>
<li class='green'><span class='hits'>16</span><code>            return this.reverse.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the columns selected changed</code></li>
<li class='green'><span class=''> </span><code>         * to the given columns. This also takes a function similar to {@link patio.Dataset#filter}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").select("a");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT a FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").select("a", "b");</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT a, b FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").select("a", function(){</code></li>
<li class='green'><span class=''> </span><code>         *          return this.sum("b")</code></li>
<li class='green'><span class=''> </span><code>         *   }).sql;  //=&gt; SELECT a, sum(b) FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @param {String|patio.sql.Identifier|Function} args variable number of colums to select</code></li>
<li class='green'><span class=''> </span><code>         *  @return {patio.Dataset} a cloned dataset with the columns selected changed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        select:function (args) {</code></li>
<li class='green'><span class='hits'>500</span><code>            args = flatten(argsToArray(arguments));</code></li>
<li class='green'><span class='hits'>500</span><code>            var columns = [];</code></li>
<li class='green'><span class='hits'>500</span><code>            args.forEach(function (c) {</code></li>
<li class='green'><span class='hits'>920</span><code>                if (isFunction(c)) {</code></li>
<li class='green'><span class='hits'>23</span><code>                    var res = c.apply(sql, [sql]);</code></li>
<li class='green'><span class='hits'>23</span><code>                    columns = columns.concat(isArray(res) ? res : [res]);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>897</span><code>                    columns.push(c);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>500</span><code>            var select = [];</code></li>
<li class='green'><span class='hits'>500</span><code>            columns.forEach(function (c) {</code></li>
<li class='green'><span class='hits'>923</span><code>                if (isHash(c)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                    for (var i in c) {</code></li>
<li class='green'><span class='hits'>4</span><code>                        select.push(new AliasedExpression(new Identifier(i), c[i]));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>920</span><code>                } else if (isString(c)) {</code></li>
<li class='green'><span class='hits'>371</span><code>                    select.push(this.stringToIdentifier(c));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>549</span><code>                    select.push(c);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>500</span><code>            return this.mergeOptions({select:select});</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a cloned dataset that selects *.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset}  a cloned dataset that selects *.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        selectAll:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            return this.mergeOptions({select:null});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Selects the columns if only if there is not already select sources.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var ds = DB.from("items"); //SELECT * FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.select("a"); //SELECT a FROM items;</code></li>
<li class='green'><span class=''> </span><code>         * ds.select("a").selectIfNoSource("a", "b"). //SELECT a FROM items;</code></li>
<li class='green'><span class=''> </span><code>         * ds.selectIfNoSource("a", "b"). //SELECT a, b FROM items;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param cols columns to select if there is not already select sources.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the appropriate select sources.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        selectIfNoSource:function (cols) {</code></li>
<li class='red'><span class='nohits'>0</span><code>            var ret;</code></li>
<li class='red'><span class='nohits'>0</span><code>            if (!this.hasSelectSource) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = this.select.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret = this.mergeOptions();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='red'><span class='nohits'>0</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the given columns added</code></li>
<li class='green'><span class=''> </span><code>         * to the existing selected columns. If no columns are currently selected,</code></li>
<li class='green'><span class=''> </span><code>         * it will select the columns given in addition to *.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").select("a").selectAppend("b").sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT b FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").select("a").selectAppend("b", "c", "d").sql</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT a, b, c, d FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").selectAppend("b").sql</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT *, b FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param [...] cols variable number of columns to add to the select statement</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} returns a cloned dataset with the new select columns appended.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        selectAppend:function (cols) {</code></li>
<li class='green'><span class='hits'>7</span><code>            cols = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>7</span><code>            var currentSelect = this.__opts.select;</code></li>
<li class='green'><span class='hits'>7</span><code>            if (!currentSelect || !currentSelect.length) {</code></li>
<li class='green'><span class='hits'>3</span><code>                currentSelect = [this._static.WILDCARD];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>7</span><code>            return this.select.apply(this, currentSelect.concat(cols));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the given columns added</code></li>
<li class='green'><span class=''> </span><code>         * to the existing selected columns. If no columns are currently selected</code></li>
<li class='green'><span class=''> </span><code>         * it will just select the columns given.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").select("a").select("b").sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT b FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").select("a").selectMore("b", "c", "d").sql</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT a, b, c, d FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").selectMore("b").sql</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT b FROM items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param [...] cols variable number of columns to add to the select statement</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} returns a cloned dataset with the new select columns appended.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        selectMore:function (cols) {</code></li>
<li class='green'><span class='hits'>10</span><code>            cols = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>10</span><code>            var currentSelect = this.__opts.select;</code></li>
<li class='green'><span class='hits'>10</span><code>            return this.select.apply(this, (currentSelect || []).concat(cols));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set the default values for insert and update statements.  The values hash passed</code></li>
<li class='green'><span class=''> </span><code>         * to insert or update are merged into this hash, so any values in the hash passed</code></li>
<li class='green'><span class=''> </span><code>         * to insert or update will override values passed to this method.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").setDefaults({a : 'a', c : 'c'}).insert({a : 'd', b : 'b'}).insertSql();</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO items (a, c, b) VALUES ('d', 'c', 'b')</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} hash object with key value pairs to use as override values</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the defaults added to the current datasets defaults.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        setDefaults:function (hash) {</code></li>
<li class='green'><span class='hits'>5</span><code>            return this.mergeOptions({defaults:merge({}, this.__opts.defaults || {}, hash)});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Set values that override hash arguments given to insert and update statements.</code></li>
<li class='green'><span class=''> </span><code>         * This hash is merged into the hash provided to insert or update, so values</code></li>
<li class='green'><span class=''> </span><code>         * will override any values given in the insert/update hashes.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").setOverrides({a : 'a', c : 'c'}).insert({a : 'd', b : 'b'}).insertSql();</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; INSERT INTO items (a, c, b) VALUES ('a', 'c', 'b')</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} hash object with key value pairs to use as override values</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the overrides added to the current datasets overrides.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        setOverrides:function (hash) {</code></li>
<li class='green'><span class='hits'>5</span><code>            return this.mergeOptions({overrides:merge({}, this.__opts.overrides || {}, hash)});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with no filters (HAVING or WHERE clause) applied.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").group("a").having({a : 1}).where("b").unfiltered().sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items GROUP BY a</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with no HAVING or WHERE clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        unfiltered:function () {</code></li>
<li class='green'><span class='hits'>14</span><code>            return this.mergeOptions({where:null, having:null});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with no GROUP or HAVING clause.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("t").group("a").having({a : 1}).where("b").ungrouped().sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM t WHERE b</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with no GROUP or HAVING clause.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ungrouped:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.mergeOptions({group:null, having:null});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds a UNION clause using a second dataset object.</code></li>
<li class='green'><span class=''> </span><code>         * A UNION compound dataset returns all rows in either the current dataset</code></li>
<li class='green'><span class=''> </span><code>         * or the given dataset.</code></li>
<li class='green'><span class=''> </span><code>         * Options:</code></li>
<li class='green'><span class=''> </span><code>         * :alias :: Use the given value as the from_self alias</code></li>
<li class='green'><span class=''> </span><code>         * :all :: Set to true to use UNION ALL instead of UNION, so duplicate rows can occur</code></li>
<li class='green'><span class=''> </span><code>         * :from_self :: Set to false to not wrap the returned dataset in a from_self, use with care.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").union(DB.from("otherItems")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items UNION SELECT * FROM other_items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").union(DB.from("otherItems"), {all : true, fromSelf : false}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM items UNION ALL SELECT * FROM other_items</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("items").union(DB.from("otherItems"), {alias : "i"})</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM (SELECT * FROM items UNION SELECT * FROM other_items) AS i</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} dataset dataset to union with</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} opts addional options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifier} [opts.alias] Alias to use as the fromSelf alias.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opt.all=false] Set to true to use UNION ALL instead of UNION so duplicate rows can occur</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.fromSelf=true] Set to false to not wrap the returned dataset in a fromSelf.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the union.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        union:function (dataset, opts) {</code></li>
<li class='green'><span class='hits'>21</span><code>            opts = isUndefined(opts) ? {} : opts;</code></li>
<li class='green'><span class='hits'>21</span><code>            if (!isHash(opts)) {</code></li>
<li class='green'><span class='hits'>3</span><code>                opts = {all:opts};</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>21</span><code>            return this.compoundClone("union", dataset, opts);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with no limit or offset.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("t").limit(10, 20).unlimited().sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM t</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with no limit or offset.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        unlimited:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            return this.mergeOptions({limit:null, offset:null});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with no order.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("t").order("a", sql.identifier("b").desc()).unordered().sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; SELECT * FROM t</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with no order.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        unordered:function () {</code></li>
<li class='green'><span class='hits'>139</span><code>            return this.order(null);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a condition to the WHERE clause.  See {@link patio.Dataset#filter} for argument types.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("test").where('price &lt; ? AND id in ?', 100, [1, 2, 3]).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; "SELECT * FROM test WHERE (price &lt; 100 AND id in (1, 2, 3))"</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("test").where('price &lt; {price} AND id in {ids}', {price:100, ids:[1, 2, 3]}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; "SELECT * FROM test WHERE (price &lt; 100 AND id in (1, 2, 3))")</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        where:function () {</code></li>
<li class='green'><span class='hits'>332</span><code>            return this._filter.apply(this, ["where"].concat(argsToArray(arguments)));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a common table expression (CTE) with the given name and a dataset that defines the CTE.</code></li>
<li class='green'><span class=''> </span><code>         * A common table expression acts as an inline view for the query.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @name with</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("t")["with"]("t", db.from("x"))["with"]("j", db.from("y")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; 'WITH t AS (SELECT * FROM x), j AS (SELECT * FROM y) SELECT * FROM t'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("t")["with"]("t", db.from("x")).withRecursive("j", db.from("y"), db.from("j")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; 'WITH t AS (SELECT * FROM x), j AS (SELECT * FROM y UNION ALL SELECT * FROM j) SELECT * FROM t'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("t")["with"]("t", db.from("x"), {args:["b"]}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *      //=&gt; 'WITH t(b) AS (SELECT * FROM x) SELECT * FROM t'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} name the name of the to assign to the CTE.</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} dataset the dataset to use for the CTE.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} opts extra options.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String[]} [opts.args] colums/args for the CTE.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [opts.recursive] set to true that the CTE is recursive.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the CTE.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        "with":function (name, dataset, opts) {</code></li>
<li class='green'><span class='hits'>6</span><code>            if (!this.supportsCte) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("this dataset does not support common table expressions");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>5</span><code>            return this.mergeOptions({</code></li>
<li class='green'><span class=''> </span><code>                "with":(this.__opts["with"] || []).concat([merge(opts || {}, {name:this.stringToIdentifier(name), dataset:dataset})])</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a recursive common table expression (CTE) with the given name, a dataset that</code></li>
<li class='green'><span class=''> </span><code>         * defines the nonrecursive part of the CTE, and a dataset that defines the recursive part</code></li>
<li class='green'><span class=''> </span><code>         * of the CTE.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //Sing withRecursive call.</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("t").withRecursive("t", db.from("x"), db.from("t")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; 'WITH t AS (SELECT * FROM x UNION ALL SELECT * FROM t) SELECT * FROM t'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //Multiple withRecursive calls.</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("t").withRecursive("t", db.from("x"), db.from("t"))</code></li>
<li class='green'><span class=''> </span><code>         *    .withRecursive("j", db.from("y"), db.from("j")).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; 'WITH t AS (SELECT * FROM x UNION ALL SELECT * FROM t),</code></li>
<li class='green'><span class=''> </span><code>         *                     j AS (SELECT * FROM y UNION ALL SELECT * FROM j) SELECT * FROM t';</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //Adding args</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("t").withRecursive("t", db.from("x"), db.from("t"), {args:["b", "c"]}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; 'WITH t(b, c) AS (SELECT * FROM x UNION ALL SELECT * FROM t) SELECT * FROM t'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //Setting union all to false</code></li>
<li class='green'><span class=''> </span><code>         * DB.from("t").withRecursive("t", db.from("x"), db.from("t"), {unionAll:false}).sql;</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; 'WITH t AS (SELECT * FROM x UNION SELECT * FROM t) SELECT * FROM t');</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} name the name to assign to the CTE</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} nonRecursive the non-recursive part of the CTE</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} recursive the recursive part of the CTE</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts={}] extra options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String[]} [opts.args] columns to include with the CTE</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolena} [opts.unionAll] set to false to use UNION instead of UNION ALL when combining non recursive</code></li>
<li class='green'><span class=''> </span><code>         *                                with recursive.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with the CTE.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        withRecursive:function (name, nonRecursive, recursive, opts) {</code></li>
<li class='green'><span class='hits'>7</span><code>            if (!this.supportsCte) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("This dataset does not support common table expressions");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>6</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>6</span><code>            var wit = (this.__opts["with"] || []).concat([merge(opts, {recursive:true, name:this.stringToIdentifier(name), dataset:nonRecursive.union(recursive, {all:opts.unionAll != false, fromSelf:false})})]);</code></li>
<li class='green'><span class='hits'>6</span><code>            return this.mergeOptions({"with":wit});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a copy of the dataset with the static SQL used.  This is useful if you want</code></li>
<li class='green'><span class=''> </span><code>         * to keep the same {@link patio.Dataset#rowCb}/{@link patio.Dataset#graph},</code></li>
<li class='green'><span class=''> </span><code>         *  but change the SQL used to custom SQL.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  DB.from("items").withSql('SELECT * FROM foo')</code></li>
<li class='green'><span class=''> </span><code>         *          //=&gt; SELECT * FROM foo</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @param {String} sql sql for the dataset to use.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  @return {patio.Dataset} a cloned dataset with the static sql set.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        withSql:function (sql) {</code></li>
<li class='green'><span class='hits'>46</span><code>            var args = argsToArray(arguments).slice(1);</code></li>
<li class='green'><span class='hits'>46</span><code>            if (args.length) {</code></li>
<li class='green'><span class='hits'>23</span><code>                sql = new PlaceHolderLiteralString(sql, args)</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>46</span><code>            return this.mergeOptions({sql:sql});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add the dataset to the list of compounds</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} type the type of compound (i.e. "union", "intersect")</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Dataset} dataset the dataset to add to</code></li>
<li class='green'><span class=''> </span><code>         * @param [Object] [options={}] compound option to use (i.e {all : true})</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} ds with the dataset added to the compounds.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        compoundClone:function (type, dataset, options) {</code></li>
<li class='green'><span class='hits'>51</span><code>            var ds = this._compoundFromSelf().mergeOptions({compounds:(array.toArray(this.__opts.compounds || [])).concat([</code></li>
<li class='green'><span class=''> </span><code>                [type, dataset._compoundFromSelf(), options.all]</code></li>
<li class='green'><span class=''> </span><code>            ])});</code></li>
<li class='green'><span class='hits'>51</span><code>            return options.fromSelf === false ? ds : ds.fromSelf(options);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns the a cloned dataset with out the {@link patio.Dataset#rowCb}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * var ds = DB.from("test");</code></li>
<li class='green'><span class=''> </span><code>         * ds.rowCb = function(r){</code></li>
<li class='green'><span class=''> </span><code>         *     r.a = r.a * 2;</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.all().then(function(ret){</code></li>
<li class='green'><span class=''> </span><code>         *      //ret === [{a : 4}, {a : 6}]</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * ds.naked().all().then(function(ret){</code></li>
<li class='green'><span class=''> </span><code>         *      //ret ===  [{a : 2}, {a : 3}];</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a cloned dataset with out the {@link patio.Dataset#rowCb}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        naked:function () {</code></li>
<li class='green'><span class='hits'>2553</span><code>            var ds = this.mergeOptions({});</code></li>
<li class='green'><span class='hits'>2553</span><code>            ds.rowCb = null;</code></li>
<li class='green'><span class='hits'>2553</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Protected</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Internal filter method so it works on either the having or where clauses.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _filter:function (clause) {</code></li>
<li class='green'><span class='hits'>4205</span><code>            var cond = argsToArray(arguments).slice(1), cb;</code></li>
<li class='green'><span class='hits'>4205</span><code>            if (cond.length &amp;&amp; isFunction(cond[cond.length - 1])) {</code></li>
<li class='green'><span class='hits'>59</span><code>                cb = cond.pop();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4205</span><code>            cond = cond.length == 1 ? cond[0] : cond</code></li>
<li class='green'><span class='hits'>4205</span><code>            if ((cond == null || cond == undefined || cond === "") || (isArray(cond) &amp;&amp; cond.length == 0 &amp;&amp; !cb) || (isObject(cond) &amp;&amp; isEmpty(cond) &amp;&amp; !cb)) {</code></li>
<li class='green'><span class='hits'>382</span><code>                return this.mergeOptions();</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>3823</span><code>                cond = this._filterExpr(cond, cb);</code></li>
<li class='green'><span class='hits'>3820</span><code>                var cl = this.__opts[clause];</code></li>
<li class='green'><span class='hits'>3820</span><code>                cl &amp;&amp; (cond = new BooleanExpression("AND", cl, cond));</code></li>
<li class='green'><span class='hits'>3820</span><code>                var opts = {};</code></li>
<li class='green'><span class='hits'>3820</span><code>                opts[clause] = cond;</code></li>
<li class='green'><span class='hits'>3820</span><code>                return this.mergeOptions(opts);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Splits a possible implicit alias, handling both {@link patio.sql.AliasedExpression}s</code></li>
<li class='green'><span class=''> </span><code>         * and strings.  Returns an array of two elements, with the first being the</code></li>
<li class='green'><span class=''> </span><code>         * main expression, and the second being the alias. Alias may be null if it is a</code></li>
<li class='green'><span class=''> </span><code>         * string that does not contain an alias {table}___{alias}.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _splitAlias:function (c) {</code></li>
<li class='green'><span class='hits'>780</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>780</span><code>            if (isInstanceOf(c, AliasedExpression)) {</code></li>
<li class='green'><span class='hits'>5</span><code>                ret = [c.expression, c.alias];</code></li>
<li class='green'><span class='hits'>775</span><code>            } else if (isString(c)) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                var parts = this._splitString(c), cTable = parts[0], column = parts[1], alias = parts[2];</code></li>
<li class='red'><span class='nohits'>0</span><code>                if (alias) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret = [cTable ? new QualifiedIdentifier(cTable, column) : column, alias];</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                    ret = [c, null];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>775</span><code>                ret = [c, null];</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>780</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Inverts the given order by breaking it into a list of column references</code></li>
<li class='green'><span class=''> </span><code>         * and inverting them.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   ds.invertOrder([sql.identifier("id").desc()]]) //=&gt; [id]</code></li>
<li class='green'><span class=''> </span><code>         *   ds.invertOrder("category", sql.identifier("price").desc()]) #=&gt; [category.desc(), price]</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _invertOrder:function (order) {</code></li>
<li class='green'><span class='hits'>46</span><code>            var ret = order;</code></li>
<li class='green'><span class='hits'>46</span><code>            if (order) {</code></li>
<li class='green'><span class='hits'>45</span><code>                ret = order.map(function (o) {</code></li>
<li class='green'><span class='hits'>57</span><code>                    if (isInstanceOf(o, OrderedExpression)) {</code></li>
<li class='green'><span class='hits'>17</span><code>                        return o.invert();</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>40</span><code>                        return new OrderedExpression(isString(o) ? new Identifier(o) : o);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>46</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Creates a boolean expression that each key is compared to its value using the provided operator.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.__createBoolExpression("gt", {x : 1, y:2, z : 5}) //=&gt; WHERE ((x &gt; 1) AND (y &gt; 2) AND (z &gt; 5))</code></li>
<li class='green'><span class=''> </span><code>         * ds.__createBoolExpression("gt", [[x, 1], [y,2], [z, 5]) //=&gt; WHERE ((x &gt; 1) AND (y &gt; 2) AND (z &gt; 5))</code></li>
<li class='green'><span class=''> </span><code>         * ds.__createBoolExpression("lt", {x : 1, y:2, z : 5}) //=&gt; WHERE ((x &lt; 1) AND (y &lt; 2) AND (z &lt; 5))</code></li>
<li class='green'><span class=''> </span><code>         * ds.__createBoolExpression("lt", [[x, 1], [y,2], [z, 5]) //=&gt; WHERE ((x &lt; 1) AND (y &lt; 2) AND (z &lt; 5))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} op valid boolean expression operator to capare each K,V pair with</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object| Array } obj object or two dimensional array containing key value pairs</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} boolean expression joined by a AND of each key value pair compared by the op</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __createBoolExpression:function (op, obj) {</code></li>
<li class='green'><span class='hits'>32</span><code>            var pairs = [];</code></li>
<li class='green'><span class='hits'>32</span><code>            if (Expression.isConditionSpecifier(obj)) {</code></li>
<li class='green'><span class='hits'>32</span><code>                if (isHash(obj)) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    obj = array.toArray(obj);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>32</span><code>                obj.forEach(function (pair) {</code></li>
<li class='green'><span class='hits'>42</span><code>                    pairs.push(new BooleanExpression(op, new Identifier(pair[0]), pair[1]));</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>32</span><code>            return pairs.length == 1 ? pairs[0] : BooleanExpression.fromArgs(["AND"].concat(pairs));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Creates a boolean expression where the key is '&gt;=' value 1 and '&lt;=' value two.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * ds.__createBetweenExpression({x : [1,2]}) =&gt; //=&gt; WHERE ((x &gt;= 1) AND (x &lt;= 10))</code></li>
<li class='green'><span class=''> </span><code>         * ds.__createBetweenExpression({x : [1,2]}, true) =&gt; //=&gt; WHERE ((x &lt; 1) OR (x &gt; 10))</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} obj object where the keys are columns and the values are two element arrays.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [invert] if set to true it inverts the between to make it not between the two values</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.BooleanExpression} a boolean expression containing the between expression.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __createBetweenExpression:function (obj, invert) {</code></li>
<li class='green'><span class='hits'>4</span><code>            var pairs = [];</code></li>
<li class='green'><span class='hits'>4</span><code>            for (var i in obj) {</code></li>
<li class='green'><span class='hits'>4</span><code>                var v = obj[i];</code></li>
<li class='green'><span class='hits'>4</span><code>                if (isArray(v) &amp;&amp; v.length) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    var ident = this.stringToIdentifier(i);</code></li>
<li class='green'><span class='hits'>2</span><code>                    pairs.push(new BooleanExpression("AND", new BooleanExpression("gte", ident, v[0]), new BooleanExpression("lte", ident, v[1])));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                    throw new QueryError("Between requires an array for the value");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>2</span><code>            var ret = pairs.length == 1 ? pairs[0] : BooleanExpression.fromArgs(["AND"].concat(pairs))</code></li>
<li class='green'><span class='hits'>2</span><code>            return invert ? BooleanExpression.invert(ret) : ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         * Converts an array to a two dimensional array where the first element</code></li>
<li class='green'><span class=''> </span><code>         * is the identifier and the second argument is the value that the value should equal</code></li>
<li class='green'><span class=''> </span><code>         * used by is{Null|NotNull|True|NotTrue|False|notFalse} functions to join all the values passed in.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String[]|patio.sql.Identifier} arr array of elements to make a condition specifier out of</code></li>
<li class='green'><span class=''> </span><code>         * @param defaultOp the value to assign a value if one is not provided.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return { [[]] } an array of two element arrays.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        __arrayToConditionSpecifier:function (arr, defaultOp) {</code></li>
<li class='green'><span class='hits'>22</span><code>            var ret = [];</code></li>
<li class='green'><span class='hits'>22</span><code>            arr.forEach(function (a) {</code></li>
<li class='green'><span class='hits'>28</span><code>                if (isString(a)) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    a = this.stringToIdentifier(a);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>28</span><code>                if (isInstanceOf(a, Identifier)) {</code></li>
<li class='green'><span class='hits'>18</span><code>                    ret.push([a, defaultOp]);</code></li>
<li class='green'><span class='hits'>10</span><code>                } else if (isHash(a)) {</code></li>
<li class='green'><span class='hits'>4</span><code>                    ret = ret.concat(array.toArray(a));</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>6</span><code>                    throw new QueryError("Invalid condition specifier " + a);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>16</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @private</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * SQL expression object based on the expr type.  See {@link patio.Dataset#filter}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        _filterExpr:function (expr, cb) {</code></li>
<li class='green'><span class='hits'>4799</span><code>            expr = (isUndefined(expr) || isNull(expr) || (isArray(expr) &amp;&amp; !expr.length)) ? null : expr;</code></li>
<li class='green'><span class='hits'>4799</span><code>            if (expr &amp;&amp; cb) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return new BooleanExpression("AND", this._filterExpr(expr), this._filterExpr(cb))</code></li>
<li class='green'><span class='hits'>4798</span><code>            } else if (cb) {</code></li>
<li class='green'><span class='hits'>58</span><code>                expr = cb</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4798</span><code>            if (isInstanceOf(expr, Expression)) {</code></li>
<li class='green'><span class='hits'>459</span><code>                if (isInstanceOf(expr, NumericExpression, StringExpression)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    throw new QueryError("Invalid SQL Expression type : " + expr);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>457</span><code>                return expr;</code></li>
<li class='green'><span class='hits'>4339</span><code>            } else if (isArray(expr)) {</code></li>
<li class='green'><span class='hits'>908</span><code>                if (expr.length) {</code></li>
<li class='green'><span class='hits'>908</span><code>                    var first = expr[0];</code></li>
<li class='green'><span class='hits'>908</span><code>                    if (isString(first)) {</code></li>
<li class='green'><span class='hits'>25</span><code>                        return new PlaceHolderLiteralString(first, expr.slice(1), true);</code></li>
<li class='green'><span class='hits'>883</span><code>                    } else if (Expression.isConditionSpecifier(expr)) {</code></li>
<li class='green'><span class='hits'>876</span><code>                        return BooleanExpression.fromValuePairs(expr)</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>7</span><code>                        return BooleanExpression.fromArgs(["AND"].concat(expr.map(function (e) {</code></li>
<li class='green'><span class='hits'>15</span><code>                            return this._filterExpr(e);</code></li>
<li class='green'><span class=''> </span><code>                        }, this)));</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>3431</span><code>            } else if (isFunction(expr)) {</code></li>
<li class='green'><span class='hits'>59</span><code>                return this._filterExpr(expr.call(sql, sql));</code></li>
<li class='green'><span class='hits'>3372</span><code>            } else if (isBoolean(expr)) {</code></li>
<li class='green'><span class='hits'>7</span><code>                return new BooleanExpression("NOOP", expr);</code></li>
<li class='green'><span class='hits'>3365</span><code>            } else if (isString(expr)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this.stringToIdentifier(expr);</code></li>
<li class='green'><span class='hits'>3364</span><code>            } else if (isInstanceOf(expr, LiteralString)) {</code></li>
<li class='green'><span class='hits'>16</span><code>                return new LiteralString("(" + expr + ")");</code></li>
<li class='green'><span class='hits'>3348</span><code>            } else if (isHash(expr)) {</code></li>
<li class='green'><span class='hits'>3347</span><code>                return BooleanExpression.fromValuePairs(expr);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("Invalid filter argument");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * @ignore</code></li>
<li class='green'><span class=''> </span><code>             * Returns true if this dataset is a simple SELECT * FROM {table}, otherwise false.</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            isSimpleSelectAll:function () {</code></li>
<li class='green'><span class='hits'>33</span><code>                var o = {}, opts = this.__opts, count = 0;</code></li>
<li class='green'><span class='hits'>33</span><code>                for (var i in opts) {</code></li>
<li class='green'><span class='hits'>70</span><code>                    if (opts[i] != null &amp;&amp; this._static.NON_SQL_OPTIONS.indexOf(i) == -1) {</code></li>
<li class='green'><span class='hits'>37</span><code>                        o[i] = opts[i];</code></li>
<li class='green'><span class='hits'>37</span><code>                        count++;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>33</span><code>                var f = o.from</code></li>
<li class='green'><span class='hits'>33</span><code>                return count == 1 &amp;&amp; f.length == 1 &amp;&amp; (isString(f[0]) || isInstanceOf(f[0], AliasedExpression, Identifier));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * These strings have {name}Join methods created (e.g. {@link patio.Dataset#innerJoin}) that</code></li>
<li class='green'><span class=''> </span><code>         * call {@link patio.Dataset#joinTable} with the string, passing along the arguments and</code></li>
<li class='green'><span class=''> </span><code>         * block from the method call.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        CONDITIONED_JOIN_TYPES:["inner", "fullOuter", "rightOuter", "leftOuter", "full", "right", "left"],</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * These strings have {name}Join methods created (e.g. naturalJoin) that</code></li>
<li class='green'><span class=''> </span><code>         * call {@link patio.Dataset#joinTable}.  They only accept a single table</code></li>
<li class='green'><span class=''> </span><code>         * argument which is passed to {@link patio.Dataset#joinTable}, and they throw an error</code></li>
<li class='green'><span class=''> </span><code>         * if called with a block.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        UNCONDITIONED_JOIN_TYPES:["natural", "naturalLeft", "naturalRight", "naturalFull", "cross"],</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  The dataset options that require the removal of cached columns</code></li>
<li class='green'><span class=''> </span><code>         *  if changed.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        COLUMN_CHANGE_OPTS:["select", "sql", "from", "join"],</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Which options don't affect the SQL generation.  Used by {@link patio.Dataset#simpleSelectAll}</code></li>
<li class='green'><span class=''> </span><code>         * to determine if this is a simple SELECT * FROM table.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        NON_SQL_OPTIONS:["server", "defaults", "overrides", "graph", "eagerGraph", "graphAliases"],</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *  All methods that return modified datasets with a joined table added.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        JOIN_METHODS:["join", "joinTable"],</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Methods that return modified datasets</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        QUERY_METHODS:['addGraphAliases', "and", "distinct", "except", "exclude", "filter", "find", "is", "isNot",</code></li>
<li class='green'><span class=''> </span><code>            "eq", "neq", "lt", "lte", "gt", "gte", "forUpdate", "from", "fromSelf", "graph", "grep", "group",</code></li>
<li class='green'><span class=''> </span><code>            "groupAndCount", "groupBy", "having", "intersect", "invert", "limit", "lockStyle", "naked", "or", "order",</code></li>
<li class='green'><span class=''> </span><code>            "orderAppend", "orderBy", "orderMore", "orderPrepend", "qualify", "reverse",</code></li>
<li class='green'><span class=''> </span><code>            "reverseOrder", "select", "selectAll", "selectAppend", "selectMore", "setDefaults",</code></li>
<li class='green'><span class=''> </span><code>            "setGraphAliases", "setOverrides", "unfiltered", "ungraphed", "ungrouped", "union", "unlimited",</code></li>
<li class='green'><span class=''> </span><code>            "unordered", "where", "with", "withRecursive", "withSql"],</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        init:function () {</code></li>
<li class='green'><span class='hits'>35</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            //initialize our join methods array</code></li>
<li class='green'><span class='hits'>35</span><code>            var joinMethods = this.JOIN_METHODS;</code></li>
<li class='green'><span class='hits'>35</span><code>            var queryMethods = this.QUERY_METHODS;</code></li>
<li class='green'><span class='hits'>35</span><code>            this.UNCONDITIONED_JOIN_TYPES.forEach(function (joinType) {</code></li>
<li class='green'><span class='hits'>175</span><code>                var m = joinType + "Join";</code></li>
<li class='green'><span class='hits'>175</span><code>                joinMethods.push(m);</code></li>
<li class='green'><span class='hits'>175</span><code>                queryMethods.push(m);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>35</span><code>            this.CONDITIONED_JOIN_TYPES.forEach(function (joinType) {</code></li>
<li class='green'><span class='hits'>245</span><code>                var m = joinType + "Join";</code></li>
<li class='green'><span class='hits'>245</span><code>                joinMethods.push(m);</code></li>
<li class='green'><span class='hits'>245</span><code>                queryMethods.push(m);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>35</span><code>            this.QUERY_METHODS = queryMethods.concat(joinMethods);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).</code></li>
<li class='green'><span class=''> </span><code>    as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="database/logging.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/logging.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>97.96</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>193</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>49</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>1</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/logging.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    logging = comb.logging,</code></li>
<li class='green'><span class=''> </span><code>    Logger = logging.Logger,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    format = comb.string.format,</code></li>
<li class='green'><span class=''> </span><code>    QueryError = require("../errors").QueryError;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var LOGGER = Logger.getLogger("patio.Database");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs an INFO level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logInfo:function () {</code></li>
<li class='green'><span class='hits'>8349</span><code>            if (LOGGER.isInfo) {</code></li>
<li class='green'><span class='hits'>8349</span><code>                LOGGER.info.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a DEBUG level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logDebug:function () {</code></li>
<li class='green'><span class='hits'>8054</span><code>            if (LOGGER.isDebug) {</code></li>
<li class='green'><span class='hits'>8054</span><code>                LOGGER.debug.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs an ERROR level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logError:function (error) {</code></li>
<li class='green'><span class='hits'>76</span><code>            if (LOGGER.isError) {</code></li>
<li class='green'><span class='hits'>76</span><code>                LOGGER.error.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a WARN level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logWarn:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isWarn) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.warn.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a TRACE level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logTrace:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isTrace) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.trace.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a FATAL level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logFatal:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isFatal) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.fatal.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /* Yield to the block, logging any errors at error level to all loggers,</code></li>
<li class='green'><span class=''> </span><code>         * and all other queries with the duration at warn or info level.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __logAndExecute:function (sql, args, cb) {</code></li>
<li class='green'><span class='hits'>8129</span><code>            if (isFunction(args)) {</code></li>
<li class='green'><span class='hits'>8128</span><code>                cb = args;</code></li>
<li class='green'><span class='hits'>8128</span><code>                args = null;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>8129</span><code>            if (args) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                sql = format("%s; %j", sql, args);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>8129</span><code>            sql = sql.trim();</code></li>
<li class='green'><span class='hits'>8129</span><code>            var start = new Date();</code></li>
<li class='green'><span class='hits'>8129</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>8129</span><code>            if (isFunction(cb)) {</code></li>
<li class='green'><span class='hits'>8128</span><code>                this.logInfo("Executing; %s", sql);</code></li>
<li class='green'><span class='hits'>8128</span><code>                cb().then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>8053</span><code>                    this.logDebug("Duration: % 6dms; %s", new Date() - start, sql);</code></li>
<li class='green'><span class='hits'>8053</span><code>                    ret.callback.apply(ret, arguments);</code></li>
<li class='green'><span class=''> </span><code>                }), hitch(this, function (err) {</code></li>
<li class='green'><span class='hits'>75</span><code>                    err = new QueryError(format("%s: %s", err.message, sql));</code></li>
<li class='green'><span class='hits'>75</span><code>                    this.logError(err);</code></li>
<li class='green'><span class='hits'>75</span><code>                    ret.errback.apply(ret, [err]);</code></li>
<li class='green'><span class=''> </span><code>                }));</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("CB is required");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>8128</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /*Log the given SQL and then execute it on the connection, used by</code></li>
<li class='green'><span class=''> </span><code>         *the transaction code.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        __logConnectionExecute:function (conn, sql) {</code></li>
<li class='green'><span class='hits'>2091</span><code>            return this.__logAndExecute(sql, hitch(this, function () {</code></li>
<li class='green'><span class='hits'>2091</span><code>                return conn[this.connectionExecuteMethod](sql);</code></li>
<li class='green'><span class=''> </span><code>            }));</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            logger:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>                return LOGGER;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database*/</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs an INFO level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logInfo:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isInfo) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.info.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a DEBUG level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logDebug:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isDebug) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.debug.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a ERROR level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logError:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isError) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.error.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a WARN level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logWarn:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isWarn) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.warn.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a TRACE level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logTrace:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isTrace) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.trace.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Logs a FATAL level message to the "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        logFatal:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            if (LOGGER.isFatal) {</code></li>
<li class='green'><span class='hits'>1</span><code>                LOGGER.fatal.apply(LOGGER, arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Database*/</code></li>
<li class='green'><span class=''> </span><code>            /**</code></li>
<li class='green'><span class=''> </span><code>             * The "patio.Database" logger.</code></li>
<li class='green'><span class=''> </span><code>             * @field</code></li>
<li class='green'><span class=''> </span><code>             */</code></li>
<li class='green'><span class=''> </span><code>            logger:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                return LOGGER;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="plugins/inheritance.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/inheritance.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>98.96</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>301</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>96</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>1</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/inheritance.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>comb.define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{},</code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        configure:function (model) {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "SingleTableInheritance");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This plugin enables</code></li>
<li class='green'><span class=''> </span><code> * &lt;a href="http://www.martinfowler.com/eaaCatalog/classTableInheritance.html" target="patioapi"&gt;</code></li>
<li class='green'><span class=''> </span><code> *     class table inheritance</code></li>
<li class='green'><span class=''> </span><code> * &lt;/a&gt;.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *&lt;div&gt;</code></li>
<li class='green'><span class=''> </span><code> *     Consider the following table model.</code></li>
<li class='green'><span class=''> </span><code> * @code</code></li>
<li class='green'><span class=''> </span><code> *          employee</code></li>
<li class='green'><span class=''> </span><code> *            - id</code></li>
<li class='green'><span class=''> </span><code> *            - name (varchar)</code></li>
<li class='green'><span class=''> </span><code> *            - kind (varchar)</code></li>
<li class='green'><span class=''> </span><code> *     /                          \</code></li>
<li class='green'><span class=''> </span><code> * staff                        manager</code></li>
<li class='green'><span class=''> </span><code> *   - id (fk employee)           - id (fk employee)</code></li>
<li class='green'><span class=''> </span><code> *   - manager_id (fk manger)     - numStaff (number)</code></li>
<li class='green'><span class=''> </span><code> *                                 |</code></li>
<li class='green'><span class=''> </span><code> *                              executive</code></li>
<li class='green'><span class=''> </span><code> *                                - id (fk manager)</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *  &lt;ul&gt;</code></li>
<li class='green'><span class=''> </span><code> *      &lt;li&gt;&lt;b&gt;employee&lt;/b&gt;: This is the parent table of all employee instances.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *      &lt;li&gt;&lt;b&gt;staff&lt;/b&gt;: Table that inherits from employee where and represents.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *      &lt;li&gt;&lt;b&gt;manager&lt;/b&gt;: Another subclass of employee.&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *      &lt;li&gt;&lt;b&gt;executive&lt;/b&gt;: Subclass of manager that also inherits from employee through inhertiance&lt;/li&gt;</code></li>
<li class='green'><span class=''> </span><code> *  &lt;/ul&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code> * When setting up you tables the parent table should contain a String column that contains the "kind" of class it is.</code></li>
<li class='green'><span class=''> </span><code> * (i.e. employee, staff, manager, executive). This allows the plugin to return the proper instance type when querying</code></li>
<li class='green'><span class=''> </span><code> * the tables.</code></li>
<li class='green'><span class=''> </span><code> * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;p&gt;</code></li>
<li class='green'><span class=''> </span><code> *     All other tables that inherit from employee should contain a foreign key to their direct super class that is the</code></li>
<li class='green'><span class=''> </span><code> *     same name as the primary key of the parent table(&lt;b&gt;employee&lt;/b&gt;). So, in the</code></li>
<li class='green'><span class=''> </span><code> *     above example &lt;b&gt;staff&lt;/b&gt; and &lt;b&gt;manager&lt;/b&gt; both contain foreign keys to employee and &lt;b&gt;executive&lt;/b&gt; contains</code></li>
<li class='green'><span class=''> </span><code> *     a foreign key to &lt;b&gt;manager&lt;/b&gt; and they are all named &lt;b&gt;id&lt;/b&gt;.</code></li>
<li class='green'><span class=''> </span><code> * &lt;/p&gt;</code></li>
<li class='green'><span class=''> </span><code> *&lt;/div&gt;</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * To set up you models the base super class should contain the ClassTableInheritancePlugin</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * {@code</code></li>
<li class='green'><span class=''> </span><code> * var Employee = (exports.Employee = patio.addModel("employee", {</code></li>
<li class='green'><span class=''> </span><code> *      plugins : [patio.plugins.ClassTableInheritancePlugin],</code></li>
<li class='green'><span class=''> </span><code> *      static:{</code></li>
<li class='green'><span class=''> </span><code> *          init:function () {</code></li>
<li class='green'><span class=''> </span><code> *              this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code> *              this.configure({key : "kind"});</code></li>
<li class='green'><span class=''> </span><code> *          }</code></li>
<li class='green'><span class=''> </span><code> *      }</code></li>
<li class='green'><span class=''> </span><code> *  }));</code></li>
<li class='green'><span class=''> </span><code> * }</code></li>
<li class='green'><span class=''> </span><code> * All sub classes should just inherit their super class</code></li>
<li class='green'><span class=''> </span><code> * {@code</code></li>
<li class='green'><span class=''> </span><code> * var Staff = (exports.Staff =  patio.addModel("staff", Employee, {</code></li>
<li class='green'><span class=''> </span><code> *      static:{</code></li>
<li class='green'><span class=''> </span><code> *          init:function () {</code></li>
<li class='green'><span class=''> </span><code> *              this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code> *              this.manyToOne("manager", {key : "managerId", fetchType : this.fetchType.EAGER});</code></li>
<li class='green'><span class=''> </span><code> *          }</code></li>
<li class='green'><span class=''> </span><code> *      }</code></li>
<li class='green'><span class=''> </span><code> * }));</code></li>
<li class='green'><span class=''> </span><code> * var Manager = (exports.Manager = patio.addModel("manager", Employee, {</code></li>
<li class='green'><span class=''> </span><code> *      static:{</code></li>
<li class='green'><span class=''> </span><code> *          init:function () {</code></li>
<li class='green'><span class=''> </span><code> *              this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code> *              this.oneToMany("staff", {key : "managerId", fetchType : this.fetchType.EAGER});</code></li>
<li class='green'><span class=''> </span><code> *          }</code></li>
<li class='green'><span class=''> </span><code> *      }</code></li>
<li class='green'><span class=''> </span><code> * }));</code></li>
<li class='green'><span class=''> </span><code> * }</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Executive inherits from manager, and through inheritance will also receive the oneToMany relationship with staff</code></li>
<li class='green'><span class=''> </span><code> * {@code</code></li>
<li class='green'><span class=''> </span><code> * var Executive = (exports.Executive = patio.addModel("executive",  Manager));</code></li>
<li class='green'><span class=''> </span><code> * }</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * Working with models</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * {@code</code></li>
<li class='green'><span class=''> </span><code> * comb.when(</code></li>
<li class='green'><span class=''> </span><code> *     new Employee({name:"Bob"}).save(),</code></li>
<li class='green'><span class=''> </span><code> *     new Staff({name:"Greg"}).save(),</code></li>
<li class='green'><span class=''> </span><code> *     new Manager({name:"Jane"}).save(),</code></li>
<li class='green'><span class=''> </span><code> *     new Executive({name:"Sue"}).save()</code></li>
<li class='green'><span class=''> </span><code> * ).then(function(){</code></li>
<li class='green'><span class=''> </span><code> *      Employee.all().then(function(emps){</code></li>
<li class='green'><span class=''> </span><code> *          var bob = emps[0], greg = emps[1], jane = emps[2], sue = emps[3];</code></li>
<li class='green'><span class=''> </span><code> *          console.log(bob instanceof Employee); //true</code></li>
<li class='green'><span class=''> </span><code> *          console.log(greg instanceof Employee);  //true</code></li>
<li class='green'><span class=''> </span><code> *          console.log(greg instanceof Staff);  //true</code></li>
<li class='green'><span class=''> </span><code> *          console.log(jane instanceof Employee);  //true</code></li>
<li class='green'><span class=''> </span><code> *          console.log(jane instanceof Manager);  //true</code></li>
<li class='green'><span class=''> </span><code> *          console.log(sue instanceof Employee);  //true</code></li>
<li class='green'><span class=''> </span><code> *          console.log(sue instanceof Manager);  //true</code></li>
<li class='green'><span class=''> </span><code> *          console.log(sue instanceof Executive);  //true</code></li>
<li class='green'><span class=''> </span><code> *      });</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> * }</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name ClassTableInheritancePlugin</code></li>
<li class='green'><span class=''> </span><code> * @memberof patio.plugins</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>comb.define(null, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Delete the row from all backing tables, starting from the</code></li>
<li class='green'><span class=''> </span><code>        // most recent table and going through all superclasses.</code></li>
<li class='green'><span class=''> </span><code>        _remove:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            var q = this._getPrimaryKeyQuery();</code></li>
<li class='green'><span class='hits'>6</span><code>            return new PromiseList(this._static.__ctiTables.slice().reverse().map(function (table) {</code></li>
<li class='green'><span class='hits'>12</span><code>                return this.db.from(table).filter(q).remove();</code></li>
<li class='green'><span class=''> </span><code>            }, this), true).promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // Save each column according to the columns in each table</code></li>
<li class='green'><span class=''> </span><code>        _save:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            var thisStatic = this._static;</code></li>
<li class='green'><span class='hits'>6</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>6</span><code>            if (thisStatic === this._static.__ctiBaseModel) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>5</span><code>                var q = this._getPrimaryKeyQuery(), pk = this.primaryKey[0];</code></li>
<li class='green'><span class='hits'>5</span><code>                var tables = thisStatic.__ctiTables, ctiColumns = thisStatic.__ctiColumns;</code></li>
<li class='green'><span class='hits'>5</span><code>                var insertTable = comb.hitch(this, function (index) {</code></li>
<li class='green'><span class='hits'>16</span><code>                    if (index &lt; tables.length) {</code></li>
<li class='green'><span class='hits'>11</span><code>                        var table = tables[index];</code></li>
<li class='green'><span class='hits'>11</span><code>                        var isRestricted = this._static.isRestrictedPrimaryKey;</code></li>
<li class='green'><span class='hits'>11</span><code>                        var cols = ctiColumns[table], insert = {};</code></li>
<li class='green'><span class='hits'>11</span><code>                        cols.forEach(function (c) {</code></li>
<li class='green'><span class='hits'>27</span><code>                            var val;</code></li>
<li class='green'><span class='hits'>27</span><code>                            if ((index !== 0 || (index == 0 &amp;&amp; (!isRestricted || pk.indexOf(c) == -1))) &amp;&amp; !comb.isUndefined(val = this[c])) {</code></li>
<li class='green'><span class='hits'>18</span><code>                                insert[c] = val;</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        }, this);</code></li>
<li class='green'><span class='hits'>11</span><code>                        this.db.from(table).insert(insert).then(comb.hitch(this, function (id) {</code></li>
<li class='green'><span class='hits'>11</span><code>                            if (comb.isUndefined(this.primaryKeyValue) &amp;&amp; !comb.isUndefined(id) &amp;&amp; index == 0) {</code></li>
<li class='green'><span class='hits'>5</span><code>                                this.__ignore = true;</code></li>
<li class='green'><span class=''> </span><code>                                //how to handle composite keys.</code></li>
<li class='green'><span class='hits'>5</span><code>                                this[pk] = id;</code></li>
<li class='green'><span class='hits'>5</span><code>                                this.__ignore = false;</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class='hits'>11</span><code>                            insertTable(++index);</code></li>
<li class='green'><span class=''> </span><code>                        }), ret);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>5</span><code>                        this.__isNew = false;</code></li>
<li class='green'><span class='hits'>5</span><code>                        this.__isChanged = false;</code></li>
<li class='green'><span class='hits'>5</span><code>                        this._saveReload().then(comb.hitch(this, function () {</code></li>
<li class='green'><span class='hits'>5</span><code>                            ret.callback(this);</code></li>
<li class='green'><span class=''> </span><code>                        }), ret);</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>5</span><code>                insertTable(0);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>5</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        // update each column according to the columns in each table</code></li>
<li class='green'><span class=''> </span><code>        _update:function () {</code></li>
<li class='green'><span class='hits'>4</span><code>            var q = this._getPrimaryKeyQuery(), changed = this.__changed;</code></li>
<li class='green'><span class='hits'>4</span><code>            var ret = new Promise(),</code></li>
<li class='green'><span class=''> </span><code>                modelStatic = this._static,</code></li>
<li class='green'><span class=''> </span><code>                ctiColumns = modelStatic.__ctiColumns,</code></li>
<li class='green'><span class=''> </span><code>                tables = modelStatic.__ctiTables;</code></li>
<li class='green'><span class='hits'>4</span><code>            return new PromiseList(tables.map(function (table) {</code></li>
<li class='green'><span class='hits'>9</span><code>                var cols = ctiColumns[table], update = {};</code></li>
<li class='green'><span class='hits'>9</span><code>                cols.forEach(function (c) {</code></li>
<li class='green'><span class='hits'>22</span><code>                    if (!comb.isUndefined(changed[c])) {</code></li>
<li class='green'><span class='hits'>7</span><code>                        update[c] = changed[c];</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                }, this);</code></li>
<li class='green'><span class='hits'>9</span><code>                return comb.isEmpty(update) ? new Promise().callback() : this.db.from(table).filter(q).update(update);</code></li>
<li class='green'><span class=''> </span><code>            }, this), true)</code></li>
<li class='green'><span class=''> </span><code>                .chain(comb.hitch(this, "_updateReload"))</code></li>
<li class='green'><span class=''> </span><code>                .promise();</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.plugins.ClassTableInheritancePlugin*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Configures the plugins with the provided options. &lt;b&gt;Note:&lt;/b&gt; This should only be called in the</code></li>
<li class='green'><span class=''> </span><code>         * initial parent class.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts] Additional options to configure behavior of the plugin</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.key="key"] the column in the base table that contains the name of the subclass.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Funciton} [opts.keyCb] A callback to invoke on on the key returned from the database. This is useful</code></li>
<li class='green'><span class=''> </span><code>         * if you are working with other orms that save the keys differently.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        configure:function (opts) {</code></li>
<li class='green'><span class='hits'>4</span><code>            this.__configureOpts = opts;</code></li>
<li class='green'><span class='hits'>4</span><code>            return this;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        sync:function (cb) {</code></li>
<li class='green'><span class='hits'>57</span><code>            var ret = new Promise(), opts = this.__configureOpts;</code></li>
<li class='green'><span class='hits'>57</span><code>            if (this.__configureOpts &amp;&amp; !this.__configured) {</code></li>
<li class='green'><span class='hits'>1</span><code>                this._super().then(hitch(this, function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                    if (!this.__configured) {</code></li>
<li class='green'><span class='hits'>1</span><code>                        var baseModel = this.__ctiBaseModel = this;</code></li>
<li class='green'><span class='hits'>1</span><code>                        var key = this.__ctiKey = opts.key || "key";</code></li>
<li class='green'><span class='hits'>1</span><code>                        var keyCallback = opts.keyCb || function (k) {</code></li>
<li class='green'><span class='hits'>26</span><code>                            return k;</code></li>
<li class='green'><span class=''> </span><code>                        };</code></li>
<li class='green'><span class='hits'>1</span><code>                        this.__ctiModels = [this];</code></li>
<li class='green'><span class='hits'>1</span><code>                        this.__ctiTables = [this.tableName];</code></li>
<li class='green'><span class='hits'>1</span><code>                        var cols = this.__ctiColumns = {};</code></li>
<li class='green'><span class='hits'>1</span><code>                        cols[this.tableName] = this.columns;</code></li>
<li class='green'><span class='hits'>1</span><code>                        this.dataset.rowCb = comb.hitch(this, function (r) {</code></li>
<li class='green'><span class='hits'>26</span><code>                            if (key) {</code></li>
<li class='green'><span class='hits'>26</span><code>                                var model = this.patio.getModel(keyCallback(r[key]));</code></li>
<li class='green'><span class='hits'>26</span><code>                                if (model !== baseModel) {</code></li>
<li class='green'><span class='hits'>23</span><code>                                    var q = {};</code></li>
<li class='green'><span class='hits'>23</span><code>                                    model.primaryKey.forEach(function (k) {</code></li>
<li class='green'><span class='hits'>23</span><code>                                        q[k] = r[k];</code></li>
<li class='green'><span class=''> </span><code>                                    }, this);</code></li>
<li class='green'><span class='hits'>23</span><code>                                    return model.dataset.naked().filter(q).one().chain(model.load.bind(model));</code></li>
<li class='green'><span class=''> </span><code>                                } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                                    return this.load(r);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            } else {</code></li>
<li class='red'><span class='nohits'>0</span><code>                                return this.load(r);</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class='hits'>1</span><code>                        this.pre("save", function (next) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            if (key) {</code></li>
<li class='green'><span class='hits'>1</span><code>                                this[key] = this.tableName.toString();</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class='hits'>1</span><code>                            next();</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class='hits'>1</span><code>                        this.__configured = true;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class='hits'>1</span><code>                    ret.callback(this);</code></li>
<li class='green'><span class=''> </span><code>                }), ret);</code></li>
<li class='green'><span class='hits'>1</span><code>                ret.classic(cb);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>56</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>1</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;Not typically called by user code&lt;/b&gt;. Sets up subclass inheritance.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {patio.Model} model model that this class is inheriting from.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        inherits:function (model) {</code></li>
<li class='green'><span class='hits'>3</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>3</span><code>            var ctiKey = this.__ctiKey = model.__ctiKey;</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__ctiTables = model.__ctiTables.slice();</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__ctiModels = model.__ctiModels.slice();</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__ctiModels.push(this);</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__ctiTables.push(this.tableName);</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__ctiColumns = comb.merge({}, model.__ctiColumns);</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__ctiColumns[this.tableName] = this.columns;</code></li>
<li class='green'><span class='hits'>3</span><code>            this.__ctiBaseModel = model.__ctiBaseModel;</code></li>
<li class='green'><span class=''> </span><code>            //copy over our schema</code></li>
<li class='green'><span class='hits'>3</span><code>            var newSchema = comb.merge({}, this.__schema);</code></li>
<li class='green'><span class='hits'>3</span><code>            var schemas = model.__ctiModels.map(</code></li>
<li class='green'><span class=''> </span><code>                function (m) {</code></li>
<li class='green'><span class='hits'>4</span><code>                    return m.schema;</code></li>
<li class='green'><span class=''> </span><code>                }).reverse();</code></li>
<li class='green'><span class='hits'>3</span><code>            schemas.forEach(function (s) {</code></li>
<li class='green'><span class='hits'>4</span><code>                for (var i in s) {</code></li>
<li class='green'><span class='hits'>13</span><code>                    newSchema[i] = s[i];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }, this);</code></li>
<li class='green'><span class='hits'>3</span><code>            this._setSchema(newSchema);</code></li>
<li class='green'><span class='hits'>3</span><code>            this._setDataset(model.dataset.join(this.tableName, this.primaryKey));</code></li>
<li class='green'><span class='hits'>3</span><code>            this._setPrimaryKey(this.__ctiBaseModel.primaryKey);</code></li>
<li class='green'><span class='hits'>3</span><code>            this.pre("save", function (next) {</code></li>
<li class='green'><span class='hits'>5</span><code>                if (ctiKey) {</code></li>
<li class='green'><span class='hits'>5</span><code>                    this[ctiKey] = this.tableName.toString();</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>5</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(exports, "ClassTableInheritance");</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-high" id="dataset/graph.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>dataset/graph.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>99.19</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>402</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>124</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>1</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="dataset/graph.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    string = comb.string,</code></li>
<li class='green'><span class=''> </span><code>    format = string.format,</code></li>
<li class='green'><span class=''> </span><code>    SQL = require("../sql"),</code></li>
<li class='green'><span class=''> </span><code>    sql = SQL.sql,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    isArray = comb.isArray,</code></li>
<li class='green'><span class=''> </span><code>    isObject = comb.isObject,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    isEmpty = comb.isEmpty,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    toArray = comb.array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("../errors"),</code></li>
<li class='green'><span class=''> </span><code>    QueryError = errors.QueryError;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/*</code></li>
<li class='green'><span class=''> </span><code> * This file contains dataset graphing related features. All methods return</code></li>
<li class='green'><span class=''> </span><code> * a copy of the dataset.</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//leave for later initialization</code></li>
<li class='green'><span class='hits'>1</span><code>var Dataset;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>//checks for a table alies if there isnt one throw an error.</code></li>
<li class='green'><span class='hits'>1</span><code>var raiseAliasError = function (options) {</code></li>
<li class='green'><span class='hits'>2</span><code>    var isAlias = isUndefinedOrNull(options.tableAlias);</code></li>
<li class='green'><span class='hits'>2</span><code>    throw new QueryError(format("this %s has already been used, please specify %s", isAlias ? "alias" : "table", isAlias ? "a different alias" : "an alias in options"));</code></li>
<li class='green'><span class=''> </span><code>};</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @lends patio.Dataset.prototype</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @ignore</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>28667</span><code>            !Dataset &amp;&amp; (Dataset = require("../index").Dataset);</code></li>
<li class='green'><span class='hits'>28667</span><code>            this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds the given graph aliases to the list of graph aliases to use,</code></li>
<li class='green'><span class=''> </span><code>         * unlike {@link patio.Dataset#setGraphAliases}, which replaces the list (the equivalent</code></li>
<li class='green'><span class=''> </span><code>         * of {@link patio.Dataset#selectMore} when graphing).  See {@link patio.Dataset#setGraphAliases}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *  var DB = patio.defaultDatabase;</code></li>
<li class='green'><span class=''> </span><code>         *  // SELECT ..., table.column AS someAlias</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("table").addGraphAliases({someAlias : ["table", "column"]);</code></li>
<li class='green'><span class=''> </span><code>         *   //returns from graphing</code></li>
<li class='green'><span class=''> </span><code>         *   // =&gt; {table : {column : someAlias_value, ...}, ...}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   @param {Object} graphAliases the graph aliases to use.</code></li>
<li class='green'><span class=''> </span><code>         *          Where key is the alias name and the value is an array where arr[0] = 'tableName' arr[1] = "colName'.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   @return {patio.Dataset} deep copy of the original dataset with the added graphAliases.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        addGraphAliases:function (graphAliases) {</code></li>
<li class='green'><span class='hits'>3</span><code>            var ds = this.selectMore.apply(this, this.__graphAliasColumns(graphAliases));</code></li>
<li class='green'><span class='hits'>3</span><code>            ds.__opts.graphAliases = merge((ds.__opts.graphAliases || (ds.__opts.graph ? ds.__opts.graph.columnAliases : {}) || {}), graphAliases);</code></li>
<li class='green'><span class='hits'>3</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Allows you to join multiple datasets/tables and have the result set</code></li>
<li class='green'><span class=''> </span><code>         * split into component tables.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * This differs from the usual usage of join, which returns the result set</code></li>
<li class='green'><span class=''> </span><code>         * as a single hash.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //CREATE TABLE artists (id INTEGER, name TEXT);</code></li>
<li class='green'><span class=''> </span><code>         * //CREATE TABLE albums (id INTEGER, name TEXT, artist_id INTEGER);</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var DB = patio.defaultDatabase, ds = db.from("artists");</code></li>
<li class='green'><span class=''> </span><code>         * ds.leftOuterJoin("albums", {artistId : "id"}).first</code></li>
<li class='green'><span class=''> </span><code>         *   //=&gt; {id : albums.id, name : albums.name, artist_id : albums.artist_id}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var p = comb.executeInOrder(ds, function(ds){</code></li>
<li class='green'><span class=''> </span><code>         *   var graphedDs = ds.graph("albums", {artist_id : "id"});</code></li>
<li class='green'><span class=''> </span><code>         *   return graphedDs.first();</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * p.then(function(obj){</code></li>
<li class='green'><span class=''> </span><code>         *    //obj == {artists : {</code></li>
<li class='green'><span class=''> </span><code>         *                  id : artists.id,</code></li>
<li class='green'><span class=''> </span><code>         *                  name : artists.name</code></li>
<li class='green'><span class=''> </span><code>         *                  },</code></li>
<li class='green'><span class=''> </span><code>         *             albums : {</code></li>
<li class='green'><span class=''> </span><code>         *                  id : albums.id,</code></li>
<li class='green'><span class=''> </span><code>         *                  name : albums.name,</code></li>
<li class='green'><span class=''> </span><code>         *                  artist_id=&gt;albums.artist_id</code></li>
<li class='green'><span class=''> </span><code>         *                  }</code></li>
<li class='green'><span class=''> </span><code>         *             }</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * Using a join such as leftOuterJoin, the attribute names that are shared between</code></li>
<li class='green'><span class=''> </span><code>         * the tables are combined in the single return hash.  You can get around that by</code></li>
<li class='green'><span class=''> </span><code>         * using {@link patio.Dataset#select} with correct aliases for all of the columns, but it is simpler to</code></li>
<li class='green'><span class=''> </span><code>         * use {@link patio.Dataset#graph} and have the result set split for you.  In addition, {@link patio.Dataset#graph} respects</code></li>
<li class='green'><span class=''> </span><code>         * any {@link patio.Dataset#rowCb} of the current dataset and the datasets you use with {@link patio.Dataset#graph}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If you are graphing a table and all columns for that table are null, this</code></li>
<li class='green'><span class=''> </span><code>         * indicates that no matching rows existed in the table, so graph will return null.</code></li>
<li class='green'><span class=''> </span><code>         * instead of a hash with all nil values:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   // Psuedo code there will be promises returned</code></li>
<li class='green'><span class=''> </span><code>         *   /// If the artist doesn't have any albums</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *   var DB = patio.defaultDatabase, ds = db.from("artists");</code></li>
<li class='green'><span class=''> </span><code>         *   var obj = ds.graph(:albums, :artist_id=&gt;:id).first()</code></li>
<li class='green'><span class=''> </span><code>         *   //obj == { artists : {id : artists.id, name : artists.name}, albums : null};</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @parameter {String|patio.Dataset|Object} dataset This can be a string (representing a table), another {@link patio.Dataset},</code></li>
<li class='green'><span class=''> </span><code>         *            or an object that has a dataset property that returns a string or dataset.</code></li>
<li class='green'><span class=''> </span><code>         * @parameter joinConditions Any condition(s) allowed by {@link patio.Dataset#joinTable}.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @parameter {Object} [options] options to use when creating the graph</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @parameter {String|sql.LiteralString|sql.Identifier} [options.fromSelfAlias] The alias to use when the</code></li>
<li class='green'><span class=''> </span><code>         *                      receiver is not a graphed dataset but it contains multiple FROM tables or a JOIN.</code></li>
<li class='green'><span class=''> </span><code>         *                      In this case, the receiver is wrapped in a {@link patio.Dataset#fromSelf} before graphing,</code></li>
<li class='green'><span class=''> </span><code>         *                      and this option determines the alias to use.</code></li>
<li class='green'><span class=''> </span><code>         * @parameter {String|sql.LiteralString|sql.Identifier} [options.implicitQualifier] The qualifier of implicit conditions,</code></li>
<li class='green'><span class=''> </span><code>         *              see {@link patio.Dataset#joinTable}.</code></li>
<li class='green'><span class=''> </span><code>         * @parameter [String] [options.joinType="leftOuter"] The type of join to use (passed to {@link patio.Dataset#joinTable}.).</code></li>
<li class='green'><span class=''> </span><code>         * @parameter [String[]|sql.LiteralString[]|sql.Identifier[]|Boolean] [options.select] An array of columns to select.  When not used, selects</code></li>
<li class='green'><span class=''> </span><code>         *            all columns in the given dataset.  When set to false, selects no</code></li>
<li class='green'><span class=''> </span><code>         *            columns and is like simply joining the tables, though graph keeps</code></li>
<li class='green'><span class=''> </span><code>         *            some metadata about the join that makes it important to use {@link patio.Dataset#graph} instead</code></li>
<li class='green'><span class=''> </span><code>         *            of {@link patio.Dataset#joinTable}</code></li>
<li class='green'><span class=''> </span><code>         * @parameter {String|sql.LiteralString|sql.Identifier} [options.tableAlias] The alias to use for the table.  If not specified, doesn't</code></li>
<li class='green'><span class=''> </span><code>         *                 alias the table.  You will get an error if the the alias (or table) name is</code></li>
<li class='green'><span class=''> </span><code>         *                 used more than once.</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>         * @parameter {Function} block  A function that is passed to {@link patio.Dataset#joinTable}.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        graph:function (dataset, joinConditions, options, block) {</code></li>
<li class='green'><span class='hits'>52</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>52</span><code>            var args = argsToArray(arguments, 1);</code></li>
<li class='green'><span class='hits'>52</span><code>            block = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='green'><span class='hits'>52</span><code>            joinConditions = args.shift() || null;</code></li>
<li class='green'><span class='hits'>52</span><code>            options = args.shift() || {};</code></li>
<li class='green'><span class=''> </span><code>            // Allow the use of a model, dataset, or string as the first argument</code></li>
<li class='green'><span class=''> </span><code>            // Find the table name/dataset based on the argument</code></li>
<li class='green'><span class='hits'>52</span><code>            dataset.hasOwnProperty("dataset") &amp;&amp; (dataset = dataset.dataset);</code></li>
<li class='green'><span class='hits'>52</span><code>            var tableAlias = options.tableAlias, table;</code></li>
<li class='green'><span class='hits'>52</span><code>            if (isString(dataset)) {</code></li>
<li class='green'><span class='hits'>18</span><code>                table = sql.identifier(dataset);</code></li>
<li class='green'><span class='hits'>18</span><code>                dataset = this.db.from(dataset);</code></li>
<li class='green'><span class='hits'>18</span><code>                isUndefinedOrNull(tableAlias) &amp;&amp; (tableAlias = table);</code></li>
<li class='green'><span class='hits'>34</span><code>            } else if (isInstanceOf(dataset, Dataset)) {</code></li>
<li class='green'><span class='hits'>33</span><code>                if (dataset.isSimpleSelectAll) {</code></li>
<li class='green'><span class='hits'>29</span><code>                    table = dataset.__opts.from[0];</code></li>
<li class='green'><span class='hits'>29</span><code>                    isUndefinedOrNull(tableAlias) &amp;&amp; (tableAlias = table);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>4</span><code>                    table = dataset;</code></li>
<li class='green'><span class='hits'>4</span><code>                    isUndefinedOrNull(tableAlias) &amp;&amp; (tableAlias = this._datasetAlias((this.__opts.numDatasetSources || 0) + 1));</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new QueryError("The dataset arg should be a string, dataset or model");</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>51</span><code>            var aliases;</code></li>
<li class='green'><span class=''> </span><code>            // Only allow table aliases that haven't been used</code></li>
<li class='green'><span class='hits'>51</span><code>            var thisOpts = this.__opts, thisOptsGraph = thisOpts.graph;</code></li>
<li class='green'><span class='hits'>51</span><code>            if (isObject(thisOptsGraph) &amp;&amp; isHash((aliases = thisOptsGraph.tableAliases)) &amp;&amp; !isUndefinedOrNull(aliases[tableAlias.value])) {</code></li>
<li class='green'><span class='hits'>1</span><code>                raiseAliasError(options);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>            // Use a from_self if this is already a joined table</code></li>
<li class='green'><span class='hits'>50</span><code>            var ds = (!thisOptsGraph &amp;&amp; (thisOpts.from.length &gt; 1 || thisOpts.join)) ? this.fromSelf({alias:options.fromSelfAlias || this.firstSourceAlias}) : this;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Join the table early in order to avoid cloning the dataset twice</code></li>
<li class='green'><span class='hits'>50</span><code>            ds = ds.joinTable(options.joinType || "leftOuter", table, joinConditions, {tableAlias:tableAlias, implicitQualifier:options.implicitQualifier}, block);</code></li>
<li class='green'><span class='hits'>50</span><code>            var opts = ds.__opts;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Whether to include the table in the result set</code></li>
<li class='green'><span class='hits'>50</span><code>            var addTable = isBoolean(options.select) ? options.select : true;</code></li>
<li class='green'><span class=''> </span><code>            // Whether to add the columns to the list of column aliases</code></li>
<li class='green'><span class='hits'>50</span><code>            var addColumns = isUndefinedOrNull(opts.graphAliases);</code></li>
<li class='green'><span class=''> </span><code>            // Setup the initial graph data structure if it doesn't exist</code></li>
<li class='green'><span class='hits'>50</span><code>            var graph;</code></li>
<li class='green'><span class='hits'>50</span><code>            var populateGraphPromise = new Promise();</code></li>
<li class='green'><span class='hits'>50</span><code>            if (isUndefinedOrNull((graph = opts.graph))) {</code></li>
<li class='green'><span class='hits'>41</span><code>                var master = this._toTableName(ds.firstSourceAlias);</code></li>
<li class='green'><span class='hits'>41</span><code>                (master == tableAlias) &amp;&amp; raiseAliasError(options);</code></li>
<li class='green'><span class=''> </span><code>                // Master hash storing all .graph related information</code></li>
<li class='green'><span class='hits'>40</span><code>                graph = opts.graph = {};</code></li>
<li class='green'><span class=''> </span><code>                // Associates column aliases back to tables and columns</code></li>
<li class='green'><span class='hits'>40</span><code>                var columnAliases = graph.columnAliases = {};</code></li>
<li class='green'><span class=''> </span><code>                // Associates table alias (the master is never aliased)</code></li>
<li class='green'><span class='hits'>40</span><code>                var tableAliases = graph.tableAliases = {};</code></li>
<li class='green'><span class='hits'>40</span><code>                tableAliases[master] = this;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                // All columns in the master table are never</code></li>
<li class='green'><span class=''> </span><code>                // aliased, but are not included if set_graph_aliases</code></li>
<li class='green'><span class=''> </span><code>                // has been used.</code></li>
<li class='green'><span class='hits'>40</span><code>                if (addColumns) {</code></li>
<li class='green'><span class='hits'>39</span><code>                    var select = opts.select = [];</code></li>
<li class='green'><span class='hits'>39</span><code>                    this.columns.then(hitch(this, function (cols) {</code></li>
<li class='green'><span class='hits'>39</span><code>                        cols.forEach(function (column) {</code></li>
<li class='green'><span class='hits'>113</span><code>                            columnAliases[column] = [master, column];</code></li>
<li class='green'><span class='hits'>113</span><code>                            select.push(new sql.QualifiedIdentifier(master, column));</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class='hits'>39</span><code>                        populateGraphPromise.callback(graph);</code></li>
<li class='green'><span class=''> </span><code>                    }), ret);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>1</span><code>                    populateGraphPromise.callback(graph);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>9</span><code>                populateGraphPromise.callback(graph);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>49</span><code>            populateGraphPromise.then(hitch(this, function (graph) {</code></li>
<li class='green'><span class=''> </span><code>                // Add the table alias to the list of aliases</code></li>
<li class='green'><span class=''> </span><code>                // Even if it isn't been used in the result set,</code></li>
<li class='green'><span class=''> </span><code>                // we add a key for it with a nil value so we can check if it</code></li>
<li class='green'><span class=''> </span><code>                // is used more than once</code></li>
<li class='green'><span class='hits'>49</span><code>                var tableAliases = graph.tableAliases;</code></li>
<li class='green'><span class='hits'>49</span><code>                tableAliases[tableAlias] = addTable ? dataset : null;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                // Add the columns to the selection unless we are ignoring them</code></li>
<li class='green'><span class='hits'>49</span><code>                if (addTable &amp;&amp; addColumns) {</code></li>
<li class='green'><span class='hits'>46</span><code>                    var select = opts.select;</code></li>
<li class='green'><span class='hits'>46</span><code>                    var columnAliases = graph.columnAliases;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>                    // Which columns to add to the result set</code></li>
<li class='green'><span class='hits'>46</span><code>                    var dsColPromise;</code></li>
<li class='green'><span class='hits'>46</span><code>                    if (options.select) {</code></li>
<li class='green'><span class='hits'>1</span><code>                        dsColPromise = new Promise().callback(options.select);</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>45</span><code>                        dsColPromise = dataset.columns;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                    // If the column hasn't been used yet, don't alias it.</code></li>
<li class='green'><span class=''> </span><code>                    // If it has been used, try tableColumn.</code></li>
<li class='green'><span class='hits'>46</span><code>                    dsColPromise.then(hitch(this, function (cols) {</code></li>
<li class='green'><span class='hits'>46</span><code>                        cols.forEach(function (column) {</code></li>
<li class='green'><span class='hits'>182</span><code>                            var colAlias, identifier;</code></li>
<li class='green'><span class='hits'>182</span><code>                            if (columnAliases[column]) {</code></li>
<li class='green'><span class='hits'>135</span><code>                                var columnAlias = format("%s_%s", [tableAlias, column]);</code></li>
<li class='green'><span class='hits'>135</span><code>                                colAlias = columnAlias;</code></li>
<li class='green'><span class='hits'>135</span><code>                                identifier = new sql.QualifiedIdentifier(tableAlias, column).as(columnAlias);</code></li>
<li class='green'><span class=''> </span><code>                            } else {</code></li>
<li class='green'><span class='hits'>47</span><code>                                colAlias = column;</code></li>
<li class='green'><span class='hits'>47</span><code>                                identifier = new sql.QualifiedIdentifier(tableAlias, column);</code></li>
<li class='green'><span class=''> </span><code>                            }</code></li>
<li class='green'><span class='hits'>182</span><code>                            columnAliases[colAlias] = [tableAlias, column];</code></li>
<li class='green'><span class='hits'>182</span><code>                            select.push(identifier);</code></li>
<li class='green'><span class=''> </span><code>                        });</code></li>
<li class='green'><span class='hits'>46</span><code>                        ret.callback(ds);</code></li>
<li class='green'><span class=''> </span><code>                    }), ret);</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                    ret.callback(ds);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }), ret);</code></li>
<li class='green'><span class='hits'>49</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * This allows you to manually specify the graph aliases to use</code></li>
<li class='green'><span class=''> </span><code>         * when using graph.  You can use it to only select certain</code></li>
<li class='green'><span class=''> </span><code>         * columns, and have those columns mapped to specific aliases</code></li>
<li class='green'><span class=''> </span><code>         * in the result set.  This is the equivalent of {@link patio.Dataset#select} for a</code></li>
<li class='green'><span class=''> </span><code>         * graphed dataset, and must be used instead of {@link patio.Dataset#select} whenever</code></li>
<li class='green'><span class=''> </span><code>         * graphing is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var DB = patio.defaultDatabase, ds = DB.from("artists");</code></li>
<li class='green'><span class=''> </span><code>         * var p = comb.executeInOrder(ds, function(ds){</code></li>
<li class='green'><span class=''> </span><code>         *     var graphedDs = ds.graph("albums", {artist_id : id});</code></li>
<li class='green'><span class=''> </span><code>         *     //SELECT artists.name AS artist_name, albums.name AS album_name, 42 AS forty_two FROM table</code></li>
<li class='green'><span class=''> </span><code>         *     return graphedDs.setGraphAliases({artist_name : ["artists", "name"],</code></li>
<li class='green'><span class=''> </span><code>         *                       album_name : ["albums", "name"],</code></li>
<li class='green'><span class=''> </span><code>         *                       forty_two : ["albums", "fourtwo", 42]).first();</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * p.then(function(obj){</code></li>
<li class='green'><span class=''> </span><code>         *    //obj == {artists : {name : artists.name}, albums : {name : albums.name, fourtwo : 42}}</code></li>
<li class='green'><span class=''> </span><code>         * });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @parameter {Object} graphAliases Should be a hash with keys being  column aliases, and values being</code></li>
<li class='green'><span class=''> </span><code>         *                  arrays with two or three elements. The first element of the array should be the table alias,</code></li>
<li class='green'><span class=''> </span><code>         *                  and the second should be the actual column name. If the array</code></li>
<li class='green'><span class=''> </span><code>         *                  has a third element, it is used as the value returned, instead of</code></li>
<li class='green'><span class=''> </span><code>         *                  tableAlias.columnName.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        setGraphAliases:function (graphAliases) {</code></li>
<li class='green'><span class='hits'>10</span><code>            var ds = this.select.apply(this, this.__graphAliasColumns(graphAliases));</code></li>
<li class='green'><span class='hits'>10</span><code>            ds.__opts.graphAliases = graphAliases;</code></li>
<li class='green'><span class='hits'>10</span><code>            return ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Remove the splitting of results into subhashes, and all metadata</code></li>
<li class='green'><span class=''> </span><code>         * related to the current graph (if any).</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ungraphed:function () {</code></li>
<li class='green'><span class='hits'>237</span><code>            return this.mergeOptions({graph:null});</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //Transform the hash of graph aliases to an array of columns</code></li>
<li class='green'><span class=''> </span><code>        __graphAliasColumns:function (graphAliases) {</code></li>
<li class='green'><span class='hits'>13</span><code>            var ret = [];</code></li>
<li class='green'><span class='hits'>13</span><code>            if (isArray(graphAliases)) {</code></li>
<li class='green'><span class='hits'>1</span><code>                var newGraphAliases = {};</code></li>
<li class='green'><span class='hits'>1</span><code>                for (var i in graphAliases) {</code></li>
<li class='green'><span class='hits'>2</span><code>                    newGraphAliases[graphAliases[i][0]] = graphAliases[i][1];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>1</span><code>                graphAliases = newGraphAliases;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>13</span><code>            for (var colAlias in graphAliases) {</code></li>
<li class='green'><span class='hits'>20</span><code>                var tc = graphAliases[colAlias];</code></li>
<li class='green'><span class='hits'>20</span><code>                var identifier = tc[2] || new sql.QualifiedIdentifier(tc[0], tc[1]);</code></li>
<li class='green'><span class='hits'>20</span><code>                if (tc[2] || tc[1] != colAlias) {</code></li>
<li class='green'><span class='hits'>10</span><code>                    identifier = new sql.AliasedExpression(identifier, colAlias);</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>20</span><code>                ret.push(identifier);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>13</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Fetch the rows, split them into component table parts,</code></li>
<li class='green'><span class=''> </span><code>         * transform and run the {@link patio.Dataset#rowCb} on each part (if applicable),</code></li>
<li class='green'><span class=''> </span><code>         * and yield a hash of the parts.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        graphEach:function (cb) {</code></li>
<li class='green'><span class=''> </span><code>            // Reject tables with nil datasets, as they are excluded from</code></li>
<li class='green'><span class=''> </span><code>            // the result set</code></li>
<li class='green'><span class='hits'>12</span><code>            var datasets = toArray(this.__opts.graph.tableAliases).filter(function (e) {</code></li>
<li class='green'><span class='hits'>28</span><code>                return !isUndefinedOrNull(e[1]);</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>            // Get just the list of table aliases into a local variable, for speed</code></li>
<li class='green'><span class='hits'>12</span><code>            var tableAliases = datasets.map(function (e) {</code></li>
<li class='green'><span class='hits'>27</span><code>                return e[0];</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>12</span><code>            datasets = datasets.map(function (e) {</code></li>
<li class='green'><span class='hits'>27</span><code>                return [e[0], e[1], e[1].rowCb]</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class=''> </span><code>            // Use the manually set graph aliases, if any, otherwise</code></li>
<li class='green'><span class=''> </span><code>            // use the ones automatically created by .graph</code></li>
<li class='green'><span class='hits'>12</span><code>            var columnAliases = this.__opts.graphAliases || this.__opts.graph.columnAliases;</code></li>
<li class='green'><span class='hits'>12</span><code>            var ret = this.fetchRows(this.selectSql).map(function (r) {</code></li>
<li class='green'><span class='hits'>15</span><code>                var graph = {};</code></li>
<li class='green'><span class=''> </span><code>                // Create the sub hashes, one per table</code></li>
<li class='green'><span class='hits'>15</span><code>                tableAliases.forEach(function (ta) {</code></li>
<li class='green'><span class='hits'>36</span><code>                    graph[ta] = {};</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class=''> </span><code>                // Split the result set based on the column aliases</code></li>
<li class='green'><span class=''> </span><code>                // If there are columns in the result set that are</code></li>
<li class='green'><span class=''> </span><code>                // not in column_aliases, they are ignored</code></li>
<li class='green'><span class='hits'>15</span><code>                for (var colAlias in columnAliases) {</code></li>
<li class='green'><span class='hits'>114</span><code>                    var tc = columnAliases[colAlias];</code></li>
<li class='green'><span class='hits'>114</span><code>                    var ta = tc[0], column = tc[1];</code></li>
<li class='green'><span class='hits'>114</span><code>                    !graph[ta] &amp;&amp; (graph[ta] = {});</code></li>
<li class='green'><span class='hits'>114</span><code>                    graph[ta][column] = r[colAlias];</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>15</span><code>                datasets.forEach(function (d) {</code></li>
<li class='green'><span class='hits'>36</span><code>                    var ta = d[0], ds = d[1], dsCb = d[2];</code></li>
<li class='green'><span class='hits'>36</span><code>                    var g = graph[ta];</code></li>
<li class='green'><span class='hits'>36</span><code>                    if (!isEmpty(g) &amp;&amp; Object.keys(g).some(function (x) {</code></li>
<li class='green'><span class='hits'>49</span><code>                        return !isUndefinedOrNull(g[x]);</code></li>
<li class='green'><span class=''> </span><code>                    })) {</code></li>
<li class='green'><span class='hits'>30</span><code>                        graph[ta] = dsCb ? dsCb(g) : g;</code></li>
<li class='green'><span class=''> </span><code>                    } else {</code></li>
<li class='green'><span class='hits'>6</span><code>                        graph[ta] = null;</code></li>
<li class='green'><span class=''> </span><code>                    }</code></li>
<li class='green'><span class=''> </span><code>                });</code></li>
<li class='green'><span class='hits'>15</span><code>                return graph;</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>12</span><code>            if (cb) {</code></li>
<li class='red'><span class='nohits'>0</span><code>                ret.forEach(cb);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>12</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="adapters/index.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>adapters/index.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>2</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>2</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="adapters/index.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>exports.mysql = require("./mysql");</code></li>
<li class='green'><span class='hits'>1</span><code>exports.postgres = require("./postgres.js");</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="associations/index.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>associations/index.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>18</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>2</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="associations/index.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    merge = comb.merge;</code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @ignore</code></li>
<li class='green'><span class=''> </span><code> * @name patio.associations</code></li>
<li class='green'><span class=''> </span><code> * @namespace</code></li>
<li class='green'><span class=''> </span><code> * */</code></li>
<li class='green'><span class='hits'>1</span><code>comb(exports).merge({</code></li>
<li class='green'><span class=''> </span><code>    oneToMany:require("./oneToMany"),</code></li>
<li class='green'><span class=''> </span><code>    manyToOne:require("./manyToOne"),</code></li>
<li class='green'><span class=''> </span><code>    oneToOne:require("./oneToOne"),</code></li>
<li class='green'><span class=''> </span><code>    manyToMany:require("./manyToMany"),</code></li>
<li class='green'><span class=''> </span><code>    fetch:{</code></li>
<li class='green'><span class=''> </span><code>        LAZY:"lazy",</code></li>
<li class='green'><span class=''> </span><code>        EAGER:"eager"</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="associations/oneToOne.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>associations/oneToOne.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>87</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>26</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="associations/oneToOne.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    isUndefinedOrNull = comb.isUndefinedOrNull,</code></li>
<li class='green'><span class=''> </span><code>    isNull = comb.isNull,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    ManyToOne = require("./manyToOne"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Class to define a manyToOne association.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * &lt;/br&gt;</code></li>
<li class='green'><span class=''> </span><code> * &lt;b&gt;NOT to be instantiated directly&lt;/b&gt;</code></li>
<li class='green'><span class=''> </span><code> * Its just documented for reference.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name ManyToOne</code></li>
<li class='green'><span class=''> </span><code> * @augments patio.associations.ManyToOne</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.associations</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> **/</code></li>
<li class='green'><span class='hits'>1</span><code>define(ManyToOne, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.associations.OneToOne.prototype*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        type:"oneToOne",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __remove:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //override</code></li>
<li class='green'><span class=''> </span><code>        //@see _Association</code></li>
<li class='green'><span class=''> </span><code>        _fetchMethod:"one",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        isOwner:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _preSave:function (next, model) {</code></li>
<li class='green'><span class=''> </span><code>            //handle case where no association was initially set</code></li>
<li class='green'><span class='hits'>46</span><code>            if (!this.associationLoaded(model) || !this.getAssociation(model)) {</code></li>
<li class='green'><span class='hits'>7</span><code>                this.__setValue(model, null);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>            //</code></li>
<li class='green'><span class='hits'>46</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //override</code></li>
<li class='green'><span class=''> </span><code>        //@see _Association</code></li>
<li class='green'><span class=''> </span><code>        _postSave:function (next, model) {</code></li>
<li class='green'><span class='hits'>46</span><code>            var loaded = this.associationLoaded(model), val;</code></li>
<li class='green'><span class='hits'>46</span><code>            if (loaded &amp;&amp; (val = this.getAssociation(model))) {</code></li>
<li class='green'><span class='hits'>39</span><code>                this._setAssociationKeys(model, val);</code></li>
<li class='green'><span class='hits'>39</span><code>                val.save().classic(next);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>7</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _preUpdate : function(next){</code></li>
<li class='green'><span class='hits'>18</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _postUpdate:function (next, model) {</code></li>
<li class='green'><span class='hits'>18</span><code>            var removeAssociationFlagName = this.removeAssociationFlagName;</code></li>
<li class='green'><span class='hits'>18</span><code>            if (model[removeAssociationFlagName]) {</code></li>
<li class='green'><span class='hits'>7</span><code>                var q = {};</code></li>
<li class='green'><span class='hits'>7</span><code>                this._setAssociationKeys(model, q, null);</code></li>
<li class='green'><span class='hits'>7</span><code>                model[this.associatedDatasetName].update(q).classic(next);</code></li>
<li class='green'><span class='hits'>7</span><code>                this.__setValue(model, null);</code></li>
<li class='green'><span class='hits'>7</span><code>                model[removeAssociationFlagName] = false;</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>11</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        //override</code></li>
<li class='green'><span class=''> </span><code>        //@see _Association</code></li>
<li class='green'><span class=''> </span><code>        _setter:function (val, model) {</code></li>
<li class='green'><span class='hits'>53</span><code>            var name = this.name;</code></li>
<li class='green'><span class='hits'>53</span><code>            if (!isUndefinedOrNull(val)) {</code></li>
<li class='green'><span class='hits'>46</span><code>                this.__setValue(model, this._toModel(val));</code></li>
<li class='green'><span class='hits'>7</span><code>            } else if (!model.isNew &amp;&amp; isNull(val)) {</code></li>
<li class='green'><span class='hits'>7</span><code>                model.__isChanged = true;</code></li>
<li class='green'><span class='hits'>7</span><code>                this.__setValue(model, this._toModel(val));</code></li>
<li class='green'><span class='hits'>7</span><code>                model[this.removeAssociationFlagName] = true;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="database/dataset.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>database/dataset.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>107</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>19</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="database/dataset.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    argsToArray = comb.argsToArray,</code></li>
<li class='green'><span class=''> </span><code>    isFunction = comb.isFunction,</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    errors = require("../errors"),</code></li>
<li class='green'><span class=''> </span><code>    NotImplemented = errors.NotImplemented,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    Dataset = require("../dataset");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var Database = define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Database.prototype*/</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *Fetches records for an arbitrary SQL statement. If a block is given,</code></li>
<li class='green'><span class=''> </span><code>         * it is used to iterate over the records:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   DB.fetch('SELECT * FROM items', function(r){</code></li>
<li class='green'><span class=''> </span><code>         *      //do something with row</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *&lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         * If a block is not given then {@link patio.Database#fetch} method returns a {@link patio.Dataset} instance:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   DB.fetch('SELECT * FROM items').all().then(function(records){</code></li>
<li class='green'><span class=''> </span><code>         *      //do something with the records.</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@link patio.Database#fetch} can also perform parameterized queries for protection against SQL</code></li>
<li class='green'><span class=''> </span><code>         * injection:</code></li>
<li class='green'><span class=''> </span><code>         * &lt;pre class="code"&gt;</code></li>
<li class='green'><span class=''> </span><code>         *   DB.fetch('SELECT * FROM items WHERE name = ?', myName).all().then(function(records){</code></li>
<li class='green'><span class=''> </span><code>         *      //do something with the records.</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         * &lt;/pre&gt;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} args variable number of args where the first argument is a String. If more than</code></li>
<li class='green'><span class=''> </span><code>         * one argument is given then the SQL will be treated as a place holder string. See {@link patio.Dataset#withSql}.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Function} [block=null] if the last argument given is a function then {@link patio.Dataset#forEach} will be</code></li>
<li class='green'><span class=''> </span><code>         * invoked on the dataset with the block called for each row.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {Promise|patio.Dataset} if no block is given then a {@link patio.Dataset} will be returned. If a block</code></li>
<li class='green'><span class=''> </span><code>         * is given then the return value will be a Promise that will be invoked after all records have been returned</code></li>
<li class='green'><span class=''> </span><code>         * and processed through the block.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        fetch:function (args, block) {</code></li>
<li class='green'><span class='hits'>23</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>23</span><code>            args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>23</span><code>            block = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='green'><span class='hits'>23</span><code>            var ds = this.dataset.withSql.apply(this.dataset, args);</code></li>
<li class='green'><span class='hits'>23</span><code>            if (block) {</code></li>
<li class='green'><span class='hits'>3</span><code>                ds.forEach(block).then(function () {</code></li>
<li class='green'><span class='hits'>3</span><code>                    ret.callback(ds);</code></li>
<li class='green'><span class=''> </span><code>                }, ret);</code></li>
<li class='green'><span class='hits'>3</span><code>                return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>20</span><code>                return ds;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a new {@link patio.Dataset} with the [@link patio.Dataset#from} method invoked. If a block is given,</code></li>
<li class='green'><span class=''> </span><code>         * it is used as a filter(see {@link patio.Dataset#filter} on the dataset.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items").sql //=&gt; SELECT * FROM items</code></li>
<li class='green'><span class=''> </span><code>         *   DB.from("items", function(){</code></li>
<li class='green'><span class=''> </span><code>         *          return this.id.gt(2)</code></li>
<li class='green'><span class=''> </span><code>         *   }).sql; //=&gt; SELECT * FROM items WHERE (id &gt; 2)</code></li>
<li class='green'><span class=''> </span><code>         * @param {String...} args table/s to pass to {@link patio.Dataset#from} with.</code></li>
<li class='green'><span class=''> </span><code>         * @param {function} [block] an option block to pass to {@link patio.Dataset#filter} with.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Dataset} a dataset to use for querying the {@link patio.Database} with.</code></li>
<li class='green'><span class=''> </span><code>         * */</code></li>
<li class='green'><span class=''> </span><code>        from:function (args, block) {</code></li>
<li class='green'><span class='hits'>529</span><code>            args = argsToArray(arguments);</code></li>
<li class='green'><span class='hits'>529</span><code>            block = isFunction(args[args.length - 1]) ? args.pop() : null;</code></li>
<li class='green'><span class='hits'>529</span><code>            var ds = this.dataset;</code></li>
<li class='green'><span class='hits'>529</span><code>            ds = ds.from.apply(ds, args);</code></li>
<li class='green'><span class='hits'>529</span><code>            return block ? ds.filter(block) : ds;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Returns a new {@link patio.Dataset} with the {@link patio.Dataset#select} method invoked.</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *   DB.select(1) //=&gt; SELECT 1</code></li>
<li class='green'><span class=''> </span><code>         *   DB.select(function(){</code></li>
<li class='green'><span class=''> </span><code>         *      return this.server_version();</code></li>
<li class='green'><span class=''> </span><code>         *   }).sql; //=&gt; SELECT server_version()</code></li>
<li class='green'><span class=''> </span><code>         *   DB.select("id").from("items").sql; //=&gt; SELECT id FROM items</code></li>
<li class='green'><span class=''> </span><code>         * @link {patio.Dataset} a dataset to query the {@link patio.Database} with.</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        select:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            var ds = this.dataset;</code></li>
<li class='green'><span class='hits'>2</span><code>            return ds.select.apply(ds, arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            dataset:function () {</code></li>
<li class='green'><span class='hits'>10</span><code>                return new Dataset(this);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="dataset/features.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>dataset/features.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>223</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>30</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="dataset/features.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        __providesAccurateRowsMatched:true,</code></li>
<li class='green'><span class=''> </span><code>        __requiresSqlStandardDateTimes:false,</code></li>
<li class='green'><span class=''> </span><code>        __supportsCte:true,</code></li>
<li class='green'><span class=''> </span><code>        __supportsDistinctOn:false,</code></li>
<li class='green'><span class=''> </span><code>        __supportsIntersectExcept:true,</code></li>
<li class='green'><span class=''> </span><code>        __supportsIntersectExceptAll:true,</code></li>
<li class='green'><span class=''> </span><code>        __supportsIsTrue:true,</code></li>
<li class='green'><span class=''> </span><code>        __supportsJoinUsing:true,</code></li>
<li class='green'><span class=''> </span><code>        __supportsModifyingJoins:false,</code></li>
<li class='green'><span class=''> </span><code>        __supportsMultipleColumnIn:true,</code></li>
<li class='green'><span class=''> </span><code>        __supportsTimestampTimezones:false,</code></li>
<li class='green'><span class=''> </span><code>        __supportsTimestampUsecs:true,</code></li>
<li class='green'><span class=''> </span><code>        __supportsWindowFunctions:false,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code>            // Whether this dataset quotes identifiers.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function(){</code></li>
<li class='green'><span class='hits'>47781</span><code>                return this.__quoteIdentifiers;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Whether this dataset will provide accurate number of rows matched for</code></li>
<li class='green'><span class=''> </span><code>            // delete and update statements.  Accurate in this case is the number of</code></li>
<li class='green'><span class=''> </span><code>            // rows matched by the dataset's filter.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            providesAccurateRowsMatched:function(){</code></li>
<li class='green'><span class='hits'>14920</span><code>                return this.__providesAccurateRowsMatched;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset requires SQL standard datetimes (false by default,</code></li>
<li class='green'><span class=''> </span><code>            // as most allow strings with ISO 8601 format).</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            requiresSqlStandardDateTimes:function(){</code></li>
<li class='green'><span class='hits'>14927</span><code>                return this.__requiresSqlStandardDateTimes;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Whether the dataset supports common table expressions (the WITH clause).</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsCte:function(){</code></li>
<li class='green'><span class='hits'>14933</span><code>                return this.__supportsCte;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Whether the dataset supports the DISTINCT ON clause, false by default.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsDistinctOn:function(){</code></li>
<li class='green'><span class='hits'>2279</span><code>                return this.__supportsDistinctOn;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the INTERSECT and EXCEPT compound operations, true by default.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsIntersectExcept:function(){</code></li>
<li class='green'><span class='hits'>14956</span><code>                return this.__supportsIntersectExcept;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the INTERSECT ALL and EXCEPT ALL compound operations, true by default.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsIntersectExceptAll:function(){</code></li>
<li class='green'><span class='hits'>14932</span><code>                return this.__supportsIntersectExceptAll;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the IS TRUE syntax.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsIsTrue:function(){</code></li>
<li class='green'><span class='hits'>15156</span><code>                return this.__supportsIsTrue;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the JOIN table USING (column1, ...) syntax.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsJoinUsing:function(){</code></li>
<li class='green'><span class='hits'>14931</span><code>                return this.__supportsJoinUsing;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether modifying joined datasets is supported.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsModifyingJoins:function(){</code></li>
<li class='green'><span class='hits'>2519</span><code>                return this.__supportsModifyingJoins;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the IN/NOT IN operators support multiple columns when an</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsMultipleColumnIn:function(){</code></li>
<li class='green'><span class='hits'>14924</span><code>                return this.__supportsMultipleColumnIn;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports timezones in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsTimestampTimezones:function(){</code></li>
<li class='green'><span class='hits'>2276</span><code>                return this.__supportsTimestampTimezones;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports fractional seconds in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsTimestampUsecs:function(){</code></li>
<li class='green'><span class='hits'>14920</span><code>                return this.__supportsTimestampUsecs;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports window functions.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsWindowFunctions:function(){</code></li>
<li class='green'><span class='hits'>14920</span><code>                return this.__supportsWindowFunctions;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@lends patio.Dataset.prototype*/</code></li>
<li class='green'><span class=''> </span><code>            // Whether this dataset quotes identifiers.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            quoteIdentifiers:function(val){</code></li>
<li class='green'><span class='hits'>14932</span><code>                this.__quoteIdentifiers = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Whether this dataset will provide accurate number of rows matched for</code></li>
<li class='green'><span class=''> </span><code>            // delete and update statements.  Accurate in this case is the number of</code></li>
<li class='green'><span class=''> </span><code>            // rows matched by the dataset's filter.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            providesAccurateRowsMatched:function(val){</code></li>
<li class='green'><span class='hits'>14920</span><code>                this.__providesAccurateRowsMatched = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset requires SQL standard datetimes (false by default,</code></li>
<li class='green'><span class=''> </span><code>            // as most allow strings with ISO 8601 format).</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            requiresSqlStandardDateTimes:function(val){</code></li>
<li class='green'><span class='hits'>14920</span><code>                this.__requiresSqlStandardDateTimes = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Whether the dataset supports common table expressions (the WITH clause).</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsCte:function(val){</code></li>
<li class='green'><span class='hits'>14921</span><code>                this.__supportsCte = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            // Whether the dataset supports the DISTINCT ON clause, false by default.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsDistinctOn:function(val){</code></li>
<li class='green'><span class='hits'>2277</span><code>                this.__supportsDistinctOn = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the INTERSECT and EXCEPT compound operations, true by default.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsIntersectExcept:function(val){</code></li>
<li class='green'><span class='hits'>14922</span><code>                this.__supportsIntersectExcept = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the INTERSECT ALL and EXCEPT ALL compound operations, true by default.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsIntersectExceptAll:function(val){</code></li>
<li class='green'><span class='hits'>14922</span><code>                this.__supportsIntersectExceptAll = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the IS TRUE syntax.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsIsTrue:function(val){</code></li>
<li class='green'><span class='hits'>14920</span><code>                this.__supportsIsTrue = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports the JOIN table USING (column1, ...) syntax.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsJoinUsing:function(val){</code></li>
<li class='green'><span class='hits'>14922</span><code>                this.__supportsJoinUsing = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether modifying joined datasets is supported.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsModifyingJoins:function(val){</code></li>
<li class='green'><span class='hits'>2277</span><code>                this.__supportsModifyingJoins = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the IN/NOT IN operators support multiple columns when an</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsMultipleColumnIn:function(val){</code></li>
<li class='green'><span class='hits'>14920</span><code>                this.__supportsMultipleColumnIn = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports timezones in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsTimestampTimezones:function(val){</code></li>
<li class='green'><span class='hits'>2276</span><code>                this.__supportsTimestampTimezones = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports fractional seconds in literal timestamps</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsTimestampUsecs:function(val){</code></li>
<li class='green'><span class='hits'>14920</span><code>                this.__supportsTimestampUsecs = val;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            //Whether the dataset supports window functions.</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            supportsWindowFunctions:function(val){</code></li>
<li class='green'><span class='hits'>14920</span><code>                this.__supportsWindowFunctions = val;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.Dataset*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @property {String[]}</code></li>
<li class='green'><span class=''> </span><code>         * @default ["quoteIdentifiers","providesAccurateRowsMatched","requiresSqlStandardDateTimes","supportsCte",</code></li>
<li class='green'><span class=''> </span><code>         * "supportsDistinctOn","supportsIntersectExcept","supportsIntersectExceptAll","supportsIsTrue","supportsJoinUsing",</code></li>
<li class='green'><span class=''> </span><code>         * "supportsModifyingJoins","supportsMultipleColumnIn","supportsTimestampTimezones","supportsTimestampUsecs",</code></li>
<li class='green'><span class=''> </span><code>         * "supportsWindowFunctions"]</code></li>
<li class='green'><span class=''> </span><code>         * Array of features.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        FEATURES:["quoteIdentifiers", "providesAccurateRowsMatched", "requiresSqlStandardDateTimes", "supportsCte",</code></li>
<li class='green'><span class=''> </span><code>            "supportsDistinctOn", "supportsIntersectExcept", "supportsIntersectExceptAll", "supportsIsTrue", "supportsJoinUsing",</code></li>
<li class='green'><span class=''> </span><code>            "supportsModifyingJoins", "supportsMultipleColumnIn", "supportsTimestampTimezones", "supportsTimestampUsecs",</code></li>
<li class='green'><span class=''> </span><code>            "supportsWindowFunctions"]</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="plugins/cache.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/cache.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>83</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>31</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/cache.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    hitch = comb.hitch,</code></li>
<li class='green'><span class=''> </span><code>    Promise = comb.Promise,</code></li>
<li class='green'><span class=''> </span><code>    PromiseList = comb.PromiseList,</code></li>
<li class='green'><span class=''> </span><code>    Hive = require("hive-cache");</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var hive;</code></li>
<li class='green'><span class='hits'>1</span><code>var i = 0;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var LOGGER = comb.logging.Logger.getLogger("patio.plugins.CachePlugin");</code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Adds in memory caching support for models.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * var MyModel = patio.addModel("testTable", {</code></li>
<li class='green'><span class=''> </span><code> *     plugins : [patio.plugins.CachePlugin];</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //NOW IT WILL CACHE</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name CachePlugin</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.plugins</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>exports.CachePlugin = comb.define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>6</span><code>            this.post("load", this._postLoad);</code></li>
<li class='green'><span class='hits'>6</span><code>            this._static.initHive();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        reload:function () {</code></li>
<li class='green'><span class='hits'>1</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>1</span><code>            this._super(arguments).then(hitch(this, function (m) {</code></li>
<li class='green'><span class='hits'>1</span><code>                hive.replace((this.tableName.toString() + this.primaryKeyValue.toString()), m);</code></li>
<li class='green'><span class='hits'>1</span><code>                ret.callback(m);</code></li>
<li class='green'><span class=''> </span><code>            }), ret);</code></li>
<li class='green'><span class='hits'>1</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        _postLoad:function (next) {</code></li>
<li class='green'><span class='hits'>25</span><code>            hive.replace(this.tableName + this.primaryKeyValue, this);</code></li>
<li class='green'><span class='hits'>25</span><code>            next();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        update:function (options, errback) {</code></li>
<li class='green'><span class='hits'>1</span><code>            var ret = new Promise();</code></li>
<li class='green'><span class='hits'>1</span><code>            this._super(arguments).then(hitch(this, function (val) {</code></li>
<li class='green'><span class='hits'>1</span><code>                hive.remove(this.tableName + this.primaryKeyValue, val);</code></li>
<li class='green'><span class='hits'>1</span><code>                ret.callback(val);</code></li>
<li class='green'><span class=''> </span><code>            }), ret);</code></li>
<li class='green'><span class='hits'>1</span><code>            return ret.promise();</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        remove:function (errback) {</code></li>
<li class='green'><span class='hits'>1</span><code>            hive.remove(this.tableName + this.primaryKeyValue);</code></li>
<li class='green'><span class='hits'>1</span><code>            return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        initHive:function () {</code></li>
<li class='green'><span class='hits'>6</span><code>            if (!hive) {</code></li>
<li class='green'><span class='hits'>1</span><code>                hive = new Hive();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>6</span><code>            this.cache = hive;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        findById:function (id) {</code></li>
<li class='green'><span class='hits'>3</span><code>            var cached = hive.get(this.tableName + id);</code></li>
<li class='green'><span class='hits'>3</span><code>            if (!cached) {</code></li>
<li class='green'><span class='hits'>1</span><code>                return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>            } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                var ret = new Promise();</code></li>
<li class='green'><span class='hits'>2</span><code>                ret.callback(cached);</code></li>
<li class='green'><span class='hits'>2</span><code>                return ret;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>});</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="plugins/columnMapper.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/columnMapper.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>192</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>44</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/columnMapper.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    toArray = comb.array.toArray,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf,</code></li>
<li class='green'><span class=''> </span><code>    isBoolean = comb.isBoolean,</code></li>
<li class='green'><span class=''> </span><code>    when = comb.when,</code></li>
<li class='green'><span class=''> </span><code>    isHash = comb.isHash,</code></li>
<li class='green'><span class=''> </span><code>    isString = comb.isString,</code></li>
<li class='green'><span class=''> </span><code>    sql = require("../sql.js").sql,</code></li>
<li class='green'><span class=''> </span><code>    AliasedExpression = sql.AliasedExpression,</code></li>
<li class='green'><span class=''> </span><code>    Identifier = sql.Identifier,</code></li>
<li class='green'><span class=''> </span><code>    isConditionSpecifier = sql.Expression.isConditionSpecifier,</code></li>
<li class='green'><span class=''> </span><code>    ModelError = require("../errors.js").ModelError;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class This plugin exposes the ability to map columns on other tables to this Model.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * See {@link patio.plugins.ColumnMapper.mappedColumn} for more information.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name ColumnMapper</code></li>
<li class='green'><span class=''> </span><code> * @memberof patio.plugins</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>comb.define(null, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    "static":{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.plugins.ColumnMapper*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Boolean flag indicating if mapped columns should be re-fetched on update.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;NOTE&lt;/b&gt; This can be overridden by passing {reload : false} to the {@link patio.Model#update} method.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fetchMappedColumnsOnUpdate:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Boolean flag indicating if mapped columns should be re-fetched on save.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;NOTE&lt;/b&gt; This can be overridden by passing {reload : false} to the {@link patio.Model#save} method.</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        fetchMappedColumnsOnSave:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Add a mapped column from another table. This is useful if there columns on</code></li>
<li class='green'><span class=''> </span><code>         * another table but you do not want to load the association every time.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * For example assume we have an employee and works table. Well we might want the salary from the works table,</code></li>
<li class='green'><span class=''> </span><code>         * but do not want to add it to the employee table.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * &lt;b&gt;NOTE:&lt;/b&gt; mapped columns are READ ONLY.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * patio.addModel("employee")</code></li>
<li class='green'><span class=''> </span><code>         *    .oneToOne("works")</code></li>
<li class='green'><span class=''> </span><code>         *    .mappedColumn("salary", "works", {employeeId : patio.sql.identifier("id")});</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * You can also change the name of the of the column</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *  patio.addModel("employee")</code></li>
<li class='green'><span class=''> </span><code>         *    .oneToOne("works")</code></li>
<li class='green'><span class=''> </span><code>         *    .mappedColumn("mySalary", "works", {employeeId : patio.sql.identifier("id")}, {</code></li>
<li class='green'><span class=''> </span><code>         *          column : "salary"</code></li>
<li class='green'><span class=''> </span><code>         *    });</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If you want to prevent the mapped columns from being reloaded after a save or update you can set the</code></li>
<li class='green'><span class=''> </span><code>         * &lt;code&gt;fetchMappedColumnsOnUpdate&lt;/code&gt; or &lt;code&gt;fetchMappedColumnsOnSave&lt;/code&gt; to false.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var Employee = patio.addModel("employee")</code></li>
<li class='green'><span class=''> </span><code>         *   .oneToOne("works")</code></li>
<li class='green'><span class=''> </span><code>         *   .mappedColumn("mySalary", "works", {employeeId : patio.sql.identifier("id")}, {</code></li>
<li class='green'><span class=''> </span><code>         *          column : "salary"</code></li>
<li class='green'><span class=''> </span><code>         *   });</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //prevent the mapped columns from being fetched after a save.</code></li>
<li class='green'><span class=''> </span><code>         * Employee.fetchMappedColumnsOnSave = false;</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //prevent the mapped columns from being re-fetched after an update.</code></li>
<li class='green'><span class=''> </span><code>         * Employee.fetchMappedColumnsOnUpdate = false;</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * You can also override prevent the properties from being reloaded by setting the &lt;code&gt;reload&lt;/code&gt; or &lt;code&gt;reloadMapped&lt;/code&gt; options when saving or updating.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * {@code</code></li>
<li class='green'><span class=''> </span><code>         * //prevents entire model from being reloaded including mapped columns</code></li>
<li class='green'><span class=''> </span><code>         * employee.save(null, {reload : false});</code></li>
<li class='green'><span class=''> </span><code>         * employee.update(null, {reload : false});</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //just prevents just the mapped columns from being reloaded</code></li>
<li class='green'><span class=''> </span><code>         * employee.save(null, {reloadMapped : false});</code></li>
<li class='green'><span class=''> </span><code>         * employee.update(null, {reloadMapped : false});</code></li>
<li class='green'><span class=''> </span><code>         * }</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} name the name you want the column represented as on the model.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.Model} table the table or model you want the property mapped from</code></li>
<li class='green'><span class=''> </span><code>         * @param condition the join condition. See {@link patio.Dataset#joinTable}.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [opts={}] additional options</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [opts.joinType="left"] the join type to use when gathering the properties.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String|patio.sql.Identifer} [opts.column=null] the column on the remote table that should be used</code></li>
<li class='green'><span class=''> </span><code>         * as the local copy.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.Model} returns the model for chaining.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        mappedColumn:function (name, table, condition, opts) {</code></li>
<li class='green'><span class='hits'>6</span><code>            opts = opts || {};</code></li>
<li class='green'><span class='hits'>6</span><code>            if (name) {</code></li>
<li class='green'><span class='hits'>6</span><code>                name = sql.stringToIdentifier(name);</code></li>
<li class='green'><span class='hits'>6</span><code>                if (table &amp;&amp; condition) {</code></li>
<li class='green'><span class='hits'>4</span><code>                    opts = comb.merge({joinType:"left", table:table, condition:condition, column:name}, opts);</code></li>
<li class='green'><span class='hits'>4</span><code>                    this._mappedColumns[name] = opts;</code></li>
<li class='green'><span class=''> </span><code>                } else {</code></li>
<li class='green'><span class='hits'>2</span><code>                    throw new ModelError("mapped column requires a table and join condition");</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4</span><code>            return this;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        sync:function () {</code></li>
<li class='green'><span class='hits'>44</span><code>            var ret = this._super(arguments);</code></li>
<li class='green'><span class='hits'>44</span><code>            if (!this.synced) {</code></li>
<li class='green'><span class='hits'>1</span><code>                ret = ret.chain(function () {</code></li>
<li class='green'><span class='hits'>1</span><code>                    var ds = this.dataset.naked().select(), mappedColumns = this._mappedColumns, joinTableAlias = "columnMapper", selects = [];</code></li>
<li class='green'><span class='hits'>1</span><code>                    Object.keys(mappedColumns).forEach(function (column, i) {</code></li>
<li class='green'><span class='hits'>4</span><code>                        var opts = mappedColumns[column],</code></li>
<li class='green'><span class=''> </span><code>                            condition = opts.condition;</code></li>
<li class='green'><span class='hits'>4</span><code>                        if (isConditionSpecifier(condition)) {</code></li>
<li class='green'><span class='hits'>4</span><code>                            condition = toArray(condition);</code></li>
<li class='green'><span class='hits'>4</span><code>                            condition.forEach(function (cond) {</code></li>
<li class='green'><span class='hits'>4</span><code>                                var val = cond[1];</code></li>
<li class='green'><span class='hits'>4</span><code>                                if (!isInstanceOf(val, AliasedExpression) &amp;&amp; isInstanceOf(val, Identifier)) {</code></li>
<li class='green'><span class='hits'>4</span><code>                                    cond[1] = val.qualify(this.tableName);</code></li>
<li class='green'><span class=''> </span><code>                                }</code></li>
<li class='green'><span class=''> </span><code>                            }, this);</code></li>
<li class='green'><span class='hits'>4</span><code>                            var tableAlias = sql.identifier(joinTableAlias + i);</code></li>
<li class='green'><span class='hits'>4</span><code>                            ds = ds.joinTable(opts.joinType, opts.table, condition, {tableAlias:tableAlias});</code></li>
<li class='green'><span class='hits'>4</span><code>                            selects.push(sql.stringToIdentifier(opts.column).qualify(tableAlias).as(column));</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    }, this);</code></li>
<li class='green'><span class='hits'>1</span><code>                    ds = ds.select(selects);</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>                    var middleWare = function (next) {</code></li>
<li class='green'><span class='hits'>17</span><code>                        ds.filter(this._getPrimaryKeyQuery()).qualify().one().then(function (vals) {</code></li>
<li class='green'><span class='hits'>17</span><code>                            this.setValues(vals);</code></li>
<li class='green'><span class=''> </span><code>                        }.bind(this)).classic(next);</code></li>
<li class='green'><span class=''> </span><code>                    };</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>                    var self = this;</code></li>
<li class='green'><span class='hits'>1</span><code>                    this.post("load", middleWare);</code></li>
<li class='green'><span class='hits'>1</span><code>                    this.post("save", function (next, options) {</code></li>
<li class='green'><span class='hits'>9</span><code>                        options = options || {};</code></li>
<li class='green'><span class='hits'>9</span><code>                        if (self.fetchMappedColumnsOnSave &amp;&amp;</code></li>
<li class='green'><span class=''> </span><code>                            isBoolean(options.reload) ? options.reload :</code></li>
<li class='green'><span class=''> </span><code>                            isBoolean(options.reloadMapped) ? options.reloadMapped :</code></li>
<li class='green'><span class=''> </span><code>                                self.reloadOnSave) {</code></li>
<li class='green'><span class='hits'>6</span><code>                            middleWare.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                            next();</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class='hits'>1</span><code>                    this.post("update", function (next, options) {</code></li>
<li class='green'><span class='hits'>4</span><code>                        options = options || {};</code></li>
<li class='green'><span class='hits'>4</span><code>                        if (self.fetchMappedColumnsOnUpdate &amp;&amp;</code></li>
<li class='green'><span class=''> </span><code>                            isBoolean(options.reload) ? options.reload :</code></li>
<li class='green'><span class=''> </span><code>                            isBoolean(options.reloadMapped) ? options.reloadMapped :</code></li>
<li class='green'><span class=''> </span><code>                                self.reloadOnUpdate) {</code></li>
<li class='green'><span class='hits'>1</span><code>                            middleWare.apply(this, arguments);</code></li>
<li class='green'><span class=''> </span><code>                        } else {</code></li>
<li class='green'><span class='hits'>3</span><code>                            next();</code></li>
<li class='green'><span class=''> </span><code>                        }</code></li>
<li class='green'><span class=''> </span><code>                    });</code></li>
<li class='green'><span class=''> </span><code>                }.bind(this));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>44</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        init:function () {</code></li>
<li class='green'><span class='hits'>2</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>2</span><code>            this._mappedColumns = {};</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="plugins/index.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/index.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>16</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>2</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/index.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"), inheritance = require("./inheritance");</code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @ignore</code></li>
<li class='green'><span class=''> </span><code> * @namespace</code></li>
<li class='green'><span class=''> </span><code> * @name patio.plugins</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>comb.merge(exports, {</code></li>
<li class='green'><span class=''> </span><code>    QueryPlugin:require("./query").QueryPlugin,</code></li>
<li class='green'><span class=''> </span><code>    CachePlugin:require("./cache").CachePlugin,</code></li>
<li class='green'><span class=''> </span><code>    AssociationPlugin:require("./association").AssociationPlugin,</code></li>
<li class='green'><span class=''> </span><code>    TimeStampPlugin:require("./timestamp"),</code></li>
<li class='green'><span class=''> </span><code>    ClassTableInheritancePlugin:inheritance.ClassTableInheritance,</code></li>
<li class='green'><span class=''> </span><code>    ColumnMapper:require("./columnMapper.js"),</code></li>
<li class='green'><span class=''> </span><code>    ValidatorPlugin:require("./validation.js")</code></li>
<li class='green'><span class=''> </span><code>});</code></li>
<li class='green'><span class=''> </span><code></code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="plugins/timestamp.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>plugins/timestamp.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>145</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>27</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="plugins/timestamp.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var define = require("comb").define, DateTime;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * @class Time stamp plugin to support creating timestamp</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @example</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //initialize default timestamp functionality</code></li>
<li class='green'><span class=''> </span><code> * var MyModel = patio.addModel("testTable", {</code></li>
<li class='green'><span class=''> </span><code> *     plugins : [patio.plugins.TimeStampPlugin],</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *     static : {</code></li>
<li class='green'><span class=''> </span><code> *         init : function(){</code></li>
<li class='green'><span class=''> </span><code> *             this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code> *             this.timestamp();</code></li>
<li class='green'><span class=''> </span><code> *         }</code></li>
<li class='green'><span class=''> </span><code> *     }</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //custom updated column</code></li>
<li class='green'><span class=''> </span><code> * var MyModel = patio.addModel("testTable", {</code></li>
<li class='green'><span class=''> </span><code> *     plugins : [patio.plugins.TimeStampPlugin],</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *     static : {</code></li>
<li class='green'><span class=''> </span><code> *         init : function(){</code></li>
<li class='green'><span class=''> </span><code> *             this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code> *             this.timestamp({updated : "myUpdatedColumn"});</code></li>
<li class='green'><span class=''> </span><code> *         }</code></li>
<li class='green'><span class=''> </span><code> *     }</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //custom created column</code></li>
<li class='green'><span class=''> </span><code> * var MyModel = patio.addModel("testTable", {</code></li>
<li class='green'><span class=''> </span><code> *     plugins : [patio.plugins.TimeStampPlugin],</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *     static : {</code></li>
<li class='green'><span class=''> </span><code> *         init : function(){</code></li>
<li class='green'><span class=''> </span><code> *             this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code> *             this.timestamp({created : "customCreatedColumn"});</code></li>
<li class='green'><span class=''> </span><code> *         }</code></li>
<li class='green'><span class=''> </span><code> *     }</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //set both custom columns</code></li>
<li class='green'><span class=''> </span><code> * var MyModel = patio.addModel("testTable", {</code></li>
<li class='green'><span class=''> </span><code> *     plugins : [patio.plugins.TimeStampPlugin],</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *     static : {</code></li>
<li class='green'><span class=''> </span><code> *         init : function(){</code></li>
<li class='green'><span class=''> </span><code> *             this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code> *             this.timestamp({created : "customCreatedColumn", updated : "myUpdatedColumn"});</code></li>
<li class='green'><span class=''> </span><code> *         }</code></li>
<li class='green'><span class=''> </span><code> *     }</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //Set to update the updated column when row is created</code></li>
<li class='green'><span class=''> </span><code> * var MyModel = patio.addModel("testTable", {</code></li>
<li class='green'><span class=''> </span><code> *     plugins : [patio.plugins.TimeStampPlugin],</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *     static : {</code></li>
<li class='green'><span class=''> </span><code> *         init : function(){</code></li>
<li class='green'><span class=''> </span><code> *             this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code> *             this.timestamp({updateOnCreate : true});</code></li>
<li class='green'><span class=''> </span><code> *         }</code></li>
<li class='green'><span class=''> </span><code> *     }</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * //Set all three options</code></li>
<li class='green'><span class=''> </span><code> * var MyModel = patio.addModel("testTable", {</code></li>
<li class='green'><span class=''> </span><code> *     plugins : [patio.plugins.TimeStampPlugin],</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *     static : {</code></li>
<li class='green'><span class=''> </span><code> *         init : function(){</code></li>
<li class='green'><span class=''> </span><code> *             this._super("arguments");</code></li>
<li class='green'><span class=''> </span><code> *             this.timestamp({created : "customCreatedColumn", updated : "myUpdatedColumn", updateOnCreate : true});</code></li>
<li class='green'><span class=''> </span><code> *         }</code></li>
<li class='green'><span class=''> </span><code> *     }</code></li>
<li class='green'><span class=''> </span><code> * });</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @name TimeStampPlugin</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio.plugins</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>module.exports = exports = define(null, {</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        constructor:function () {</code></li>
<li class='green'><span class='hits'>21</span><code>            this._super(arguments);</code></li>
<li class='green'><span class='hits'>21</span><code>            var options = (this._timestampOptions = this._static._timestampOptions);</code></li>
<li class='green'><span class='hits'>21</span><code>            this._updateColumn = options.updated || "updated";</code></li>
<li class='green'><span class='hits'>21</span><code>            this._createdColumn = options.created || "created";</code></li>
<li class='green'><span class='hits'>21</span><code>            this._updateOnCreate = options.updateOnCreate || false;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getInsertSql:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>            this[this._createdColumn] = new Date();</code></li>
<li class='green'><span class='hits'>3</span><code>            if (this._updateOnCreate) {</code></li>
<li class='green'><span class='hits'>1</span><code>                this[this._updateColumn] = new Date();</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>3</span><code>            return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        getUpdateSql:function () {</code></li>
<li class='green'><span class='hits'>3</span><code>            this[this._updateColumn] = new Date();</code></li>
<li class='green'><span class='hits'>3</span><code>            return this._super(arguments);</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>    static:{</code></li>
<li class='green'><span class=''> </span><code>        /**@lends patio.plugins.TimeStampPlugin*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Adds timestamp functionality to a table.</code></li>
<li class='green'><span class=''> </span><code>         * @param {Object} [options]</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [options.updated="updated"] the name of the column to set the updated timestamp on.</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [options.created="created"] the name of the column to set the created timestamp on</code></li>
<li class='green'><span class=''> </span><code>         * @param {Boolean} [options.updateOnCreate=false] Set to true to set the updated column on creation</code></li>
<li class='green'><span class=''> </span><code>         **/</code></li>
<li class='green'><span class=''> </span><code>        timestamp:function (options) {</code></li>
<li class='green'><span class='hits'>3</span><code>            options = options || {};</code></li>
<li class='green'><span class='hits'>3</span><code>            this._timestampOptions = options;</code></li>
<li class='green'><span class='hits'>3</span><code>            var updateColumn = options.updated || "updated";</code></li>
<li class='green'><span class='hits'>3</span><code>            var createdColumn = options.created || "created";</code></li>
<li class='green'><span class='hits'>3</span><code>            var updateOnCreate = options.updateOnCreate || false;</code></li>
<li class='green'><span class='hits'>3</span><code>            this.pre("save", function (next) {</code></li>
<li class='green'><span class='hits'>12</span><code>                this[createdColumn] = new Date();</code></li>
<li class='green'><span class='hits'>12</span><code>                if (updateOnCreate) {</code></li>
<li class='green'><span class='hits'>4</span><code>                    this[updateColumn] = new Date();</code></li>
<li class='green'><span class=''> </span><code>                }</code></li>
<li class='green'><span class='hits'>12</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>3</span><code>            this.pre("update", function (next) {</code></li>
<li class='green'><span class='hits'>3</span><code>                this[updateColumn] = new Date();</code></li>
<li class='green'><span class='hits'>3</span><code>                next();</code></li>
<li class='green'><span class=''> </span><code>            });</code></li>
<li class='green'><span class='hits'>3</span><code>            return this;</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>});</code></li></ol></pre></div>
</div>

<div class="cov-section cov-section-hover cov-section-all" id="time.js">
    <table class='section-table'>
        <tr>
            <td>
                <div class='cov-section-header'>time.js</div>
            </td>
            <td class="cov-stats">
                <div>
                    <span class='cov-label'>Coverage</span><span class='cov-value'>100.00</span>
                    <span class='cov-label'>SLOC</span><span class='cov-value'>630</span>
                    <span class='cov-label'>LOC</span><span class='cov-value'>72</span>
                    <span class='cov-label'>Missed</span><span class='cov-value'>0</span>
                </div>
            </td>
        </tr>
    </table>
    <div class='source' id="time.js-source"><pre class='prettyprint linenums'><ol class='linenums'><li class='green'><span class='hits'>1</span><code>var comb = require("comb"),</code></li>
<li class='green'><span class=''> </span><code>    PatioError = require("./errors").PatioError,</code></li>
<li class='green'><span class=''> </span><code>    date = comb.date,</code></li>
<li class='green'><span class=''> </span><code>    SQL = require("./sql").sql,</code></li>
<li class='green'><span class=''> </span><code>    define = comb.define,</code></li>
<li class='green'><span class=''> </span><code>    dateFormat = date.format,</code></li>
<li class='green'><span class=''> </span><code>    isDate = comb.isDate,</code></li>
<li class='green'><span class=''> </span><code>    isUndefined = comb.isUndefined,</code></li>
<li class='green'><span class=''> </span><code>    isInstanceOf = comb.isInstanceOf;</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class='hits'>1</span><code>var DEFAULT_DATE_FORMAT = "yyyy-MM-dd";</code></li>
<li class='green'><span class='hits'>1</span><code>var TWO_YEAR_DATE_FORMAT = "yy-MM-dd";</code></li>
<li class='green'><span class='hits'>1</span><code>var DEFAULT_YEAR_FORMAT = "yyyy";</code></li>
<li class='green'><span class='hits'>1</span><code>var DEFAULT_TIME_FORMAT = "HH:mm:ss";</code></li>
<li class='green'><span class='hits'>1</span><code>var DEFAULT_TIMESTAMP_FORMAT = "yyyy-MM-dd HH:mm:ssZ";</code></li>
<li class='green'><span class='hits'>1</span><code>var DEFAULT_DATETIME_FORMAT = "yyyy-MM-dd HH:mm:ssZ";</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>/**</code></li>
<li class='green'><span class=''> </span><code> * Mixin that provides time formatting/coversion functions.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @constructor</code></li>
<li class='green'><span class=''> </span><code> * @name Time</code></li>
<li class='green'><span class=''> </span><code> * @memberOf patio</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> * @property {String}  [dateFormat={@link patio.Time#DEFAULT_DATE_FORMAT}] the format to use to formatting/converting dates.</code></li>
<li class='green'><span class=''> </span><code> * @property {String}  [yearFormat={@link patio.Time#DEFAULT_YEAR_FORMAT}] the format to use to formatting/converting dates.</code></li>
<li class='green'><span class=''> </span><code> * @property {String}  [timeFormat={@link patio.Time#DEFAULT_TIME_FORMAT}] the format to use to formatting/converting dates.</code></li>
<li class='green'><span class=''> </span><code> * @property {String}  [timeStampFormat={@link patio.Time#DEFAULT_TIMESTAMP_FORMAT}] the format to use to formatting/converting dates.</code></li>
<li class='green'><span class=''> </span><code> * @property {String}  [dateTimeFormat={@link patio.Time#DEFAULT_DATETIME_FORMAT}] the format to use to formatting/converting dates.</code></li>
<li class='green'><span class=''> </span><code> *</code></li>
<li class='green'><span class=''> </span><code> */</code></li>
<li class='green'><span class='hits'>1</span><code>define(null, {</code></li>
<li class='green'><span class=''> </span><code>    instance:{</code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @lends patio.Time.prototype</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description default date format.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default  yyyy-MM-dd</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  patio.DEFAULT_DATE_FORMAT = "yyyy MM, dd";</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_DATE_FORMAT:"yyyy-MM-dd",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Two year date format</code></li>
<li class='green'><span class=''> </span><code>         * This is used in date coversions when convertTwoDigitYears is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * If this format fails then dateFormat|DEFAULT_DATE_FORMAT is used.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yy-MM-dd</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.TWO_YEAR_DATE_FORMAT = "yy MM, dd";</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        TWO_YEAR_DATE_FORMAT:"yy-MM-dd",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Default year format</code></li>
<li class='green'><span class=''> </span><code>         * @default yyyy</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.DEFAULT_YEAR_FORMAT = "yy";</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_YEAR_FORMAT:"yyyy",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Default time format</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default HH:mm:ss</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.DEFAULT_TIME_FORMAT = "HH:mm:ss:SS";</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_TIME_FORMAT:"HH:mm:ss",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Default timestamp format</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yyyy-MM-dd HH:mm:ss</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.DEFAULT_TIMESTAMP_FORMAT = "yyyy-MM-dd hh:mm:ss:SS a";</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_TIMESTAMP_FORMAT:"yyyy-MM-dd HH:mm:ss",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Default datetime format</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yyyy-MM-dd HH:mm:ss</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.DEFAULT_DATETIME_FORMAT = "yyyy-MM-dd hh:mm:ss:SS a";</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DEFAULT_DATETIME_FORMAT:"yyyy-MM-dd HH:mm:ss",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Timestamp format used if the default fails. This format includes timezone info.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yyyy-MM-dd HH:mm:ssZ</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        TIMESTAMP_FORMAT_TZ:"yyyy-MM-dd HH:mm:ssZ",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Two year timestamp format. If convertTwoDigitYear is set to true and the timeStampFormat</code></li>
<li class='green'><span class=''> </span><code>         * fails this format will be tried.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yy-MM-dd HH:mm:ss</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        TIMESTAMP_TWO_YEAR_FORMAT:"yy-MM-dd HH:mm:ss",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Datetime format used if the default fails. This format includes timezone info.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yyyy-MM-dd HH:mm:ssZ</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DATETIME_FORMAT_TZ:"yyyy-MM-dd HH:mm:ssZ",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Two year datetime format. If convertTwoDigitYear is set to true and the timeStampFormat</code></li>
<li class='green'><span class=''> </span><code>         * fails this format will be tried.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yy-MM-dd HH:mm:ss</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        DATETIME_TWO_YEAR_FORMAT:"yy-MM-dd HH:mm:ss",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description ISO-8601 format</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default yyyy-MM-ddTHH:mm:ssZ</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ISO_8601:"yyyy-MM-ddTHH:mm:ssZ",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @constant</code></li>
<li class='green'><span class=''> </span><code>         * @type String</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description Two year ISO-8601 format</code></li>
<li class='green'><span class=''> </span><code>         * @default yy-MM-ddTHH:mm:ssZ</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        ISO_8601_TWO_YEAR:"yy-MM-ddTHH:mm:ssZ",</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * @type Boolean</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @description By default patio will try to covert all two digit years.</code></li>
<li class='green'><span class=''> </span><code>         * To turn this off:</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @default true</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         * patio.convertTwoDigitYears = false;</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        convertTwoDigitYears:true,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        __dateFormat:undefined,</code></li>
<li class='green'><span class=''> </span><code>        __yearFormat:undefined,</code></li>
<li class='green'><span class=''> </span><code>        __timeFormat:undefined,</code></li>
<li class='green'><span class=''> </span><code>        __timeStampFormat:undefined,</code></li>
<li class='green'><span class=''> </span><code>        __dateTimeFormat:undefined,</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a {@link patio.sql.Year} to a string.</code></li>
<li class='green'><span class=''> </span><code>         * The format used is {@link patio.Time#yearFormat},</code></li>
<li class='green'><span class=''> </span><code>         * which defaults to {@link patio.Time#DEFAULT_YEAR_FORMAT}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var date = new Date(2004, 1, 1, 1, 1, 1),</code></li>
<li class='green'><span class=''> </span><code>         *     year = new sql.Year(2004);</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearToString(date); //=&gt; '2004'</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearToString(year); //=&gt; '2004'</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearFormat = "yy";</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearToString(date); //=&gt; '04'</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearToString(year); //=&gt; '04'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Date\sql.Year} dt the year to covert to to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @returns {String} the date string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        yearToString:function (dt, format) {</code></li>
<li class='green'><span class='hits'>8</span><code>            return dateFormat(isInstanceOf(dt, SQL.Year) ? dt.date : dt, format || this.yearFormat);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a {@link sql.Time} to a string.</code></li>
<li class='green'><span class=''> </span><code>         * The format used is {@link patio.Time#timeFormat},</code></li>
<li class='green'><span class=''> </span><code>         * which defaults to {@link patio.Time#DEFAULT_TIME_FORMAT}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var date =  new Date(null, null, null, 13, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         *     time = new sql.Time(13,12,12);</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeToString(date); //=&gt; '13:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeToString(time); //=&gt; '13:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeFormat = "hh:mm:ss";</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeToString(date); //=&gt; '01:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeToString(time); //=&gt; '01:12:12'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Date\patio.sql.Time} dt the time to covert to to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @returns {String} the date string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        timeToString:function (dt, format) {</code></li>
<li class='green'><span class='hits'>6</span><code>            return dateFormat(isInstanceOf(dt, SQL.Time) ? dt.date : dt, format || this.timeFormat);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a @link{patio.sql.DateTime} to a string.</code></li>
<li class='green'><span class=''> </span><code>         * The format used is {@link patio.Time#dateTimeFormat},</code></li>
<li class='green'><span class=''> </span><code>         * which defaults to {@link patio.Time#DEFAULT_DATETIME_FORMAT}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var date = new Date(2004, 1, 1, 12, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         * dateTime = new sql.DateTime(2004, 1, 1, 12, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         * offset = "-0600";</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(date); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(dateTime); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.DATETIME_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(date); //=&gt; '04-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(dateTime); //=&gt; '04-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.DATETIME_FORMAT_TZ;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(date); //=&gt; '2004-02-01 12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(dateTime); //=&gt; '2004-02-01 12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.ISO_8601;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(date); //=&gt; '2004-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(dateTime); //=&gt; '2004-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.ISO_8601_TWO_YEAR;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(date); //=&gt; '04-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeToString(dateTime); //=&gt; '04-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Date\patio.sql.DateTime} dt the datetime to covert to to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @returns {String} the date string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        dateTimeToString:function (dt, format) {</code></li>
<li class='green'><span class='hits'>46</span><code>            return dateFormat(isInstanceOf(dt, SQL.DateTime) ? dt.date : dt, format || this.dateTimeFormat);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a {@link patio.sql.TimeStamp} to a string.</code></li>
<li class='green'><span class=''> </span><code>         * The format used is {@link patio.Time#timeStampFormat},</code></li>
<li class='green'><span class=''> </span><code>         * which defaults to {@link patio.Time#DEFAULT_TIMESTAMP_FORMAT}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var date = new Date(2004, 1, 1, 12, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         * dateTime = new sql.TimeStamp(2004, 1, 1, 12, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         * offset = "-0600";</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(date); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(dateTime); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.TIMESTAMP_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(date); //=&gt; '04-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(dateTime); //=&gt; '04-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.TIMESTAMP_FORMAT_TZ;</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(date); //=&gt; '2004-02-01 12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(dateTime); //=&gt; '2004-02-01 12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStamp = patio.ISO_8601;</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(date); //=&gt; '2004-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(dateTime); //=&gt; '2004-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStamp = patio.ISO_8601_TWO_YEAR;</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(date); //=&gt; '04-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampToString(dateTime); //=&gt; '04-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Date\patio.sql.TimeStamp} dt the timestamp to convert to to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @returns {String} the date string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        timeStampToString:function (dt, format) {</code></li>
<li class='green'><span class='hits'>21</span><code>            return dateFormat(isInstanceOf(dt, SQL.TimeStamp) ? dt.date : dt, format || this.timeStampFormat);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a date to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var date = new Date(2004, 1, 1),</code></li>
<li class='green'><span class=''> </span><code>         * timeStamp = new sql.TimeStamp(2004, 1, 1, 12, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         * dateTime = new sql.DateTime(2004, 1, 1, 12, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         * year = new sql.Year(2004),</code></li>
<li class='green'><span class=''> </span><code>         * time = new sql.Time(12,12,12),</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //convert years</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(year); //=&gt; '2004'</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearFormat = "yy";</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(year); //=&gt; '04'</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearFormat = patio.DEFAULT_YEAR_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(year); //=&gt; '2004'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //convert times</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(time); //=&gt; '12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * //convert dates</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(date); //=&gt; '2004-02-01'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateFormat = patio.TWO_YEAR_DATE_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(date); //=&gt; '04-02-01'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateFormat = patio.DEFAULT_DATE_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(date); //=&gt; '2004-02-01'</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>         * //convert dateTime</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(dateTime); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.DATETIME_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(dateTime); //=&gt; '04-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.DATETIME_FORMAT_TZ;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(dateTime); //=&gt; '2004-02-01 12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.ISO_8601;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(dateTime); //=&gt; '2004-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.ISO_8601_TWO_YEAR;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(dateTime); //=&gt; '04-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.DEFAULT_DATETIME_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(dateTime); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>         * //convert timestamps</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(timeStamp); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.TIMESTAMP_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(timeStamp); //=&gt; '04-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.TIMESTAMP_FORMAT_TZ;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(timeStamp); //=&gt; '2004-02-01 12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.ISO_8601;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(timeStamp); //=&gt; '2004-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.ISO_8601_TWO_YEAR;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(timeStamp); //=&gt; '04-02-01T12:12:12-0600'</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.DEFAULT_TIMESTAMP_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateToString(timeStamp); //=&gt; '2004-02-01 12:12:12'</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {Date\patio.sql.Time|patio.sql.Year|patio.sql.DateTime|patio.sql.TimeStamp} dt the date to covert to to a string.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @returns {String} the date string.</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        dateToString:function (dt, format) {</code></li>
<li class='green'><span class='hits'>61</span><code>            var ret = "";</code></li>
<li class='green'><span class='hits'>61</span><code>            if (isInstanceOf(dt, SQL.Time)) {</code></li>
<li class='green'><span class='hits'>2</span><code>                ret = this.timeToString(dt, format);</code></li>
<li class='green'><span class='hits'>59</span><code>            } else if (isInstanceOf(dt, SQL.Year)) {</code></li>
<li class='green'><span class='hits'>4</span><code>                ret = this.yearToString(dt, format);</code></li>
<li class='green'><span class='hits'>55</span><code>            } else if (isInstanceOf(dt, SQL.DateTime)) {</code></li>
<li class='green'><span class='hits'>34</span><code>                ret = this.dateTimeToString(dt, format);</code></li>
<li class='green'><span class='hits'>21</span><code>            } else if (isInstanceOf(dt, SQL.TimeStamp)) {</code></li>
<li class='green'><span class='hits'>9</span><code>                ret = this.timeStampToString(dt, format);</code></li>
<li class='green'><span class='hits'>12</span><code>            } else if (isDate(dt)) {</code></li>
<li class='green'><span class='hits'>12</span><code>                ret = dateFormat(dt, format || this.dateFormat);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>61</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a year date string to a {@link patio.sql.Year}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var year = new sql.Year(2004);</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToYear("2004"); //=&gt; year</code></li>
<li class='green'><span class=''> </span><code>         * patio.yearFormat = "yy";</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToYear("04"); //=&gt; year</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} dt the string to covert to a {@link patio.sql.Year}</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [format=patio.Time#yearFormat] the format to use when converting the date.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {PatioError} thrown if the conversion fails.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.Year} the {@link patio.sql.Year}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        stringToYear:function (dt, format) {</code></li>
<li class='green'><span class='hits'>5</span><code>            var ret = date.parse(dt, format || this.yearFormat);</code></li>
<li class='green'><span class='hits'>5</span><code>            if (!ret) {</code></li>
<li class='green'><span class='hits'>1</span><code>                throw new PatioError("Unable to convert year: " + dt);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>4</span><code>            return new SQL.Year(ret);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a time date string to a {@link patio.sql.Time}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var time = new sql.Time(12,12,12);</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToTime("12:12:12"); //=&gt; time</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} dt the string to convert to a {@link patio.sql.Time}</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [format=patio.Time#timeFormat] the format to use when converting the date.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {PatioError} thrown if the conversion fails.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.Time} the {@link patio.sql.Time}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        stringToTime:function (dt, format) {</code></li>
<li class='green'><span class='hits'>12</span><code>            var ret = date.parse(dt, format || this.timeFormat);</code></li>
<li class='green'><span class='hits'>12</span><code>            if (!ret) {</code></li>
<li class='green'><span class='hits'>7</span><code>                throw new PatioError("Unable to convert time: " + dt);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>5</span><code>            return new SQL.Time(ret);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a date string to a Date</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * var date = new Date(2004, 1,1,0,0,0);</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToDate('2004-02-01'); //=&gt; date</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateFormat = patio.TWO_YEAR_DATE_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToDate('04-02-01'); //=&gt; date</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} dt the string to convert to a Date</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [format=patio.Time#dateFormat] the format to use when converting the date.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {PatioError} thrown if the conversion fails.</code></li>
<li class='green'><span class=''> </span><code>         * @return {Date} the {@link Date}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        stringToDate:function (dt, format) {</code></li>
<li class='green'><span class='hits'>19</span><code>            var ret;</code></li>
<li class='green'><span class='hits'>19</span><code>            if (this.convertTwoDigitYears) {</code></li>
<li class='green'><span class='hits'>19</span><code>                ret = date.parse(dt, this.TWO_YEAR_DATE_FORMAT);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>19</span><code>            if (!ret) {</code></li>
<li class='green'><span class='hits'>9</span><code>                ret = date.parse(dt, format || this.dateFormat);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>19</span><code>            if (!ret) {</code></li>
<li class='green'><span class='hits'>9</span><code>                throw new PatioError("Unable to convert date: " + dt);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>10</span><code>            return ret;</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a datetime date string to a {@link patio.sql.DateTime}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  var dateTime = new sql.DateTime(2004, 1, 1, 12, 12, 12),</code></li>
<li class='green'><span class=''> </span><code>         * offset = getTimeZoneOffset();</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToDateTime('2004-02-01 12:12:12'); //=&gt; dateTime</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.DATETIME_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToDateTime('04-02-01 12:12:12-0600'); //=&gt; dateTime</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.DATETIME_FORMAT_TZ;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToDateTime('2004-02-01 12:12:12-0600'); //=&gt; dateTime</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.ISO_8601;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToDateTime('2004-02-01T12:12:12-0600'); //=&gt; dateTime</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.dateTimeFormat = patio.ISO_8601_TWO_YEAR;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToDateTime('04-02-01T12:12:12-0600'); //=&gt; dateTime</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} dt the string to convert to a {@link patio.sql.DateTime}</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [format=patio.Time#dateTimeFormat] the format to use when converting the date.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {PatioError} thrown if the conversion fails.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.DateTime} the {@linkpatio.sql.DateTime}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        stringToDateTime:function (dt, fmt) {</code></li>
<li class='green'><span class='hits'>21</span><code>            var useT = dt.indexOf("T") != -1;</code></li>
<li class='green'><span class=''> </span><code>            //test if there is a T in the string so we can try to properly convert it</code></li>
<li class='green'><span class='hits'>21</span><code>            var format = fmt ? fmt : useT ? this.ISO_8601 : this.DEFAULT_DATETIME_FORMAT;</code></li>
<li class='green'><span class='hits'>21</span><code>            var ret = date.parse(dt, format);</code></li>
<li class='green'><span class=''> </span><code>            //if the coversion failed try it with a time zone</code></li>
<li class='green'><span class='hits'>21</span><code>            !ret &amp;&amp; (ret = date.parse(dt, this.DATETIME_FORMAT_TZ));</code></li>
<li class='green'><span class='hits'>21</span><code>            if (!ret &amp;&amp; this.convertTwoDigitYears) {</code></li>
<li class='green'><span class=''> </span><code>                //if we still fail and we need to convert two digit years try the twoYearFormat</code></li>
<li class='green'><span class='hits'>10</span><code>                var twoYearFormat = fmt ? fmt : useT ? this.ISO_8601_TWO_YEAR : this.DATETIME_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class='hits'>10</span><code>                ret = date.parse(dt, twoYearFormat);</code></li>
<li class='green'><span class=''> </span><code>                //try with time zone</code></li>
<li class='green'><span class='hits'>10</span><code>                !ret &amp;&amp; (ret = date.parse(dt, twoYearFormat + "Z"));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>21</span><code>            if (!ret) {</code></li>
<li class='green'><span class='hits'>10</span><code>                throw new PatioError("Unable to convert datetime: " + dt);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>11</span><code>            return new SQL.DateTime(ret);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**</code></li>
<li class='green'><span class=''> </span><code>         * Converts a timestamp date string to a {@link patio.sql.TimeStamp}</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @example</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         *  var timeStamp = new sql.TimeStamp(2004, 1, 1, 12, 12, 12);</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToTimeStamp('2004-02-01 12:12:12'); //=&gt; timeStamp</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.TIMESTAMP_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToTimeStamp('04-02-01 12:12:12-0600'); //=&gt; timeStamp</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.TIMESTAMP_FORMAT_TZ;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToTimeStamp('2004-02-01 12:12:12-0600'); //=&gt; timeStamp</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.ISO_8601;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToTimeStamp('2004-02-01T12:12:12-0600'); //=&gt; timeStamp</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * patio.timeStampFormat = patio.ISO_8601_TWO_YEAR;</code></li>
<li class='green'><span class=''> </span><code>         * patio.stringToTimeStamp('04-02-01T12:12:12-0600'); //=&gt; timeStamp</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} dt the string to convert to a {@link patio.sql.TimeStamp}</code></li>
<li class='green'><span class=''> </span><code>         * @param {String} [format=patio.Time#timeStampFormat] the format to use when converting the date.</code></li>
<li class='green'><span class=''> </span><code>         *</code></li>
<li class='green'><span class=''> </span><code>         * @throws {PatioError} thrown if the conversion fails.</code></li>
<li class='green'><span class=''> </span><code>         * @return {patio.sql.TimeStamp} the {@link patio.sql.TimeStamp}</code></li>
<li class='green'><span class=''> </span><code>         */</code></li>
<li class='green'><span class=''> </span><code>        stringToTimeStamp:function (dt, fmt) {</code></li>
<li class='green'><span class='hits'>50</span><code>            var useT = dt.indexOf("T") != -1;</code></li>
<li class='green'><span class=''> </span><code>            //test if there is a T in the string so we can try to properly convert it</code></li>
<li class='green'><span class='hits'>50</span><code>            var format = fmt ? fmt : useT ? this.ISO_8601 : this.DEFAULT_TIMESTAMP_FORMAT;</code></li>
<li class='green'><span class='hits'>50</span><code>            var ret = date.parse(dt, format);</code></li>
<li class='green'><span class=''> </span><code>            //if the coversion failed try it with a time zone</code></li>
<li class='green'><span class='hits'>50</span><code>            !ret &amp;&amp; (ret = date.parse(dt, this.TIMESTAMP_FORMAT_TZ));</code></li>
<li class='green'><span class='hits'>50</span><code>            if (!ret &amp;&amp; this.convertTwoDigitYears) {</code></li>
<li class='green'><span class=''> </span><code>                //if we still fail and we need to convert two digit years try the twoYearFormat</code></li>
<li class='green'><span class='hits'>4</span><code>                var twoYearFormat = fmt ? fmt : useT ? this.ISO_8601_TWO_YEAR : this.TIMESTAMP_TWO_YEAR_FORMAT;</code></li>
<li class='green'><span class='hits'>4</span><code>                ret = date.parse(dt, twoYearFormat);</code></li>
<li class='green'><span class=''> </span><code>                //try with time zone</code></li>
<li class='green'><span class='hits'>4</span><code>                !ret &amp;&amp; (ret = date.parse(dt, twoYearFormat + "Z"));</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>50</span><code>            if (!ret) {</code></li>
<li class='green'><span class='hits'>4</span><code>                throw new PatioError("Unable to convert timestamp: " + dt);</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class='hits'>46</span><code>            return new SQL.TimeStamp(ret);</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        getters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            dateFormat:function (format) {</code></li>
<li class='green'><span class='hits'>21</span><code>                return isUndefined(this.__dateFormat) ? this.DEFAULT_DATE_FORMAT : this.__dateFormat;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            yearFormat:function (format) {</code></li>
<li class='green'><span class='hits'>13</span><code>                return isUndefined(this.__yearFormat) ? this.DEFAULT_YEAR_FORMAT : this.__yearFormat;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            timeFormat:function (format) {</code></li>
<li class='green'><span class='hits'>17</span><code>                return isUndefined(this.__timeFormat) ? this.DEFAULT_TIME_FORMAT : this.__timeFormat;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            timeStampFormat:function (format) {</code></li>
<li class='green'><span class='hits'>20</span><code>                return isUndefined(this.__timeStampFormat) ? this.DEFAULT_TIMESTAMP_FORMAT : this.__timeStampFormat;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            dateTimeFormat:function (format) {</code></li>
<li class='green'><span class='hits'>19</span><code>                return isUndefined(this.__dateTimeFormat) ? this.DEFAULT_DATETIME_FORMAT : this.__dateTimeFormat;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        },</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>        /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>        setters:{</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code></code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            dateFormat:function (format) {</code></li>
<li class='green'><span class='hits'>6</span><code>                this.__dateFormat = format;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            yearFormat:function (format) {</code></li>
<li class='green'><span class='hits'>6</span><code>                this.__yearFormat = format;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            timeFormat:function (format) {</code></li>
<li class='green'><span class='hits'>2</span><code>                this.__timeFormat = format;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            timeStampFormat:function (format) {</code></li>
<li class='green'><span class='hits'>15</span><code>                this.__timeStampFormat = format;</code></li>
<li class='green'><span class=''> </span><code>            },</code></li>
<li class='green'><span class=''> </span><code>            /**@ignore*/</code></li>
<li class='green'><span class=''> </span><code>            dateTimeFormat:function (format) {</code></li>
<li class='green'><span class='hits'>15</span><code>                this.__dateTimeFormat = format;</code></li>
<li class='green'><span class=''> </span><code>            }</code></li>
<li class='green'><span class=''> </span><code>        }</code></li>
<li class='green'><span class=''> </span><code>    }</code></li>
<li class='green'><span class=''> </span><code>}).as(module);</code></li></ol></pre></div>
</div>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script type="text/javascript">
    $(function () {
        //$(".source").hide();
        $(".cov-section").click(function () {
            var id = this.id;
            $(document.getElementById(id + "-source")).slideToggle();
        });
    });
</script>
</body>
</html>