<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>

    <title>Patio - Associations</title>
    <meta name="generator" content="JsDoc Toolkit"/>
    <link type="text/css" href="./api/css/default.css" rel="stylesheet"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"
            charset="utf-8"></script>
    <script type="text/javascript" src="./api/js/doc.js"></script>
    <script type="text/javaScript" src="./api/js/chili/jquery.chili-2.2.js"></script>
    <script type="text/javaScript" src="./api/js/chili/recipes.js"></script>
</head>
<!--[if gte IE 9]>
<style type="text/css">
    * {
        filter: none !important;
    }
</style>
<![endif]-->
<style type="text/css">
    .featureList li {
        margin: 10px;
    }
</style>
<body>

<a href="http://github.com/doug-martin/patio-query" target="_blank">
    <img style="position: absolute; top: 0; right: 0; border: 0;"
         src="https://a248.e.akamai.net/assets.github.com/img/71eeaab9d563c2b3c590319b398dd35683265e85/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
         alt="Fork me on GitHub">
</a>


<div class="menuContainer">
    <div class="menuContainerContent">
        <ul>
            <li><span
                    class='nodeContainer'><a href="./index.html" class=""><span>Patio</span></a></span></li>
            <li><span class='nodeContainer'><a href="./api/index.html" target="_blank"
                                               class=""><span>API</span></a></span></li>
            <li>
                <span class='nodeContainer'>
                    <a href="./connecting.html" class="">
                        <span>Connecting to a database</span>
                    </a>
                </span>
            </li>
            <li>
                <span class='nodeContainer'>
                    <a href="./DDL.html.html" class="">
                        <span>Schema CRUD</span>
                    </a>
                </span>
            </li>
        </ul>
    </div>
</div>
<div class="contentContainer">
    <div id="content">
        <div class="section">
            <h1 class="classTitle">DDL</h1>

            <div class="methodDetail">
                <h3><a href="./api/symbols/patio.plugins.AssociationPlugin.html#.oneToMany">patio.Model.oneToMany</a></h3>

                <p>
One of the most common forms of associations. One to Many is the inverse of Many to one.
One to Many often describes a parent child relationship, where the One To Many {@link patio.Model}
is the parent, and the many to one model is the child.

<p>For example consider a BiologicalFather and his children. The father can have many children,
    but a child can have only one Biological Father.</p>

<p>
    Assuming you have the following table structure:
</p>
<pre class='code'>
biological_father       child
--------------          ---------------------------
|id  | name  |          |id | bio_father_id  | name |
--------------          ---------------------------
| 1  | Fred  |          | 1 |     1        | Bobby |
| 2  | Ben   |  ------> | 2 |     1        | Alice |
| 3  | Bob   |          | 3 |     1        | Susan |
| 4  | Scott |          | 4 |     4        | Brad  |
--------------          ---------------------------

//set up camelization so that properties can be camelcase but will be inserted
//snake case (i.e. 'biologicalFather' becomes 'biological_father').
patio.camelize = true;
DB.createTable("biologicalFather", function(){
    this.primaryKey("id");
    this.name(String);
});
DB.createTable("child", function(){
    this.primaryKey("id");
    this.name(String);
    this.foreignKey("bioFatherId", "biologicalFather", {key : "id"});
});
</pre>
<p>
    The table biological_father has four fathers in it. Each row in child has a bio_father_id that is a foreign
    key to biologcal father. Fred hash 3 children(Bobby, Alice, and Susan) while Scott has 1 child Brad.
</p>
<p>
    You could represent the OneToMany association as follows:
</p>
<pre class="code">
comb.executeInOrder(patio, function(patio){
     //define the BiologicalFather model
     patio.addModel("biologicalFather", {
         static : {
             init : function(){
                 this.oneToMany("children");
             }
         }
     });

     //define Child  model
     patio.addModel("child", {
         static : {
             init : function(){
                 this.manyToOne("biologicalFather");
             }
         }
     });
     //Create data
     var BiologicalFather = patio.getModel("biologicalFather");
     BiologicalFather.save([
           {name:"Fred", children:[
                   {name:"Bobby"},
                   {name:"Alice"},
                   {name:"Susan"}
           ]},
           {name:"Ben"},
           {name:"Bob"},
           {name:"Scott", children:[
                   {name:"Brad"}
           ]}
     ]);
});
</pre>
<p>
    Above we created a BiologicalFather and Child model. The BiologicalFather has a static initializer(init)
    that sets up the oneToMany association with the Child. The Child also has a static initializer that sets
    up the ManyToOne association with the BiologicalFather. When saving {@link patio.Model}s that have
    associations in {@link patio} you can nest the associations directly. The models set up above are
    <b>"LAZY"</b> loaded meaning the associations are not loaded until the association is accessed.
</p>
<p>
    You can query each model by:
</p>
<pre class="code">
var BiologicalFather = patio.getModel("biologicalFather");
Child.findById(1).then(function(child){
    child.biologicalFather.then(function(father){
         //father.name === "fred"
    });
});

BioFather.findById(1).then(function(father){
    father.children.then(function(children){
        //children.length === 3
    });
});
</pre>
<p>
    An "EAGER" model and query would look like this:
</p>
<pre class="code">
comb.executeInOrder(patio, function(patio){
     //define the biological father model
     patio.addModel("biologicalFather", {
         static : {
             init : function(){
                 this.oneToMany("children", {fetchType : this.fetchType.EAGER});
             }
         }
     });

     //define Person  model
     patio.addModel("child", {
         static : {
             init : function(){
                 this.manyToOne("biologicalFather", {fetchType : this.fetchType.EAGER});
             }
         }
     });
     var Child = patio.getModel("child");
       //now you can use the associations with out a promise.
     Child.findById(1).then(function(child){
         var father = child.biologicalFather;
         //father.name === "fred"
         //father.children.length === 3
    });
});

</pre>
@param {String} name the alias of the association. The key you provide here is how the association
will be looked up on instances of this model.
@param {Object} [options] additional options to specify the behavior of the association.
@param {String} [options.model] the table name of the model that this Model is associated with. This property
can usually be determined by the name of the association.
@param {patio.plugins.AssociationPlugin.fetchType.EAGER|patio.plugins.AssociationPlugin.fetchType.EAGER}
[options.fetchType=AssociationPlugin.fetchType.LAZY] how fetch the association, if specified to lazy
then the association is lazy loaded. Otherwise the association is loaded when the model is loaded.
@param {Object|String} [options.key] The key option must be used if the default column that {@link patio}
would use is not the correct column. For example:
<pre class="code">
 patio.addModel("biologicalFather", {
      static : {
          init : function(){
              //assumes the key is biologicalFatherId,
              this.oneToMany("children");
          }
      }
});

patio.addModel("child", {
    static : {
        init : function(){
           //assumes the key is biologicalFatherId
           this.manyToOne("biologicalFather");
        }
    }
});
 </pre>
If you schema looked like this
@param {String|Object} [options.orderBy] column or columns to order the associated model by.
@param {Function} filter Custom filter to define a custom association.
The filter is called in the scope of model that the association is added to.
Say we have a model called BioFather that is a one to many to a model called Child.
<pre class="code">
BioFather.oneToMany("children", {
                  model : Child.tableName,
                  fetchType : BioFather.fetchType.EAGER,
                  filter : function(){
                      return  Child.filter({bioFatherId : this.id});
                  }
               });